\begin{Def}
	\textit{Универсальный алгоритм} $U(n, x) = \langle n \rangle (x)$; запускает алгоритм с номером $n$ на входе $x$.
\end{Def}
\begin{Def}
	\textit{Диагональная функция} $u(n) = U(n, n)$; скармливает алгоритму с номером $n$ на вход его собственный номер.
\end{Def}
\begin{Rem}
	$u(n)$ определена не везде, например, есть алгоритмы, которые никогда не останавливаются.
\end{Rem}

\begin{theorem}
	Функцию $u$ нельзя вычислимо доопределить до всюду определённой функции.
\end{theorem}
\begin{proof}
	Пусть $u \colon W \to \No$, а мы хотим найти такую $u' \colon \No \to \No$, что $\forall x \in W \colon u'(x)=u(x)$.

	Доказательство от противного: пусть есть вычислимая $u'$.
	Давайте рассмотрим функцию $d(n)=u'(n)+1$ "--- она также вычислима и во всех точках отличается от $u$.
	Пусть $\#d$ "--- номер алгоритма, вычисляющего $d$.
	Так как $d$ вычислима, то $\#d \in W$.
	Тогда рассмотрим $u$ в точке $\#d$:
	\[ u(\#d) = \langle \#d \rangle (\#d) = d(\#d) = u'(\#d) + 1 \neq u(\#d) \]
	Получаем противоречие, так как в точке $\#d$ значения $u$ и $u'$ должны совпадать.
\end{proof}

\setauthor{Надежда Бугакова}

\begin{conseq}
	Множество $W = \{n \mid \langle n \rangle(n)\text{~останавливается}\}$ перечислимо, но не разрешимо.
\end{conseq}
\begin{proof}
	В самом деле, это множество "--- просто область определения диагональной функции, которая является вычислимой.
	Если бы $W$ было разрешимым, то можно было бы доопределить $u$ до всюду определённой (взяв разрешающий алгоритм для $W$ и скомбинировав его с $u$),
	что противоречит только что доказанной теореме.
\end{proof}

\begin{conseq}
	 Множество $\overline{W} = \{n \mid \langle n\rangle(n)\text{~не останавливается}\}$ неперечислимо.
\end{conseq}
\begin{proof}
	\begin{itemize}
		\item
			Если бы $\overline{W}$ было бы перечислимо и $W$ было бы перечислимо, то $W$ было бы разрешимо, что неверно.
		\item
			Альтернативное доказательство: пусть $\overline{W}$ перечислимо $\Rightarrow$ полуразрешимо.
			Пусть $A$ "--- полуразрешающий алгоритм.
			Тогда возможны два варианта:
			$\left[
				\begin{alignedat}{2}
				\#A \in W            &\Rightarrow A(\#A) &\text{~останавливается}    &\Rightarrow \#A \in \overline{W}\text{, противоречие} \\
				\#A \in \overline{W} &\Rightarrow A(\#A) &\text{~не останавливается} &\Rightarrow \#A \in W           \text{, противоречие}
				\end{alignedat}
			\right.$
	\end{itemize}
\end{proof}

\section{$m$-сведение}
Теперь мы хотим научиться доказывать неразрешимость других множеств.
Делать это будем при помощи метода сведения: сводим неразрешимую задачу к искомой и тем самым доказываем, что искомая неразрешима.

\begin{Def}
	Пусть $A, B \subset \No$, тогда \textit{$A$ $m$-сводится к $B$} (обозначается $A \le_m B$),
	если существует вычислимая и всюда определённая функция $f$ такая, что:
	\[ x \in A \iff f(x) \in B \]
\end{Def}
\begin{Rem}
	Интуиция за определением такая: $B$ в некотором смысле <<не проще>> $A$, т.е. решили $B$ $\Ra$ решили $A$.
\end{Rem}

Свойства сведения:
\begin{enumerate}
	\item Если $A \le_m B$ и $B$ разрешимо, то $A$ разрешимо.
		\begin{proof}
			Раз $B$ разрешимо, то есть разрешающий алгоритм $B'$.
			Построим разрешающий алгоритм $A'$: $A'(x)=B'(f(x))$ "--- всегда завершается.
		\end{proof}
	\item Если $A \le_m B$ и $B$ перечислимо, то $A$ перечислимо.
		\begin{proof}
			Раз $B$ перечислимо, то есть полуразрешающий алгоритм $B'$.
			Построим полуразрешающий алгоритм $A'$ в точности как в предыдущем пункте.
			Значит, $A$ полуразрешимо и, следовательно, перечислимо.
		\end{proof}
	\item Транзитивность: если $A \le_m B \le_m C$, то $A \le_m C$.
		\begin{proof}
			Пусть есть функция $f$ для $m$-сведения $A$ к $B$ и функция $g$ для $m$-сведения $B$ к $C$.
			То есть:
			\[
				\left.
				\begin{array}{c}
					x \in A \iff f(x) \in B \\
					y \in B \iff g(y) \in C
				\end{array}
				\right\}
				\Ra
				x \in A \iff g(f(x)) \in C
			\]
		\end{proof}
\end{enumerate}

$H = \{(n, x)|$<n>(x) останавливается \}  $W \le_m H$

$H_0$ = \{n|<n>(0) останавливается \} $W \le_m H_0$ : $n\in W \Leftrightarrow$ <n>(n) останавливается $\Leftrightarrow f(n) \in H_0$, где
$f: n \rightarrow $ \#'запускает <n>(n)'

\begin{assertion}
	$H_A = \{x|A(x)$ останавливается\} A - алгоритм. $\exists$ алгоритм A: $H_A$ - неразрешимо.
\end{assertion}
\begin{proof}
	A = U(n, x) 
	
	$H \le_m H_A$, f: (n, x) $\rightarrow$ (n, x)
\end{proof}

\section{Формальное определение алгоритма}
\begin{enumerate}
	\item Программа с конечным количеством переменных
	\item Все переменные принимают произвольные натуральные значения
	\item Команды a++, a--
	\item Строки нумеруются
	\item Есть команда goto(n) (где n не переменная, а число).
	\item Есть условный оператор if (a > 0) then goto $s_1$ else goto $s_2$ (сравнение только с 0)
	\item Есть команда stop, завершающая программу
\end{enumerate}

Будем считать, что все переменные в начале забиты 0, в переменной $x$ содержится вход, а если программа остановилась(stop), то
в $y$ будет выход.

\begin{exmp} .\\
	\begin{enumerate}
		\item Присваивание переменной нулю: z := 0.
		\begin{listing}[1]{1}
if z > 0 then goto 2 else goto 4
z--
goto 1
stop    \end{listing}
		\item a := b
		\begin{listing}[1]{1}
a := 0
c := 0
В цикле пока b > 0
	b--
	a++
	c++
В цикле пока c > 0
	c--
	b++ \end{listing}
	\item a := b + c
	\begin{listing}[1]{1}
a := b
d := c
Пока d > 0
	d--
	a++ 
	\end{listing}
	\item a := bc
	\item Возведение в степень
	\item Деление с остатком
	\item Проверка на простоту
	\item Вычитание
	\item Сравнение
	\item Нахождение n-го простого числа
	\item Массивы! ($\alpha_1, \dots, \alpha_k$) $\rightarrow$ $p_1^{\alpha_1}p_2^{\alpha_2}\dots p_k^{\alpha_k}$
	\end{enumerate}
\end{exmp} 


\section{Задача(язык) FRACTRAN: by Конвей.} 

$r_1, r_2, \dots, r_k > 0 \in \Q$, $m \in \{1, 2, 3, \dots\} = \N$

Ход: min i: $m{r_i} \in \N \Rightarrow m := mr_i$, если такого i нет, то процесс останавливается.

По начальным данным ($\{r_i\}$ и m) определить, закончиться ли процесс?

\begin{exmp} .\\ 
	\begin{enumerate}
		\item $\frac{2}{3}$ $\frac{3}{2}$, m = 2. Процесс не остановится
		\item $\frac{2}{3}$ $\frac{1}{17}$, m = 3. Процесс остановится.
	\end{enumerate}
\end{exmp}

\begin{assertion}
	Нет алгоритма, решающего эту задачу.
\end{assertion}
\begin{proof}
	$H \le_m$ FRACTRAN = множество таких $\{r_i\}$ и m, что процесс остановится. Если мы покажем, что Н сводится к FRACTRAN, то мы победили.

	\begin{Def}
		Состояние памяти программы - это значение всех переменных и номер строки программы.
	\end{Def}

	Пусть у нас три переменных, они соответсвуют числу $2^a3^b5^c$. Тогда номер строки мы будем обозначать $p \in \P, p > 7$. То есть нумеровать
	строки простыми числами, начиная с 7.

	Тогда состояния памяти можно записать, как число $m = 2^a3^b5^cp$, где $p$ - номер строки. Теперь закодируем команды.

	\begin{enumerate}
		\item 
		7. a++   $\leftrightarrow$ $m\frac{22}{7}$ ($m = 2^a3^b5^c7 \rightarrow m = 2^{a + 1}3^b5^c11$)
		
		11.		
		\item 
		7. a--   $\leftrightarrow$ $m\frac{11}{14}$
		
		11.
		\item 
		7. goto 13 $\leftrightarrow$ $m\frac{13}{7}$
		\item 
		7. if a > 0 then goto 13 else goto 17

		Рассмотрим первую ветку. По хорошему, надо проверить, что m делится на 2 и тогда перейти на нужную строчку. Хороший способ - попробовать
		поделить. Если число было нечётное, то после домножения на $13/(2\cdot7)$ оно станет не целым и по правилу мы не сможем применить
		это преобразование. Но тогда значение a уменьшится вдвое, если мы таки пойдём по первой ветке...

		Но мы говорим, что ничего страшного, так как можно считать, что условный оператор так и работает и переписать код под новый условный 
		оператор.

		Тогда условному оператору соответсвуют две дроби: $\frac{13}{7\cdot2}$ и $\frac{17}{7}$
		\item 
		23. stop  $\leftrightarrow$ $1/23$ Это значит, что мы остановимся, так как для выполнения какой-то строчки мы должны поделит на простое,
		большое большее 5, а после выполнения этой строчки в памяти останутся только переменные($m = 2^a3^b5^c$).
	\end{enumerate}

	Итого, мы построили по программе задачу FRACTRAN, те написали программу на языке FRACTRAN. В том числе мы пострили сведение задачи останова
	к FRATRAN.
\end{proof}

\section{Одноленточная машина Тьюринга}
Имеется бесконечная лента, на которой изначально записан вход.

\cimg{02_1.jpg}{0.5}

$\Sigma$ -алфавит символов, которые используются на ленте.
$\blacktriangleright$ - символ начала ленты, далее входа в ячейках записаны пробелы(бесконечное число).

Есть каретка, которая всегда указывает на какую-нибудь ячейку, изначально она указывает на первый символ после начала ленты.

Q - конечное множество состояний. $q_0$ - начальное состояние, $q_f$ - конечное состояние. 

$\delta: Q \times \Sigma \longrightarrow Q \times \Sigma \times \{\leftarrow, 
\rightarrow, \cdot\}$ ($\cdot$ - стоять на месте, стрелочки - соответственно передвинуться, то есть мы записываем какой-то символ в ячейку,
куда указывает каретка, а затем двигаемся и переходим в новое состояние).

Результат работы - то, что написано на ленте до бесконечного числа пробелов в конце программы.

\begin{exmp} .\\
	\begin{enumerate}
		\item ВХОД $\longrightarrow$ УХОД

		($q_0$, B) $\longrightarrow$ ($q_f$, У, $\rightarrow$)
		\item Хотим к числу, которое нам дано в двоичной записи, прибавить 1: 11001 + 1 = 00101 (то есть записано оно справа налево)

		($q_0$, 0) $\longrightarrow$ ($q_f$, 1, $\cdot$)

		($q_0$, 1) $\longrightarrow$ ($q_0$, 0, $\rightarrow$)

		($q_0$, \textvisiblespace) $\longrightarrow$ ($q_f$, 1, $\cdot$)
		\item Теперь число двоичное, но записано слева направо. И тоже хотим прибавить 1: 10011 + 1 = 10100

		($q_0$, 0/1) $\longrightarrow$ ($q_0$, 0/1, $\rightarrow$)

		($q_0$, \textvisiblespace) $\longrightarrow$ ($q_1$, \textvisiblespace, $\leftarrow$)

		($q_1$, 1) $\longrightarrow$ ($q_1$, 0, $\rightarrow$)

		($q_1$, 0) $\longrightarrow$ ($q_f$, 1, $\cdot$)

		($q_1$, $\blacktriangleright$) $\longrightarrow$ ($q_2$, $\blacktriangleright$, $\rightarrow$)

		($q_2$, 0) $\longrightarrow$ ($q_3$, 1, $\rightarrow$)

		($q_3$, 0/1) $\longrightarrow$ ($q_3$, 0/1, $\rightarrow$)

		($q_3$, \textvisiblespace) $\longrightarrow$ ($q_f$, 0, $\cdot$)
	\end{enumerate}	
\end{exmp}
