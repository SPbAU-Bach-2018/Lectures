\begin{Def}
	\textit{Универсальный алгоритм} $U(n, x) = \langle n \rangle (x)$; запускает алгоритм с номером $n$ на входе $x$.
\end{Def}
\begin{Def}
	\textit{Диагональная функция} $u(n) = U(n, n)$; скармливает алгоритму с номером $n$ на вход его собственный номер.
\end{Def}
\begin{Rem}
	$u(n)$ определена не везде, например, есть алгоритмы, которые никогда не останавливаются.
\end{Rem}

\begin{theorem}
	Функцию $u$ нельзя вычислимо доопределить до всюду определённой функции.
\end{theorem}
\begin{proof}
	Пусть $u \colon W \to \No$, а мы хотим найти такую $u' \colon \No \to \No$, что $\forall x \in W \colon u'(x)=u(x)$.

	Доказательство от противного: пусть есть вычислимая $u'$.
	Давайте рассмотрим функцию $d(n)=u'(n)+1$ "--- она также вычислима и во всех точках отличается от $u$.
	Пусть $\#d$ "--- номер алгоритма, вычисляющего $d$.
	Так как $d$ вычислима, то $\#d \in W$.
	Тогда рассмотрим $u$ в точке $\#d$:
	\[ u(\#d) = \langle \#d \rangle (\#d) = d(\#d) = u'(\#d) + 1 \neq u(\#d) \]
	Получаем противоречие, так как в точке $\#d$ значения $u$ и $u'$ должны совпадать.
\end{proof}

\setauthor{Надежда Бугакова}

\begin{conseq}
	Множество $W = \{n \mid \langle n \rangle(n)\text{~останавливается}\}$ перечислимо, но не разрешимо.
\end{conseq}
\begin{proof}
	В самом деле, это множество "--- просто область определения диагональной функции, которая является вычислимой.
	Если бы $W$ было разрешимым, то можно было бы доопределить $u$ до всюду определённой (взяв разрешающий алгоритм для $W$ и скомбинировав его с $u$),
	что противоречит только что доказанной теореме.
\end{proof}

\begin{conseq}
	 Множество $\overline{W} = \{n \mid \langle n\rangle(n)\text{~не останавливается}\}$ неперечислимо.
\end{conseq}
\begin{proof}
	\begin{itemize}
		\item
			Если бы $\overline{W}$ было бы перечислимо и $W$ было бы перечислимо, то $W$ было бы разрешимо, что неверно.
		\item
			Альтернативное доказательство: пусть $\overline{W}$ перечислимо $\Rightarrow$ полуразрешимо.
			Пусть $A$ "--- полуразрешающий алгоритм.
			Тогда возможны два варианта:
			$\left[
				\begin{alignedat}{2}
				\#A \in W            &\Rightarrow A(\#A) &\text{~останавливается}    &\Rightarrow \#A \in \overline{W}\text{, противоречие} \\
				\#A \in \overline{W} &\Rightarrow A(\#A) &\text{~не останавливается} &\Rightarrow \#A \in W           \text{, противоречие}
				\end{alignedat}
			\right.$
	\end{itemize}
\end{proof}

\section{$m$-сведение}
Теперь мы хотим научиться доказывать неразрешимость других множеств.
Делать это будем при помощи метода сведения: сводим неразрешимую задачу к искомой и тем самым доказываем, что искомая неразрешима.

\begin{Def}
	Пусть $A, B \subset \No$, тогда \textit{$A$ $m$-сводится к $B$} (обозначается $A \le_m B$),
	если существует вычислимая и всюда определённая функция $f$ такая, что:
	\[ x \in A \iff f(x) \in B \]
\end{Def}
\begin{Rem}
	Интуиция за определением такая: $B$ в некотором смысле <<не проще>> $A$, т.е. решили $B$ $\Ra$ решили $A$.
\end{Rem}

Свойства сведения:
\begin{enumerate}
	\item Если $A \le_m B$ и $B$ разрешимо, то $A$ разрешимо.
		\begin{proof}
			Раз $B$ разрешимо, то есть разрешающий алгоритм $B'$.
			Построим разрешающий алгоритм $A'$: $A'(x)=B'(f(x))$ "--- всегда завершается.
		\end{proof}
	\item Если $A \le_m B$ и $B$ перечислимо, то $A$ перечислимо.
		\begin{proof}
			Раз $B$ перечислимо, то есть полуразрешающий алгоритм $B'$.
			Построим полуразрешающий алгоритм $A'$ в точности как в предыдущем пункте.
			Значит, $A$ полуразрешимо и, следовательно, перечислимо.
		\end{proof}
	\item Транзитивность: если $A \le_m B \le_m C$, то $A \le_m C$.
		\begin{proof}
			Пусть есть функция $f$ для $m$-сведения $A$ к $B$ и функция $g$ для $m$-сведения $B$ к $C$.
			То есть:
			\[
				\left.
				\begin{array}{c}
					x \in A \iff f(x) \in B \\
					y \in B \iff g(y) \in C
				\end{array}
				\right\}
				\Ra
				x \in A \iff g(f(x)) \in C
			\]
		\end{proof}
\end{enumerate}

\begin{exmp}
	Называется <<проблема останова>> (<<halting problem>>).
	\[ H = \{(n, x) \mid \langle n \rangle(x)\text{~останавливается} \} \]
\end{exmp}
\begin{proof}
	Выполним $m$-сведение $W$ к $H$ (которое про остановку алгоритма на входе из себя самого):
	\begin{gather*}
		f(n) = (n, n) \\
		n \in W \iff f(n) = (n, n) \in H
	\end{gather*}
	Мы уже знаем, что $W$ перечислимо и неразрешимо, значит, $H$ тоже перечислимо и неразрешимо.
\end{proof}
\begin{Rem}
	Вообще говоря, перечислимость $H$ можно доказать проще: имеется очевидный полуразрешающий алгоритм:
	для пары $(n, x)$ запускаем $\langle n \rangle(x)$ и заменяем вывод на единицу.
\end{Rem}

\begin{exmp}
	$H_0 = \{n \mid \langle n \rangle(0)\text{~останавливается} \}$.
\end{exmp}
\begin{proof}
	Покажем, что $W \le_m H_0$.
	Хотим следующего:
	\[ n \in W \iff \langle n \rangle(n)\text{~останавливается} \iff f(n) \in H_0 \iff \langle f(n) \rangle (0)\text{~останавливается} \]
	Тогда скажем, что
	\[ f(n) = \#\{\text{алгоритм, независимо от входа запускающий~}\langle n \rangle(n) \} \]
\end{proof}

\begin{exmp}
	Пусть $H_A = \{x \mid A(x)\text{~останавливается}\}$, где $A$ "--- алгоритм.
	Тогда существует алгоритм $A$ такой, что $H_A$ неразрешимо.
\end{exmp}
\begin{proof}
	Возьмём $A = U(n, x)$.
	Сведём задачу останова ($H \le_m H_a$):
	\begin{gather*}
		f(n, x) = (n, x) \\
		(n, x) \in H \iff \langle n \rangle (x)\text{~останавливается}\iff U(n, x)\text{~останавливается} \iff \\
		\iff (n, x) \in H_a \iff f(n, x) \in H_a
	\end{gather*}
\end{proof}

\section{Формальное определение алгоритма}
\begin{enumerate}
	\item Программа с конечным количеством переменных, массивов нет
	\item Все переменные принимают произвольные значения из $\No$
	\item Команды: \t{a++}, \t{a--} (для конкретных переменных)
	\item Строки явно нумеруются (как в старых языках вроде BASIC)
	\item Есть команда \t{goto($n$)} (где $n$ "--- не переменная, а число), обозначает <<перейти к строке с номером $n$>>
	\item Есть условный оператор \t{if (a > 0) then goto $s_1$ else goto $s_2$}, где $s_1$ и $s_2$ "--- константы, сравнение только с нулём и только одного типа
	\item Есть команда \t{stop}, завершающая программу
\end{enumerate}

Будем считать, что все переменные в начале забиты 0, в переменной $x$ содержится вход, а если программа остановилась (\t{stop}), то
в $y$ будет выход.

\begin{exmp}
	Можно выразить все <<естественные>> операции из языков программирования:
	\begin{enumerate}
		\item Присваивание переменной нулю: \t{z := 0}.
		\begin{listing}[1]{1}
if z > 0 then goto 2 else goto 4
z--
goto 1
stop    \end{listing}
		\item \t{a := b}
		\begin{listing}[1]{1}
a := 0
c := 0
В цикле пока b > 0
	b--
	a++
	c++
В цикле пока c > 0
	c--
	b++ \end{listing}
	\item \t{a := b + c}
	\begin{listing}[1]{1}
a := b
d := c
Пока d > 0
	d--
	a++ 
	\end{listing}
	\item \t{a := bc}
	\item Возведение в степень
	\item Деление с остатком
	\item Проверка на простоту
	\item Вычитание
	\item Сравнение
	\item Нахождение $n$-го простого числа
	\item Массивы! ($\alpha_1, \dots, \alpha_k$) $\rightarrow$ $p_1^{\alpha_1}p_2^{\alpha_2}\dots p_k^{\alpha_k}$ (где $p_i$ "--- различные простые числа)
	\end{enumerate}
\end{exmp} 


\section{Задача FRACTRAN}
Придумана Джоном Конвеем, автором игры <<Жизнь>>.
Вообще говоря, это даже язык программирования.

Имеется $k+1$ переменных: $r_1, r_2, \dots, r_k > 0 \in \Q$ и переменная $m \in \{1, 2, 3, \dots\} = \N$.

За один ход ищется такое минимальное $i$, что $mr_i \in \N$ и значение $m$ заменяется на $mr_i$.

Вопрос: по начальным данным ($\{r_i\}$ и $m$) определить, закончиться ли процесс?

\begin{exmp}
	\hfill
	\begin{enumerate}
		\item $\frac{2}{3}$ $\frac{3}{2}$, m = 2. Процесс не остановится.
		\item $\frac{2}{3}$ $\frac{1}{17}$, m = 3. Процесс остановится.
	\end{enumerate}
\end{exmp}

\begin{assertion}
	Нет алгоритма, решающего эту задачу.
\end{assertion}
\begin{proof}
	Пусть $FRACTRAN =$ множество таких $\{r_i\}$ и $m$, что процесс остановится.
	Если мы покажем, что $Н$ сводится к $FRACTRAN$, то мы победили.
	То есть нужно по программе (для задачи останова) построить что-то аналогичное на FRACTRAN.

	\begin{Def}
		Состояние памяти программы "--- это значение всех переменных и номер строки программы.
	\end{Def}

	Пусть у нас три переменных, они соответсвуют числу $2^a3^b5^c$.
	Тогда номер строки мы будем обозначать $p \in \mathbb{P}, p > 7$.
	То есть нумеровать строки простыми числами, начиная с 7.
	Для большего количества переменных "--- аналогично.

	Тогда состояния памяти можно записать, как число $m = 2^a3^b5^cp$, где $p$ "--- номер строки.
	Теперь закодируем команды.

	\begin{itemize}
		\item
\begin{abstractcode}
7.  a++ // текущая команда
11.     // следующая команда
\end{abstractcode}
			Кодируем дробью $\frac{2\cdot 11}{7}$.
			Если сработало, то $m = 2^a3^b5^c7 \rightarrow m = 2^{a + 1}3^b5^c11$.
		
		\item
\begin{abstractcode}
7.  a--
11.
\end{abstractcode}
			Кодируем $\frac{11}{2\cdot 14}$.
		
		\item
\begin{abstractcode}
7. goto 13
\end{abstractcode}
Кодируем $\frac{13}{7}$.

		\item 
\begin{abstractcode}
7. if a > 0 then goto 13 else goto 17
\end{abstractcode}

			Рассмотрим первую ветку.
			По-хорошему надо проверить, что $m$ делится на 2, и тогда перейти на нужную строчку.
			Хороший способ "--- попробовать поделить.
			Если число было нечётное, то после домножения на $\frac{13}{2\cdot}$ оно станет нецелым и по правилу мы не сможем применить это преобразование.
			Но тогда значение $a$ уменьшится на единицу, если мы-таки пойдём по первой ветке, что не очень хорошо.

			Но мы говорим, что ничего страшного, так как можно считать, что условный оператор так и работает и переписать код под новый условный оператор
			(который после успешного перехода уменьшает значение переменной на единицу).

			Тогда новому условному оператору соответсвуют две дроби (по одной под каждый переход, в таком порядке):
			$\frac{13}{7\cdot2}$ и $\frac{17}{7}$.
		\item 
\begin{abstractcode}
23. stop
\end{abstractcode}
			Кодируем как $\frac{1}{23}$.
			Это значит, что мы остановимся, так как для выполнения какой-то строчки мы должны поделить на простое,
			строго большее 5 (так как в знаменателе каждой дроби есть номер строки), а после обработки дроби $\frac{1}{23}$ в памяти останутся только переменные ($m = 2^a3^b5^c$).
	\end{itemize}

	Итого: мы построили по программе задачу FRACTRAN, т.е. написали программу на языке FRACTRAN.
	В том числе мы пострили $m$-сведение задачи останова к FRAСTRAN: если бы решался FRACTRAN, то задача останова тоже бы решалась.
\end{proof}

\section{Одноленточная машина Тьюринга}
Имеется бесконечная лента, на которой изначально записан вход.

\cimg{02_1.jpg}{0.5}

$\Sigma$ -алфавит символов, которые используются на ленте.
$\blacktriangleright$ - символ начала ленты, после входа в ячейках записаны пробелы (бесконечное число).

Есть каретка, которая всегда указывает на какую-нибудь ячейку, изначально она указывает на первый символ после начала ленты.

Q "--- конечное множество состояний.
$q_0$ "--- начальное состояние, $q_f$ "--- конечное состояние.

Есть правила переходов:
\[ \delta: Q \times \Sigma \longrightarrow Q \times \Sigma \times \{\leftarrow, \rightarrow, \cdot\} \]
По символу под картекой и текущему состоянию мы пишем какой-то новый символ, переходим в новое состояние и можем опционально сдвинуть каретку
($\cdot$ "--- стоять на месте, стрелочки "--- движение).

Результат работы "--- то, что после завершения программы написано на ленте до бесконечного числа пробелов.

\begin{exmp}
	\hfill
	\begin{enumerate}
		\item
			Хотим преобразовать \t{ВХОД} $\longrightarrow$ \t{УХОД}

			Правило перехода: $(q_0, \t{B}) \longrightarrow (q_f, \t{У}, \rightarrow)$.

		\item
			Хотим к числу, которое нам дано в двоичной записи, прибавить 1: 11001 + 1 = 00101 (то есть записано оно на ленте справа налево).
			\begin{itemize}
			\item ($q_0$, 0) $\longrightarrow$ ($q_f$, 1, $\cdot$)
			\item ($q_0$, 1) $\longrightarrow$ ($q_0$, 0, $\rightarrow$)
			\item ($q_0$, \textvisiblespace) $\longrightarrow$ ($q_f$, 1, $\cdot$)
			\end{itemize}

		\item
			Теперь число двоичное, но записано слева направо. И тоже хотим прибавить 1: 10011 + 1 = 10100
			\begin{itemize}
			\item ($q_0$, 0/1) $\longrightarrow$ ($q_0$, 0/1, $\rightarrow$)
			\item ($q_0$, \textvisiblespace) $\longrightarrow$ ($q_1$, \textvisiblespace, $\leftarrow$)
			\item ($q_1$, 1) $\longrightarrow$ ($q_1$, 0, $\rightarrow$)
			\item ($q_1$, 0) $\longrightarrow$ ($q_f$, 1, $\cdot$)
			\item ($q_1$, $\blacktriangleright$) $\longrightarrow$ ($q_2$, $\blacktriangleright$, $\rightarrow$)
			\item ($q_2$, 0) $\longrightarrow$ ($q_3$, 1, $\rightarrow$)
			\item ($q_3$, 0/1) $\longrightarrow$ ($q_3$, 0/1, $\rightarrow$)
			\item ($q_3$, \textvisiblespace) $\longrightarrow$ ($q_f$, 0, $\cdot$)
			\end{itemize}
	\end{enumerate}	
\end{exmp}
