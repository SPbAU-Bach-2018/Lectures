\setauthor{Надежда Бугакова}

W = \{n| <n>(n) - останавливается\} - перечислима. $\Rightarrow$ $\bar{W}$ = \{n| <n>(n) не останавливается\} - неперечеслимо
\begin{proof}
	$1^{\circ}$ Если бы $\bar{W}$ было бы перечислимо, то W было бы разрешимо, что(мы доказывали ранее) не так.

	$2^{\circ}$ Альтернативное доказательство. Пусть $\bar{W}$ перечислимо $\Rightarrow$ полуразрешимо. A - полуразрешающий алгоритм.


	$\left[
		\begin{aligned}
		&\#A \in W \Rightarrow A(\#A) \text{останавливается} \Rightarrow \#A \in \overline{W}\text{, противоречие} \\
		&\#A \in \overline{W} \Rightarrow A(\#A) \text{не останавливается} \Rightarrow \#A \in W\text{, противоречие}
		\end{aligned}
	\right.$

\end{proof}

$A \le_m B$, если $x \in A \Leftrightarrow f(x) \in B$

$H = \{(n, x)|$<n>(x) останавливается \}  $W \le_m H$

$H_0$ = \{n|<n>(0) останавливается \} $W \le_m H_0$ : $n\in W \Leftrightarrow$ <n>(n) останавливается $\Leftrightarrow f(n) \in H_0$, где
$f: n \rightarrow $ \#'запускает <n>(n)'

\begin{assertion}
	$H_A = \{x|A(x)$ останавливается\} A - алгоритм. $\exists$ алгоритм A: $H_A$ - неразрешимо.
\end{assertion}
\begin{proof}
	A = U(n, x) 
	
	$H \le_m H_A$, f: (n, x) $\rightarrow$ (n, x)
\end{proof}

\section{Формальное определение алгоритма}
\begin{enumerate}
	\item Программа с конечным количеством переменных
	\item Все переменные принимают произвольные натуральные значения
	\item Команды a++, a--
	\item Строки нумеруются
	\item Есть команда goto(n) (где n не переменная, а число).
	\item Есть условный оператор if (a > 0) then goto $s_1$ else goto $s_2$ (сравнение только с 0)
	\item Есть команда stop, завершающая программу
\end{enumerate}

Будем считать, что все переменные в начале забиты 0, в переменной $x$ содержится вход, а если программа остановилась(stop), то
в $y$ будет выход.

\begin{exmp} .\\
	\begin{enumerate}
		\item Присваивание переменной нулю: z := 0.
		\begin{listing}[1]{1}
if z > 0 then goto 2 else goto 4
z--
goto 1
stop    \end{listing}
		\item a := b
		\begin{listing}[1]{1}
a := 0
c := 0
В цикле пока b > 0
	b--
	a++
	c++
В цикле пока c > 0
	c--
	b++ \end{listing}
	\item a := b + c
	\begin{listing}[1]{1}
a := b
d := c
Пока d > 0
	d--
	a++ 
	\end{listing}
	\item a := bc
	\item Возведение в степень
	\item Деление с остатком
	\item Проверка на простоту
	\item Вычитание
	\item Сравнение
	\item Нахождение n-го простого числа
	\item Массивы! ($\alpha_1, \dots, \alpha_k$) $\rightarrow$ $p_1^{\alpha_1}p_2^{\alpha_2}\dots p_k^{\alpha_k}$
	\end{enumerate}
\end{exmp} 


\section{Задача(язык) FRACTRAN: by Конвей.} 

$r_1, r_2, \dots, r_k > 0 \in \Q$, $m \in \{1, 2, 3, \dots\} = \N$

Ход: min i: $m{r_i} \in \N \Rightarrow m := mr_i$, если такого i нет, то процесс останавливается.

По начальным данным ($\{r_i\}$ и m) определить, закончиться ли процесс?

\begin{exmp} .\\ 
	\begin{enumerate}
		\item $\frac{2}{3}$ $\frac{3}{2}$, m = 2. Процесс не остановится
		\item $\frac{2}{3}$ $\frac{1}{17}$, m = 3. Процесс остановится.
	\end{enumerate}
\end{exmp}

\begin{assertion}
	Нет алгоритма, решающего эту задачу.
\end{assertion}
\begin{proof}
	$H \le_m$ FRACTRAN = множество таких $\{r_i\}$ и m, что процесс остановится. Если мы покажем, что Н сводится к FRACTRAN, то мы победили.

	\begin{Def}
		Состояние памяти программы - это значение всех переменных и номер строки программы.
	\end{Def}

	Пусть у нас три переменных, они соответсвуют числу $2^a3^b5^c$. Тогда номер строки мы будем обозначать $p \in \P, p > 7$. То есть нумеровать
	строки простыми числами, начиная с 7.

	Тогда состояния памяти можно записать, как число $m = 2^a3^b5^cp$, где $p$ - номер строки. Теперь закодируем команды.

	\begin{enumerate}
		\item 
		7. a++   $\leftrightarrow$ $m\frac{22}{7}$ ($m = 2^a3^b5^c7 \rightarrow m = 2^{a + 1}3^b5^c11$)
		
		11.		
		\item 
		7. a--   $\leftrightarrow$ $m\frac{11}{14}$
		
		11.
		\item 
		7. goto 13 $\leftrightarrow$ $m\frac{13}{7}$
		\item 
		7. if a > 0 then goto 13 else goto 17

		Рассмотрим первую ветку. По хорошему, надо проверить, что m делится на 2 и тогда перейти на нужную строчку. Хороший способ - попробовать
		поделить. Если число было нечётное, то после домножения на $13/(2\cdot7)$ оно станет не целым и по правилу мы не сможем применить
		это преобразование. Но тогда значение a уменьшится вдвое, если мы таки пойдём по первой ветке...

		Но мы говорим, что ничего страшного, так как можно считать, что условный оператор так и работает и переписать код под новый условный 
		оператор.

		Тогда условному оператору соответсвуют две дроби: $\frac{13}{7\cdot2}$ и $\frac{17}{7}$
		\item 
		23. stop  $\leftrightarrow$ $1/23$ Это значит, что мы остановимся, так как для выполнения какой-то строчки мы должны поделит на простое,
		большое большее 5, а после выполнения этой строчки в памяти останутся только переменные($m = 2^a3^b5^c$).
	\end{enumerate}

	Итого, мы построили по программе задачу FRACTRAN, те написали программу на языке FRACTRAN. В том числе мы пострили сведение задачи останова
	к FRATRAN.
\end{proof}

\section{Одноленточная машина Тьюринга}
Имеется бесконечная лента, на которой изначально записан вход.

%\cimg{02_1.jpg}{0.5}

$\Sigma$ -алфавит символов, которые используются на ленте.
$\blacktriangleright$ - символ начала ленты, далее входа в ячейках записаны пробелы(бесконечное число).

Есть каретка, которая всегда указывает на какую-нибудь ячейку, изначально она указывает на первый символ после начала ленты.

Q - конечное множество состояний. $q_0$ - начальное состояние, $q_f$ - конечное состояние. 

$\delta: Q \times \Sigma \longrightarrow Q \times \Sigma \times \{\leftarrow, 
\rightarrow, \cdot\}$ ($\cdot$ - стоять на месте, стрелочки - соответственно передвинуться, то есть мы записываем какой-то символ в ячейку,
куда указывает каретка, а затем двигаемся и переходим в новое состояние).

Результат работы - то, что написано на ленте до бесконечного числа пробелов в конце программы.

\begin{exmp} .\\
	\begin{enumerate}
		\item ВХОД $\longrightarrow$ УХОД

		($q_0$, B) $\longrightarrow$ ($q_f$, У, $\rightarrow$)
		\item Хотим к числу, которое нам дано в двоичной записи, прибавить 1: 11001 + 1 = 00101 (то есть записано оно справа налево)

		($q_0$, 0) $\longrightarrow$ ($q_f$, 1, $\cdot$)

		($q_0$, 1) $\longrightarrow$ ($q_0$, 0, $\rightarrow$)

		($q_0$, \textvisiblespace) $\longrightarrow$ ($q_f$, 1, $\cdot$)
		\item Теперь число двоичное, но записано слева направо. И тоже хотим прибавить 1: 10011 + 1 = 10100

		($q_0$, 0/1) $\longrightarrow$ ($q_0$, 0/1, $\rightarrow$)

		($q_0$, \textvisiblespace) $\longrightarrow$ ($q_1$, \textvisiblespace, $\leftarrow$)

		($q_1$, 1) $\longrightarrow$ ($q_1$, 0, $\rightarrow$)

		($q_1$, 0) $\longrightarrow$ ($q_f$, 1, $\cdot$)

		($q_1$, $\blacktriangleright$) $\longrightarrow$ ($q_2$, $\blacktriangleright$, $\rightarrow$)

		($q_2$, 0) $\longrightarrow$ ($q_3$, 1, $\rightarrow$)

		($q_3$, 0/1) $\longrightarrow$ ($q_3$, 0/1, $\rightarrow$)

		($q_3$, \textvisiblespace) $\longrightarrow$ ($q_f$, 0, $\cdot$)
	\end{enumerate}	
\end{exmp}