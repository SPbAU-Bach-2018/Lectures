\section{Теорема о неподвижной точке}
\setauthor{Егор Суворов, Анастасия Старкова}

\begin{theorem}[о неподвижной точке, теорема Клини о рекурсии]\label{fixedPoint}
	Для любой всюду определённой вычислимой функции $h$ существует $m \in \No$ такая, что $h(m) \equiv m$.
\end{theorem}
\begin{proof}
	Будет \href{fixedPointProof}{позже}, после следствий.
\end{proof}

\begin{conseq}
	\href{UspenskyRice}{Теорема Успенского-Райса}:
	пусть $S$ инвариантно, $S \ne \varnothing$, $S \ne \No$, тогда $S$ неразрешимо.
\end{conseq}
\begin{proof}
	Пусть $S$ разрешимо.
	Возьмём произвольный $a \in S$ и $b \notin S$.
	По инвариантности $S$ знаем, что $a \not\equiv b$.
	Построим всюду определённую функцию $h(x)$ (это можно сделать, так как мы предположили разрешимость $S$):
	\[
		h(x) =
		\begin{cases}
			a, &x \notin S \\
			b, &x \in S \\
		\end{cases}
	\]
	По теореме о неподвижной точке существует такое $m$, что $h(m) \equiv m$.
	Два случая:
	\begin{itemize}
		\item
			$m \in S \Ra h(m) = b$, но $b \notin S$ $\Ra h(m) \not\equiv m$
		\item
			$m \notin S \Ra h(m) = a$, но $a \in S$ $\Ra h(m) \not\equiv m$
	\end{itemize}
	Противоречие.
\end{proof}

\begin{conseq}
	Существует алгоритм, печатающий в точности свой номер.
\end{conseq}
\begin{proof}
	Положим $h(x) = \#(\t{print x})$.
	По теореме о неподвижной точке найдём такое $m$, что $h(m) \equiv m$.
	Тогда $\langle m \rangle \equiv \t{print m}$, то есть эквивалентен какому-то, печатающему $m$, то есть $\langle m \rangle$ печатает $m$.
\end{proof}

\begin{Rem}
	Как можно описать программы, печатающие свой текст (<<квайны>>, quine): пусть есть команда \t{print2 x}, которая
	эквивалентна \t{print x, ' "', x, '"'}.
	Тогда можно написать квайн \t{print2 "print2"}
\end{Rem}

\begin{Def}
	Вычислимая функция $f$ \textit{$\equiv$-продолжает} вычислимую функцию $g$ до всюду определённой вычислимой, если:
	\begin{enumerate}
	\item $f$ всюду определена
	\item если $g(x)$ определена, то $g(x) \equiv f(x)$
	\end{enumerate}
\end{Def}


\label{fixedPointProof}
Для доказательства теоремы \ref{fixedPoint} (о неподвижной точке) нам потребуется еще одна, вспомогательная
(которая, разумеется, теоремой о неподвижной точке не пользуется):
\begin{theorem}\label{equivFuncExtend}
	Любую вычислимую функцию $g$ можно $\equiv$-продолжить до всюду определённой вычислимой.
\end{theorem}
\begin{Rem}
	У нас была похожая теорема \ref{diagonalFunc} про диагональную функцию, и там мы показывали, что её нельзя доопределить.
	Отличие в том, что в этой теореме мы не требуем точного совпадения значений функций, а лишь эквивалентности этих значений.
\end{Rem}
\begin{proof}
	Пусть алгоритм $B$ вычисляет $g$ (и зацикливается на не-области определения).
	Тогда рассмотрим алгоритм $A(n, x)=\langle B(n) \rangle(x)$.
	Разумеется, при $n$ не из области определения $g$ алгоритм $A_n$ всегда зацикливается, потому что не может вычислить $B(n)$.

	Теперь рассмотрим функцию $f(n) = \# A_n$.
	Эта функция всюду определена.
	Более того, пусть $g(n)$ определена, тогда $f(n) \equiv \# A_n \equiv \# \langle g(n) \rangle \equiv g(n)$.
	Таким образом, $f$ является искомой функцией.
\end{proof}

Теперь доказательство теоремы о неподвижной точке:
\begin{proof}
	Вспомним диагональную функцию $u(n) = \langle n \rangle(n)$.
	По теореме \ref{equivFuncExtend} найдём $\equiv$-продолжение $u$ "--- функцию $g(n)$.
	У нас в условии фигурировала функция $h$ (у которой мы ищем неподвижную точку),
	давайте рассмотрим функцию $t(n)=h(g(n))=(h \circ g)(n)$.
	Это всюду определённая функция (так как и $h$, и $g$ всюду определены).
	Теперь заметим, что:
	\[ u(\# t) = \langle \# t \rangle (\# t) = t(\# t) = h(g(\# t)) \]
	С другой стороны, так как $g$ есть $\equiv$-продолжение $u$ и $u(\# t)$ определена:
	\[ u(\# t) \equiv g(\# t) \]
	Таким образом имеем $h(g(\# t)) \equiv g(\# t)$.
	Положив $m=g(\# t)$ получим неподвижную точку $m$ для функции $h$, что и требовалось доказать.
\end{proof}
Другое доказательство, менее формальное:
\begin{proof}
	Возьмём какой-нибудь язык программирования и расширим его функциями:
	\begin{itemize}
		\item \t{getProgramText()} "--- возвращает текст текущей программы (как квайн)
		\item \t{execute(s)} "--- выполняет программу, текст которой передан, как параметр
		\item
			\t{computeH(s)} "--- вычисляет $h$ в точке $s$ (например, если туда передан текст программы, то в точке $\# s$).
			Это можно реализовать, так как $h$ всюду вычислима.
	\end{itemize}
	Теперь пишем программу $m$:
	\begin{abstractcode}
s = getProgramText();
s = computeH(s);
execute(s);
	\end{abstractcode}
	То есть эта программа при запуске $m()$ применяёт $h$ к самой себе и выполняет результатирующий алгоритм.
	С другой стороны, если запустить $h(m)()$, то результат будет тот же: $h$ вычислит значение в $m$, а результат потом запустим.
	Таким образом, $h(m) \equiv m$, что и требовалось.
\end{proof}

\section{Нумерации}
\begin{Def}
	Вычислимая функция $U(n, x)$ называется \textit{универсальной вычислимой функцией} или \textit{нумерацией}, если для любой
	вычислимой $f$ существует такое $m$, что $\forall x \colon f(x) = U(m, x)$.
\end{Def}
\begin{Def}
	Универсальная вычислимая функция $U(n, x$) называется \textit{главной}, если для любой вычислимой функции $V(n, x)$
	есть всюду определённая вычислимая $S$ такая, что:
	\[ V(n, x) = U(S(n), x) \]
	То есть существует способ <<переформулировки программ>> с любого языка $V$ на язык $U$.
\end{Def}
\begin{exmp}
	$U(n, x) = \langle n \rangle(x)$ (универсальный алгоритм) является универсальной вычислимой функцией.
\end{exmp}
\begin{proof}
	Возьмём какую-нибудь вычислимую функцию $V(n, x)$.
	Переобозначим $V(n, x)=V_n(x)$, $V_n$ "--- тоже какие-то вычислимые функции.
	Положим $S(n)=\# V_n$.
	Тогда:
	\[ U(S(n), x) = U(\# V_n, x) = V_n(x) = V(n, x) \]
\end{proof}

\begin{theorem}[о неподвижной точке в главной нумерации $W(n, x)$]
	Пусть $h(x)$ "--- всюду определённая вычислимая функция.
	Тогда существует такое $m$, что $W(m, x) = W(h(m), x)$ для любого $x$.
\end{theorem}

\section{Арифметичность предикатов}
\subsection{Напоминание}
Сначала определим предикатные формулы (как в прошлом году).

У нас есть множества предикатных символов ($\mathcal P$) и функциональных символов ($\mathcal F$) с фиксированными арностями
(у разных символов арности могут отличаться).
Например, в арифметике было $\mathcal P = \{ = \}$, $\mathcal F = \{ *, + \}$.
\begin{Def}
	Терм "--- либо переменная ($x$, $y$, $a_{3}$), либо $f(t_1, t_2, \dots, t_k)$, где $f \in \mathcal F$, а $t_i$ "--- термы.

	То есть терм "--- это формула из переменных и функциональных символов, например: $(x+y) \cdot z + x$.
\end{Def}
\begin{Def}
	Атомарная формула "--- это $p(t_1, \dots, t_k)$, где $p \in \mathcal P$, а $t_i$ "--- термы.

	То есть это условие на термы, например: $x+y=z\cdot \alpha$.
\end{Def}
\begin{Def}
	Предикатная формула "--- это одно из нескольких:
	\begin{itemize}
		\item Атомарная формула
		\item Комбинация предикатных формул $A$ и $B$: $A \lor B$, $A \land B$, $\lnot A$, $(A)$, $A \Ra B$
		\item Предикатная формула с добавленным квантора по переменной $x$: $\forall x \colon A$ или $\exists x \colon A$
	\end{itemize}
\end{Def}

Теперь придаём смысл формулам.
\begin{Def}
	Пусть есть \textit{носитель интерпретации} "--- множество $M$,
	для каждого предикатного символа арности $k$ есть функция $M^k \to \{ 0, 1 \}$,
	а для каждого функционального символа арности $l$ есть функция $M^k \to M$.

	Тогда мы можем естественным образом <<проверить>> истинность предикатной формулы "--- это и будет \textit{интерпретацией} формулы.
\end{Def}

\begin{Def}
	Предикат $p \colon M^k \to \{ 0, 1 \}$ является \textit{выразимым}, если есть некоторая
	предикатная формула $P$ с $k$ свободными переменными (то есть не участвующими в кванторах),
	которая задаёт в точности этот предикат (то есть значения предиката и формулы совпадают на всех значениях переменных).
\end{Def}

\begin{Def}
	Арифметический предикат "--- это предикат, выразимый в арифметике.
	Носителем в арифметике является $\No = \N \cup \{0\}$, а символами $\mathcal P = \{ = \}$, $\mathcal F = \{ *, + \}$ с естественными смыслом в неотрицательных целых числах.
\end{Def}

Примеры выразимых предикатов:
\[
	\begin{array}{|l|l|}
		\hline
		x = 0 & \forall y \colon y + x = y \\\hline
		x = 1 & \forall y \colon y \cdot x = y \\\hline
		x = 238 & \forall y \colon (y = 1) \Ra x = \underbrace{y + y + \dots + y}_{238\text{ слагаемых}} \\\hline
		x \ge y & \exists z \colon x = y + z \\\hline
		x > y & \exists z \colon \lnot(z=0) \land x = y + z \\\hline
		x \bmod y = z & \exists k \colon (x = y \cdot k + z) \land (z < y) \\\hline
		x \text{"--- простое} & (\forall z \colon (x \vdots z) \Ra (z = x) \lor (z = 1)) \land \lnot (x = 1) \\\hline
	\end{array}
\]
