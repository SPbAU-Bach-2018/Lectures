\chapter{Вычислимость}
\section{Введение}
Будем пользоваться интуитивным определением понятия \textit{Алгоритм}.
Скажем лишь то, что он удовлетворяет некоторым условиям:
\begin{enumerate}
    \item Получает на вход строку из $\Sigma^*$ "--- множества строк над заданным алфавитом $\Sigma$
    \item Либо закончит работу и выдаст строку из $\Sigma^*$, либо никогда не закончит работу
    \item Его можно записать
    \item Его можно исполнять по шагам
    \item Может использовать бесконечное количество памяти
\end{enumerate}

\begin{Def}
	Обозначим множество целых неотрицательных чисел:
	\[ \No = \N \cup \{ 0 \} \]
\end{Def}

Счётных множеств у нас будет много.
Например, построим биекцию между строками и натуральными числами на примере $\Sigma = \{a, b\}$:
\begin{itemize}
\item $0 \ra$ пустая строка
\item $1\ra a$
\item $2\ra b$
\item $3\ra aa$
\item $4\ra ab$
\item $\dots$ и так далее
\end{itemize}
Дальше будем считать, что алгоритмы могут вместо строк принимать на вход элементы $\No$ "--- как нам удобнее.

\section{Разрешимые, перечислимые множества. Вычислимые функции}

\begin{Def}
	$A \subset \No$ называется \textit{разрешимым}, если существует алгоритм, который выдаёт единицу для чисел, лежащих в $A$, и ноль для чисел, не лежащих в $A$:
	\[ \exists Algo \colon Algo(x) =
	\begin{cases}
		1, &x \in A \\
		0, &x \notin A
	\end{cases}
	\]
\end{Def}
\begin{Rem}
	Время работы алгоритма нам сейчас неинтересно: лишь бы оно было конечно.
\end{Rem}

Примеры разрешимых множеств:
\begin{enumerate}
	\item Пустое множество: алгоритм, выводящий $0$
	\item $\N$: алгоритм, выводящий $1$
	\item Произвольное конечное множество $A$: алгоритм, по очереди сравнивающий параметр с каждым элементом
	\item $\{q \in \Q \mid q < e\}$ (как мы помним, рациональных чисел тоже счётно, поэтому можно считать, что алгоритму на вход даётся некоторое рациональное число)
		\begin{proof}
		В самом деле, мы умеем сколь угодно хорошо приближать $e$ следующими соотношениями:
		\[ \left(1+\frac1n\right)^n < e < \left(1+\frac1n\right)^{n+1} \]
		Значит, если у нас есть некоторое рациональное число (которое точно не равно $e$), то, взяв достаточно большое (конечное!) $n$, мы сможем определить, с какой стороны от $e$ лежит аргумент.
		\end{proof}
	\item $\{n \in \N \mid \text{в записи числа $\pi$ есть $n$ девяток подряд}\}$
		\begin{proof}
			Очевидно, что либо в $\pi$ встречается любое количество девяток подряд (и тогда алгоритм тривиален),
			либо есть минимальное $N$ такое, что $N$ девяток подряд нет.
			Тогда алгоритм просто сравнивает аргумент с этим $N$.

			Это пример неконструктивного доказательства: алгоритм существует, но предъявить мы его не смогли (равно как и явно запустить) "--- про число $\pi$ такой факт неизвестен.
		\end{proof}
\end {enumerate}

\begin{Def}
	$A \subset \No$ называется \textit{полуразрешимым}, если
	\[ \exists Algo \colon
	\begin{cases}
		Algo(x) = 1, &x \in A \\
		Algo(x) \text{~работает бесконечно долго}, &x \notin A
	\end{cases}
	\]
\end{Def}

\begin{Rem}
	$A$ разрешимо $\Ra A$ полуразрешимо 
\end{Rem}
\begin{Def}
	$A \subset \No$ называется \textit{перечислимым} если существует алгоритм, который на входе $0$ работает бесконечно долго и
	выводит все элементы множества (для каждого конкретного элемента есть конкретное время, в которое его выведут).
\end{Def}

\begin{theorem}
	Пусть $S \subset \N$, тогда $S$ перечислимо $\iff S$ полуразрешимо
\end{theorem}
\begin{proof}
	\begin{description}
	\item[$\Ra$:]
		Пусть $B$ "--- перечисляющий алгоритм.
		Опишем полуразрешающий:
\begin{verbatim}
Пока B(0) не выдало x {
  ждём
}
Выводим 1
\end{verbatim}
	\item[$\La$:]
		Пусть $A$ "--- полуразрешающий алгоритм.
		Опишем перечисляющий:
\begin{verbatim}
Для i = 0..INF {
  Для j = 0..i {
    запустить первые i - j шагов A(j)
    если завершился, то выводим j
  }
}
\end{verbatim}
		Это мы просто пошли по диагоналям таблицы <<номер входа/номер шага>>.
		Интуиция: можно считать, что мы запустили полуразрешающий алгоритм на всех входах одновременно.
	\end{description}
\end{proof}

\begin{theorem}[Поста]
	Всякое разрешимое множество натуральных чисел перечислимо.
	Если множество $A$ и его дополнение (до множества всех натуральных чисел) перечислимы, то $A$ разрешимо.
\end{theorem}
\begin{proof}
	\begin{enumerate}
	\item
		Если принадлежность числа к множеству $A$ можно проверить некоторым алгоритмом, то $A$ и его дополнение перечислимы:
		надо по очереди проверять принадлежность чисел 0, 1, 2, \dots~и печатать те из них, которые принадлежат $A$ (или те, которые не принадлежат $A$).
	\item
		Если у нас есть алгоритм, перечисляющий $A$, а также другой алгоритм, перечисляющий дополнение к $A$, то для выяснения принадлежности заданного числа $n$
		к $A$ надо запустить оба эти алгоритма параллельно (исполнять шаг одного, потом шаг другого) и ждать, пока один из них напечатает $n$ (мы знаем, что рано или поздно ровно один из них это сделает).
		Посмотрев, какой алгоритм это сделал, мы узнаем, лежит ли $n$ в $A$.
		Это произойдёт за конечное время.
	\end{enumerate}
\end{proof}

\begin{theorem}
	Множество $P$ натуральных чисел перечислимо тогда и только тогда, когда оно является проекцией некоторого разрешимого множества $Q$ пар натуральных чисел.
	Проекция получается, если от пар оставить их первые компоненты:
	\begin{gather*}
		P\text{~перечислимо} \\
		\Updownarrow \\
		\exists \text{~разрешимое~} Q \subset \No\times\No \colon
			x \in P \iff (\exists y \colon (x, y) \in Q)
	\end{gather*}
\end{theorem}
\begin{proof}
	\begin{description}
	\item[$\Uparrow$:]
		Проекция любого перечислимого множества перечислима (перечисляющиий алгоритм должен лишь удалять вторые члены пар), так что проекция разрешимого множества тем более перечислима.
	\item[$\Downarrow$:]
		Если $P$ "--- перечислимое множество, перечисляемое алгоритмом $A$, то оно есть проекция множества $Q$, состоящего из всех таких пар $(x, n)$,
		что $x$ появляется в течении первых $n$ шагов работы алгоритма $A$.
		Это множество, очевидно, разрешимо.
	\end{description}
\end{proof}

\begin{Def}
	Пусть $M \subset \No$.
	Тогда функция $f \colon M \to \No$ называется \textit{вычислимой}, если существует алгоритм, ее вычисляющии, то есть такой алгоритм $A$, что:
	\begin{enumerate}
	\item если $n \in M$, то алгоритм $A$ останавливается на входе $n$ и печатает $f(n)$
	\item если $n \notin M$ (функция не определена), то алгоритм $A$ не останавливается на входе $n$
	\end{enumerate}
\end{Def}

\setauthor{Елизавета Третьякова}
Несколько простых свойств в качестве упражнений:
\begin{enumerate}
	\item
		$S$ перечислимо $\iff$ $S$ "--- область определения вычислимой функции $f$.
		\begin{proof}
			\begin{description}
				\item[$\Ra$:]
					$S$ перечислимо, следовательно полуразрешимо.
					Возьмём функцию $f$, соответствующую полуразрешимому алгоритму "--- она определена в точности на $S$.
				\item[$\La$:]
					Возьмём алгоритм, вычисляющий функцию $f$ и заменим его вывод на единицу "--- получим полуразрешающий алгоритм для области определения $f$.
			\end{description}
		\end{proof}
	\item
		$S$ перечислимо $\iff$ $S$ "--- область значений вычислимой функции $f$
		\begin{proof}
			\begin{description}
				\item[$\Ra$:]
					Модифицируем полуразрешающий алгоритм для $S$: пусть вместо единицы он выводит $x$.
				\item[$\La$:]
					По предыдущему свойству область определения $f$ перечислима.
					Запустим перечисляющий алгоритм для области определения, на каждом его выводе дополнительно вычислим $f$ (за конечное время, так как функция определена).
					Получим алгоритм, выводящий область значений.
			\end{description}
		\end{proof}
\end{enumerate}

\begin{theorem}
	Пусть $f \colon M \to \No$ вычислима $\iff$ $\Gamma_f = \{ (x, f(x)) \mid x \in M \}$ (график функции) перечислим.
\end{theorem}
\begin{proof}
	\begin{description}
		\item[$\Ra$:]
			Так как $f$ вычислима, то область определения вычислима, перечислим её.
			Как только алгоритм выводит $x$, вычисляем $f(x)$ и выводим $(x, f(x))$.
		\item[$\La$:]
			Чтобы вычислить значение $f(x)$ запустим алгоритм, перечисляющий точки графика.
			За конечное время он выведет пару $(x, y)$ (с необходимым $x$), тогда выводим $y$, как ответ.
	\end{description}
\end{proof}

\section{Нумерация алгоритмов}
Для удобства хочется получить некоторое соответствие между алгоритмами и элементами $\No$.
Довольно естественно считать, что алгоритм можно задать некоторой строкой (например, конечной программой).
Строгое определение мы дадим позже.
Строки, не являющиеся корректными описаниями, будем считать соответствующими пустому алгоритму, который сразу завершается и ничего не выводит.
Так как все строки мы можем занумеровать элементами $\No$, то и все возможные алгоритмы мы тоже можем занумеровать.

\begin{Def}
	Пусть $A$ "--- алгоритм.
	Тогда за $\#A$ мы обозначим \textit{номер алгоритма}, некоторый элемент $\No$, ему соответствующий.
\end{Def}

\begin{Def}
	Пусть $n$ "--- натуральное число.
	Тогда \textit{алгоритм с номером $n$} мы будем обозначать $\langle n \rangle$.
\end{Def}
