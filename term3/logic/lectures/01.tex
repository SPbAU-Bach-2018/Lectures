\section{Введение}
Будем пользоваться интуитивным определением понятия $Алгоритм$. Скажем лишь то, что он удовлетворяет некоторым условиям :
\begin{enumerate}
    \item Получает на вход строку из $\sigma^*$ - множества строк над заданным алфавитом $\sigma$
    \item Либо закончит работу и выдаст строку из $\sigma^*$, либо никогда не закончит работу
    \item Его можно записать
    \item Его можно исполнять по шагам
    \item Может использовать бесконечное количество памяти
\end{enumerate}

Постоим биекцию между строками и натуральными числами на примере $\sigma = {a, b}$\\
$0 \ra$ пустая строка\\
$1\ra a$\\
$2\ra b$\\
$3\ra aa$\\
$4\ra ab$\\
$\dots$ и так далее

\section{Разрешимые, перечислимые множества. Вычислимые функции}

\begin{Def}
	$A \subset N$ называется разрешимым, если $\exists$ алгоритм, который выдаёт $1$ для $x$ из $A$ и $0$ для $x$ не из $A$
	$$\exists Algo \colon \forall x \in A, Algo(x) = 1, \forall x \notin A Algo(x) = 0$$
\end{Def}

Примеры:
\begin{enumerate}
	\item пустое множество
	\item $N$
	\item конечное множество
	\item $\{q \in Q | q < e\}$
	\item $\{n|$ в записи числа $\pi$ есть $n$ девяток подряд$\}$
\end {enumerate}

\begin{Def}
	$A \subset N$ называется полуразрешимым, если
	$\exists Algo \colon \forall x \in A, Algo(x) = 1, \forall x \notin A, Algo(x)$ работает бесконечно долго
\end{Def}

\begin{Rem}
	$A$ разрешимо $\Ra A$ полуразрешимо 
\end{Rem}
\begin{Def}
	$A \subset N$ называется перечислимым если $\exists$ алгоритм, который на входе $0$ работает бесконечно долго и выводит все элементы множества (для каждого конкретного элемента есть конкретное время, в которое его выведут)
\end{Def}

\begin{theorem}
	$S \subset N, S$ перечислимо $\Leftrightarrow S$ полуразрешимо 
\end{theorem}
\begin{proof}
	$\Ra$ Пусть $B$ перечисляющий алгоритм. Опишем полуразрешающий:\\
	%\begin{cppcode}
	Пока B(0) не выдало x \{\\
		ждём\\
	\}\\
	Выводим 1\\
	%\end{cppcode}
	$\La$ Пусть $A$ полуразрешающий алгоритм. Опишем перечисляющий:\\
	%\begin{cppcode}
	Для i = 0..INF \{\\
		Для j = 0..i \{\\
			запустить первые i - j шагов A(j)\\
			если завершился, то выводим j\\
		\}\\
	\}\\
	%\end{cppcode}
\end{proof}
\begin{theorem}{Пост}
	Всякое разрешимое множество натуральных чисел перечислимо. Если множество $A$ и его дополнение (до множества всех натуральных чисел) перечислимы, то $A$ разрешимо.
\end{theorem}
\begin{proof}
	Если принадлежность числа к множеству $A$ можно проверить некоторым алгоритмом, то $A$ и его дополнение перечислимы: надо по очереди проверять принадлежность чисел 0, 1, 2, . . . и печатать те из них, которые принадлежат $A$ (или те, которые не принадлежат $A$).
В другую сторону: если у нас есть алгоритм, перечисляющий $A$, а также другой алгоритм, перечисляющий дополнение к $A$, то для выяснения принадлежности заданного числа $n$ к $A$ надо запустить оба эти алгоритма и ждать, пока один из них напечатает $n$ (мы знаем, что рано или поздно ровно один из них это сделает). Посмотрев, какой алгоритм это сделал, мы узнаем, лежит ли $n$ в $A$. 
\end{proof}
\begin{theorem}{Пост}
	Множество P натуральных чисел перечислимо тогда и только тогда, когда оно является проекцией некоторого разрешимого множества Q пар натуральных чисел. (Проекция получается, если от пар оставить их первые компоненты: $x \in P \Leftrightarrow \exists y (x, y) \in Q$
\end{theorem}
\begin{proof}
	$\La$
	Проекция любого перечислимого множества перечислима (перечисляющиий алгоритм должен лишь удалять вторые члены пар), так что проекция разрешимого множества тем более перечислима.
	$\Ra$
Напротив, если $P$ — перечислимое множество, перечисляемое алгоритмом $A$, то оно есть проекция разрешимого множества $Q$, состоящего из всех таких пар $(x, n)$, что $x$ появляется в течении первых $n$ шагов работы алгоритма $A$. (Это свойство, очевидно, разрешимо.) 
\end{proof}
\begin{Def}
Функция f с натуральными аргументами и значениями называется вычислимой, если существует алгоритм, ее вычисляющии, то есть такой алгоритм $A$, что
\begin{enumerate}
\item если $f(n)$ определено для некоторого натурального $n$, то алгоритм A останавливается на входе n и печатает $f(n)$
\item если $f(n)$ не определено, то алгоритм $A$ не останавливается на входе $n$
\end{enumerate}
\end{Def}
продолжение следует...