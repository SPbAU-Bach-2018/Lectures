\setauthor{Надежда Бугакова}
\section{Тезис Чёрча}

Алгоритм и машина Тьюринга "--- одно и то же.

\begin{theorem}
	Если функция $f$ вычисляется с помощью программы с конечным количеством переменных, то она вычисляется и с помощью машины Тьюринга.
\end{theorem}
\begin{proof}
	Доказательство относительно нестрого.
	Алфавитом будет $\{0, 1, \#, \textvisiblespace\}$.
	На ленте мы будем записывать наши переменные в двоичном виде (от младших битов к старшим), разделяя их $\#$:
	\t{\#$a$\#$b$\#$c$\#\dots\#}

	Состоянием машины Тьюринга будет текущая строка программы (коих конечное) и описание текущего действия, всего конечное число состояний.
	\begin{enumerate}
		\item \t{goto} и \t{stop} "--- это просто переход из одного состояния в другое
		\item
			\t{if} "--- это надо съехать кареткой до начала ленты, потом <<отсчитать>> от начала ленты нужное (константное) число символов \t{\#}, найдя таким образом нужную переменную.
			После этого остаётся лишь проверить, что она больше нуля (т.е. имеет хотя бы одну единицу в записи).
			Если дошли до следующей \t{\#}, то делаем один \t{goto}, иначе "--- другой.
		\item
			\verb'a++' и \verb'a--' выражаются похожим образом: сначала мы находим нужную переменную, потом прибавляем единицу.
			Проблема может возникнуть, если у нас увеличилась длина числа, а места не ленте нет.
			Тогда надо перезаписать ограничивающую нас \t{\#} и потом <<сдвинуть>> остаток ленты (для этого нам хватит конечного числа состояний "--- машине надо помнить только текущий <<сдвигаемый>> символ).
	\end{enumerate}
\end{proof}

\begin{theorem}
	Если функция вычисляется на машине Тюринга, то она вычисляется и с помощью программмы с конечным количеством переменных.
\end{theorem}
\begin{proof}
	\begin{Def}
		\textit{Конфигурация} машины Тьюринга: (текущее состояние, лента левее головки, символ под головкой, лента правее головки).
	\end{Def}

	Ленту левее и ленту правее можно реализовать через стек, а текущее состояние и символ под головкой "--- просто как две переменные.

	Мы хотим представлять стек в виде одного числа.
	Если в алфавите k символов, то возьмём систему счисления по основанию k.
	Стек: $(a_1, a_2, \dots, a_l)$ $\longrightarrow$ $n = a_1 + ka_2 + \dots + k^la_l$. Верхний элемент: $n$ mod $k$; удалить верхний элемент: 
	$n \longrightarrow \lfloor \frac{n}{k} \rfloor$; добавить элемент: $x + nk$.

	Таким образом получили 4 переменных, описывающих состояние МТ.

	Проблемы (решаемые):
	\begin{enumerate}
		\item Если стек правее ленты пустой, добавить пробел
		\item Преобразование входов и выходов.
	\end{enumerate} 
\end{proof}

\begin{Def}
	\textit{Универсальная машина Тьюринга}: $U(M, x)$, где $M$ "--- описание некоторой машины Тьюринга, $x$ "--- её вход.
	Тогда $U(M, x)$ запускает $M$ на входе $x$.
\end{Def}
Лента в процессе работы $U(M, x)$ выглядит примерно так: \t{\#}\textit{описание $M$}\t{\#}\textit{состояние $М$}\t{\#}\textit{лента $M$ (вход)...}

Однако тут у нас скорость работы может замедлиться очень сильно (чем дальше каретка на ленте, тем медленнее переход).
Чтобы этого не было (и было лишь константное замедление работы), можно таскать описание и состояние с собой по ленте.
Например, при сдвиге каретки направо в самом начале работы из ленты
\begin{center}
	\t{\#}\textit{описание $M$}\t{\#}\textit{состояние $М$}\t{\#ВХОД}
\end{center}
получится
\begin{center}
	\t{В\#}\textit{описание $M$}\t{\#}\textit{состояние $М$}\t{\#ХОД}
\end{center}

Тогда чтобы посмотреть состояние и описание $M$ нам потребуется сделать лишь константное число шагов по ленте.

\section{Ассоциативное исчисление}
Еще одна задача, которая окажется нерешаемой.

\begin{Def}
	\textit{Одностороннее ассоциативное исчисление}:
	пусть $\Sigma^{*}$ - множество слов алфавита $\Sigma$.
	Еще есть множество правил (односторонних) $x_1 \rightarrow y_1$, $x_2 \rightarrow y_2$, \dots, $x_k \rightarrow y_k$,
	где $x_i, y_i \in \Sigma^{*}$.
	
	Можно ли получить из строки $a$ строку $b$?
	Разрешается брать подстроку $a$, равную некоторому $x_i$ и заменять её на соответствующую $y_i$.
\end{Def}
\begin{Def}
    Двустороннее ассоциативное исчисление: как одностороннее, только стрелочки в обе стороны.
    Частный случай одностороннего.
\end{Def}

\begin{exmp}
	Правила:
	\[\left\{
	\begin{aligned}
	\t{AB} &\longleftrightarrow \t{BA} \\
	\t{BC} &\longrightarrow \t{BB} \\
	\t{C} &\longrightarrow \t{CC} \\
	\end{aligned}
	\right.\]
	Можно ли из \t{ABAC} получить \t{ABBAC}?
	Можно:
	\begin{enumerate}
	\item \t{A\textbf{BA}C} \to \t{A\textbf{AB}C}
	\item \t{AAB\textbf{C}} \to \t{AAB\textbf{CC}}
	\item \t{AA\textbf{BC}C} \to \t{AA\textbf{BB}C}
	\item \t{A\textbf{AB}BC} \to \t{A\textbf{BA}BC}
	\item \t{AB\textbf{AB}C} \to \t{AB\textbf{BA}C}
	\end{enumerate}
\end{exmp}

\begin{exmp}
	Правила:
	\[\left\{
	\begin{aligned}
	\t{MAM} &\longleftrightarrow \t{AA} \\
	\t{AM} &\longleftrightarrow \t{MAA} \\
	\t{MM} &\longleftrightarrow \t{MAM}
	\end{aligned}
	\right.\]
	Можно ли из \t{MAM} получить \t{AMA}?
\end{exmp}

Оказывается, что нет алгоритма, решающего эту задачу (на вход даются правила и два слова).

\begin{theorem}
	Выводимость в одностороннем ассоциативном исчислении алгоритмически невычислима.
\end{theorem}
\begin{proof}
	Сведём задачу останова к нашей задаче.
	Пусть есть машина Тьюринга $M$, хотим узнать, остановится ли она на входе $x$?
	Закодируем её строкой:
	\t{[$\alpha \widetilde{q} \beta$]}, где $\widetilde{q}$ "--- текущее состояние МТ, а $\alpha$ и $\beta$ нарисованы ниже:
	
	\cimg{02_02}{0.5}

	Алфавит положим равным объединению алфавитов МТ, множества её состояний, а также символов \t{[}, \t{]} и \t{*}.
	Теперь напишем правила, соответствующие переходам МТ.
	Идея такова: любой шаг машины Тьюринга изменяет её состояние только в районе $\widetilde q$, поэтому можно написать
	правила замены подстрок, содержащих $\widetilde q$.
	Мы напишем их таким образом, чтобы в каждый момент можно было применить ровно одно правило.
	Также мы добавим специальный символ \t{*}, который будет обозначать <<мы достигли конечного состояния в машине>>,
	целью будет этот символ вывести.
	\begin{itemize}
	\item
		Если в $\beta$ есть что-то, кроме пробелов; каретка не сдвигается или сдвигается вправо:
		\begin{gather*}
		\left[
			\begin{array}{ll}
				\text{Шаг машины Тьюринга: } &(\widetilde{q}, c) \longrightarrow (\widetilde{q'}, b, \rightarrow)  \\
				\text{Строковая интерпретация: } &\widetilde{q}c \longrightarrow b\widetilde{q'}
			\end{array}
		\right.
		\\
		\left[
			\begin{array}{ll}
				\text{Шаг машины Тьюринга: } &(\widetilde{q}, c) \longrightarrow (\widetilde{q'}, b, \cdot)  \\
				\text{Строковая интерпретация: } &\widetilde{q}c \longrightarrow \widetilde{q'}b
			\end{array}
		\right.
		\end{gather*}

	\item
		Если каретка сдвигается влево:
		\begin{gather*}
		\left[
			\begin{aligned}
				(\widetilde{q}, c) &\longrightarrow (\widetilde{q'}, b, \leftarrow)  \\
				x\widetilde{q}c &\longrightarrow \widetilde{q'}xb\text{ для всех $x$, кроме \t{[}}
			\end{aligned}
		\right.
		\end{gather*}

	\item Если в $\beta$ только пробелы и каретка сдвигается вправо:
		$\left[
			\begin{aligned}
				(\widetilde{q}, \textvisiblespace) &\longrightarrow (\widetilde{q'}, b, \rightarrow) \\
				\widetilde{q}\t{]} &\longrightarrow b\widetilde{q'}\t{]}
			\end{aligned}
		\right.$
	\end{itemize}

   Тогда $M$ остановится на $x$ $\iff$ из \t{[$q_0$$x$]} $\rightarrow$ можно вывести \t{*}, где для \t{*} есть такие правила вывода
   (\t{*} может появиться только из конечного состояния и, если она появилась, то мы можем <<съесть>> все остальные символы):

	\begin{itemize}
	\item $q_f$ $\rightarrow$ \t{*}
	\item \t{*$a$} $\rightarrow$ \t{*} для всех символов $a$
	\item \t{$b$*} $\rightarrow$ \t{*} для всех символов $b$
	\end{itemize}

   Таким образом, мы построили сведение.
   А задача останова неразрешима.
   Если бы умели решать ассоциативное исчисление, то задачу останова тоже.
\end{proof}

\begin{theorem}
	Двустороннее ассоциативное исчисление также неразрешима.
\end{theorem}
\begin{proof}
	В правила из предыдущего доказательства к каждой стрелке добавим обратную.
	Покажем, что если существует путь в двухстороннем исчислении, то в одностороннем тоже (для наших конкретных правил).
	В самом деле, пусть имеется какой-то путь, заканчивающийся в \t{*}.
	В \t{*} по обратной стрелке не прийти, значит, последняя стрелка "--- <<прямая>>.

	Теперь рассмотрим \textit{кратчайший} путь в \t{*}.
	Пусть в нём есть обратные стрелки ($\la$).
	Мы точно знаем, что последняя стрелка прямая ($\ra$)
	Тогда где-то встречается сначала обратная стрелка ($B \la A$), а потом "--- прямая ($B \ra C$).
	Заметим, что $A=C$, так как из каждой $B$ у нас направо может идти не более одной стрелки (мы так строили правила).
	Значит, эти две стрелки можно сократить и получить путь меньшей длины, что противоречит предположению о его минимальной длине.
\end{proof}

Интерпретация в теории групп: есть полугруппа, заданная соотношениями $x_1 = y_1$, $x_2 = y_2$, \dots, $x_k = y_k$ (где $x_iy_i$ "--- какие-то последовательности элементов в произведении).
Тогда сравнение элементов $a$ и $b$ алгоритмически неразрешимо.

\section{Теорема Успенского-Райса}
Пусть $A$, $B$ "--- алгоритмы.
\begin{Def}
	A $\sim$ B (\textit{эквивалентны}), если для всех $x$:
	\[\left\{
		\begin{aligned}
		&A(x) \text{ остановится} \iff B(x) \text{ остановится} \\
		&A(x) \text{ остановится} \Ra A(x) = B(x)
		\end{aligned}
	\right.\]

	Аналогичное обозначание для номеров: $n \equiv m \iff \langle n \rangle \sim \langle m \rangle$
\end{Def}

\begin{Def}
	Пусть $S \subseteq \No$, тогда $S$ называется \textit{инвариантным}, если:
	\[ \forall a \in S, \forall b \in \No \setminus S \colon a \nequiv b \]
\end{Def}
\begin{Rem}
	Например, в будущем мы будем рассматривать множества алгоритмом, обладающих каким-то свойством.
	Если это свойство зависит только от поведения алгоритма на входах, то такие множества будут инвариантны.
\end{Rem}
\begin{Rem}
	$S$ инвариантно $\iff$ $\No \setminus S$ инвариантно.
\end{Rem}

\begin{theorem}[Успенский-Райс]
	Если $S$ инвариантно, $S \ne \varnothing$, $S \ne \No$, то $S$ неразрешимо.
\end{theorem}
\begin{proof}
	От противного.
	Пусть $S$ разрешимо и нетривиально.
	Пусть $\Lambda$ - алгоритм, который не останавливается ни на каком входе.
	Не умаляя общности можно считать, что $\#\Lambda \in S$.
	Пусть $a \in \bar{S}$.

	$W$ - перечеслимое, неразрешимое множество.

	Алгоритм V(n, x) = запускает полуразрешающий алгоритм $W$ и если он остановится, то запускаем $a(x)$ и выдаём результат.

	$V_n(x) = V(n, x)$ Таким образом, у нас есть много алгоритмов: $V_1(x), V_2(x), \dots$.

	n $\in$ W $\Rightarrow$ \#$V_n$ $\equiv$ a

	n $\notin$ W $\Rightarrow$ \#$V_n$ $\equiv$ $\Lambda$

	W $\le_m$ $\bar{S}$ : n $\longrightarrow$ \#$V_n$ - сведение

	W - неразрешимо $\Rightarrow$ $\bar{S}$ - неразрешимо $\Rightarrow$  S - неразрешимо.
\end{proof}
