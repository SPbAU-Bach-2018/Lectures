\setauthor{Надежда Бугакова}
\section{Тезис Чёрча}

Алгоритм и машина Тьюринга "--- одно и то же.

\begin{theorem}
	Если функция $f$ вычисляется с помощью программы с конечным количеством переменных, то она вычисляется и с помощью машины Тьюринга.
\end{theorem}
\begin{proof}
	Доказательство относительно нестрого.
	Алфавитом будет $\{0, 1, \#, \textvisiblespace\}$.
	На ленте мы будем записывать наши переменные в двоичном виде (от младших битов к старшим), разделяя их $\#$:
	\t{\#$a$\#$b$\#$c$\#\dots\#}

	Состоянием машины Тьюринга будет текущая строка программы (коих конечное) и описание текущего действия, всего конечное число состояний.
	\begin{enumerate}
		\item \t{goto} и \t{stop} "--- это просто переход из одного состояния в другое
		\item
			\t{if} "--- это надо съехать кареткой до начала ленты, потом <<отсчитать>> от начала ленты нужное (константное) число символов \t{\#}, найдя таким образом нужную переменную.
			После этого остаётся лишь проверить, что она больше нуля (т.е. имеет хотя бы одну единицу в записи).
			Если дошли до следующей \t{\#}, то делаем один \t{goto}, иначе "--- другой.
		\item
			\verb'a++' и \verb'a--' выражаются похожим образом: сначала мы находим нужную переменную, потом прибавляем единицу.
			Проблема может возникнуть, если у нас увеличилась длина числа, а места не ленте нет.
			Тогда надо перезаписать ограничивающую нас \t{\#} и потом <<сдвинуть>> остаток ленты (для этого нам хватит конечного числа состояний "--- машине надо помнить только текущий <<сдвигаемый>> символ).
	\end{enumerate}
\end{proof}

\begin{theorem}
	Если функция вычисляется на машине Тюринга, то она вычисляется и с помощью программмы с конечным количеством переменных.
\end{theorem}
\begin{proof}
	\begin{Def}
		\textit{Конфигурация} машины Тьюринга: (текущее состояние, лента левее головки, символ под головкой, лента правее головки).
	\end{Def}

	Ленту левее и ленту правее можно реализовать через стек, а текущее состояние и символ под головкой "--- просто как две переменные.

	Мы хотим представлять стек в виде одного числа.
	Если в алфавите k символов, то возьмём систему счисления по основанию k.
	Стек: $(a_1, a_2, \dots, a_l)$ $\longrightarrow$ $n = a_1 + ka_2 + \dots + k^la_l$. Верхний элемент: $n$ mod $k$; удалить верхний элемент: 
	$n \longrightarrow \lfloor \frac{n}{k} \rfloor$; добавить элемент: $x + nk$.

	Таким образом получили 4 переменных, описывающих состояние МТ.

	Проблемы (решаемые):
	\begin{enumerate}
		\item Если стек правее ленты пустой, добавить пробел
		\item Преобразование входов и выходов.
	\end{enumerate} 
\end{proof}

\begin{Def}
	\textit{Универсальная машина Тьюринга}: $U(M, x)$, где $M$ "--- описание некоторой машины Тьюринга, $x$ "--- её вход.
	Тогда $U(M, x)$ запускает $M$ на входе $x$.
\end{Def}
Лента в процессе работы $U(M, x)$ выглядит примерно так: \t{\#}\textit{описание $M$}\t{\#}\textit{состояние $М$}\t{\#}\textit{лента $M$ (вход)...}

Однако тут у нас скорость работы может замедлиться очень сильно (чем дальше каретка на ленте, тем медленнее переход).
Чтобы этого не было (и было лишь константное замедление работы), можно таскать описание и состояние с собой по ленте.
Например, при сдвиге каретки направо в самом начале работы из ленты
\begin{center}
	\t{\#}\textit{описание $M$}\t{\#}\textit{состояние $М$}\t{\#ВХОД}
\end{center}
получится
\begin{center}
	\t{В\#}\textit{описание $M$}\t{\#}\textit{состояние $М$}\t{\#ХОД}
\end{center}

Тогда чтобы посмотреть состояние и описание $M$ нам потребуется сделать лишь константное число шагов по ленте.

\section{Ассоциативное исчисление}
Еще одна задача, которая окажется нерешаемой.

\begin{Def}
	\textit{Одностороннее ассоциативное исчисление}:
	пусть $\Sigma^{*}$ - множество слов алфавита $\Sigma$.
	Еще есть множество правил (односторонних) $x_1 \rightarrow y_1$, $x_2 \rightarrow y_2$, \dots, $x_k \rightarrow y_k$,
	где $x_i, y_i \in \Sigma^{*}$.
	
	Можно ли получить из строки $a$ строку $b$?
	Разрешается брать подстроку $a$, равную некоторому $x_i$ и заменять её на соответствующую $y_i$.
\end{Def}
\begin{Def}
    Двустороннее ассоциативное исчисление: как одностороннее, только стрелочки в обе стороны.
    Частный случай одностороннего.
\end{Def}

\begin{exmp}
	Правила:
	\[\left\{
	\begin{aligned}
	\t{AB} &\longleftrightarrow \t{BA} \\
	\t{BC} &\longrightarrow \t{BB} \\
	\t{C} &\longrightarrow \t{CC} \\
	\end{aligned}
	\right.\]
	Можно ли из \t{ABAC} получить \t{ABBAC}?
	Можно:
	\begin{enumerate}
	\item \t{A\textbf{BA}C} \to \t{A\textbf{AB}C}
	\item \t{AAB\textbf{C}} \to \t{AAB\textbf{CC}}
	\item \t{AA\textbf{BC}C} \to \t{AA\textbf{BB}C}
	\item \t{A\textbf{AB}BC} \to \t{A\textbf{BA}BC}
	\item \t{AB\textbf{AB}C} \to \t{AB\textbf{BA}C}
	\end{enumerate}
\end{exmp}

\begin{exmp}
	Правила:
	\[\left\{
	\begin{aligned}
	\t{MAM} &\longleftrightarrow \t{AA} \\
	\t{AM} &\longleftrightarrow \t{MAA} \\
	\t{MM} &\longleftrightarrow \t{MAM}
	\end{aligned}
	\right.\]
	Можно ли из \t{MAM} получить \t{AMA}?
\end{exmp}

Оказывается, что нет алгоритма, решающего эту задачу (на вход даются правила и два слова).

\begin{theorem}
	Выводимость в одностороннем ассоциативном исчислении алгоритмически невычислима.
\end{theorem}
\begin{proof}
	Сведём задачу останова к нашей задаче.
	Пусть есть машина Тьюринга $M$, хотим узнать, остановится ли она на входе $x$?
	Закодируем её строкой:
	\t{[$\alpha \widetilde{q} \beta$]}, где $\widetilde{q}$ "--- текущее состояние МТ, а $\alpha$ и $\beta$ нарисованы ниже:
	
	\cimg{02_02}{0.5}

	Алфавит положим равным объединению алфавитов МТ, множества её состояний, а также символов \t{[}, \t{]} и \t{*}.
	Теперь напишем правила, соответствующие переходам МТ.
	Идея такова: любой шаг машины Тьюринга изменяет её состояние только в районе $\widetilde q$, поэтому можно написать
	правила замены подстрок, содержащих $\widetilde q$.
	Мы напишем их таким образом, чтобы в каждый момент можно было применить ровно одно правило.
	Также мы добавим специальный символ \t{*}, который будет обозначать <<мы достигли конечного состояния в машине>>,
	целью будет этот символ вывести.
	\begin{itemize}
	\item
		Правила на случай, если в $\beta$ есть что-то, кроме пробелов:

		\begin{tabular}{|l|rcl|rcl|}
		\hline
			Шаг машины Тюринга: &
			$(\widetilde{q}, c)$ & $\longrightarrow$ & $(\widetilde{q'}, b, \ra)$ &
			$(\widetilde{q}, c)$ & $\longrightarrow$ & $(\widetilde{q'}, b, \cdot)$
		\\\hline
			Строковая интерпретация: &
			$\widetilde{q}c$ & $\longrightarrow$ & $b\widetilde{q'}$ &
			$\widetilde{q}c$ & $\longrightarrow$ & $\widetilde{q'}b$
		\\\hline
		\end{tabular}

		А также для всех $x$, кроме \t{[}:

		\begin{tabular}{|l|rl|}
		\hline
			Шаг машины Тюринга: &
			$(\widetilde{q}, c)$ & $\longrightarrow (\widetilde{q'}, b, \la)$
		\\\hline
			Строковая интерпретация: &
			$x\widetilde{q}c$ & $\longrightarrow \widetilde{q'}xb$
		\\\hline
		\end{tabular}

	\item
		Если в $\beta$ только пробелы, то надо аккуратнее разбираться с правой границей:

		\begin{tabular}{|l|rcl|rcl|}
		\hline
			Шаг машины Тюринга: &
			$(\widetilde{q}, \textvisiblespace)$ & $\longrightarrow$ & $(\widetilde{q'}, b, \ra)$ &
			$(\widetilde{q}, \textvisiblespace)$ & $\longrightarrow$ & $(\widetilde{q'}, b, \cdot)$
		\\\hline
			Строковая интерпретация: &
			$\widetilde{q}\t{]}$ & $\longrightarrow$ & $b\widetilde{q'}\t{]}$ &
			$\widetilde{q}\t{]}$ & $\longrightarrow$ & $\widetilde{q'}b\t{]}$
		\\\hline
		\end{tabular}

		А также для всех $x$, кроме \t{[}:

		\begin{tabular}{|l|rl|}
		\hline
			Шаг машины Тюринга: &
			$(\widetilde{q}, \textvisiblespace)$ & $\longrightarrow (\widetilde{q'}, b, \la)$
		\\\hline
			Строковая интерпретация: &
			$x\widetilde{q}\t{]}$ & $\longrightarrow \widetilde{q'}xb\t{]}$
		\\\hline
		\end{tabular}
	\end{itemize}
	Таким образом на каждый переход в машине Тьюринга мы добавляем два правила (на случай, если $\beta$ пусто, и на случай, если непусто).

	Тогда $M$ остановится на $x$ $\iff$ из \t{[$q_0$$x$]} $\rightarrow$ можно вывести \t{*}, где для \t{*} есть такие правила вывода
	(\t{*} может появиться только из конечного состояния и, если она появилась, то мы можем <<съесть>> все остальные символы):

	\begin{itemize}
	\item $q_f$ $\rightarrow$ \t{*}
	\item \t{*$a$} $\rightarrow$ \t{*} для всех символов $a$
	\item \t{$b$*} $\rightarrow$ \t{*} для всех символов $b$
	\end{itemize}

   Таким образом, мы построили сведение.
   А задача останова неразрешима.
   Если бы умели решать ассоциативное исчисление, то задачу останова тоже.
\end{proof}

\begin{theorem}
	Двустороннее ассоциативное исчисление также неразрешима.
\end{theorem}
\begin{proof}
	В правила из предыдущего доказательства к каждой стрелке добавим обратную.
	Покажем, что если существует путь в двухстороннем исчислении, то в одностороннем тоже (для наших конкретных правил).
	В самом деле, пусть имеется какой-то путь, заканчивающийся в \t{*}.
	В \t{*} по обратной стрелке не прийти, значит, последняя стрелка "--- <<прямая>>.

	Теперь рассмотрим \textit{кратчайший} путь в \t{*}.
	Пусть в нём есть обратные стрелки ($\la$).
	Мы точно знаем, что последняя стрелка прямая ($\ra$)
	Тогда где-то встречается сначала обратная стрелка ($B \la A$), а потом "--- прямая ($B \ra C$).
	Заметим, что $A=C$, так как из каждой $B$ у нас направо может идти не более одной стрелки (мы так строили правила).
	Значит, эти две стрелки можно сократить и получить путь меньшей длины, что противоречит предположению о его минимальной длине.
\end{proof}

Интерпретация в теории групп: есть полугруппа, заданная соотношениями $x_1 = y_1$, $x_2 = y_2$, \dots, $x_k = y_k$ (где $x_iy_i$ "--- какие-то последовательности элементов в произведении).
Тогда сравнение элементов $a$ и $b$ алгоритмически неразрешимо.

\section{Теорема Успенского-Райса}
Пусть $A$, $B$ "--- алгоритмы.
\begin{Def}
	A $\sim$ B (\textit{эквивалентны}), если для всех $x$:
	\[\left\{
		\begin{aligned}
		&A(x) \text{ остановится} \iff B(x) \text{ остановится} \\
		&A(x) \text{ остановится} \Ra A(x) = B(x)
		\end{aligned}
	\right.\]
	То есть мы не можем отличить $A$ и $B$, смотря только на их поведение на разных входах.

	Аналогичное обозначание для номеров: $n \equiv m \iff \langle n \rangle \sim \langle m \rangle$
\end{Def}

\begin{Def}
	Пусть $S \subseteq \No$, тогда $S$ называется \textit{инвариантным}, если:
	\[ \forall a \in S, \forall b \in \No \setminus S \colon a \nequiv b \]
	То есть если $a$ и $b$ эквивалентны, то они либо оба лежат в $S$, либо оба там не лежат.
\end{Def}
\begin{Rem}
	Например, в будущем мы будем рассматривать множества алгоритмом, обладающих каким-то свойством.
	Если это свойство зависит только от поведения алгоритма на входах, то такие множества будут инвариантны.
\end{Rem}
\begin{Rem}
	$S$ инвариантно $\iff$ $\No \setminus S$ инвариантно.
\end{Rem}

\begin{theorem}[Успенский-Райс]
	Если $S$ инвариантно, $S \ne \varnothing$, $S \ne \No$, то $S$ неразрешимо.
\end{theorem}
\begin{proof}
	От противного.
	Пусть $S$ разрешимо и нетривиально.
	Пусть $\Lambda$ - алгоритм, который не останавливается ни на каком входе.
	Не умаляя общности можно считать, что $\#\Lambda \in S$.
	Возьмём какой-нибудь номер алгоритма $a \in \bar{S}$.

	Возьмём какое-нибудь перечислимое и неразрешимое множество $W$ (например, область определения диагональной функции из доказательства теоремы \ref{diagonalFunc}).
	Построим алгоритм $V_n(x)$ "--- запускает полуразрешающий алгоритм для $W$ и, если тот остановится, запускаем $\langle a \rangle(x)$ и выдаём результат.
	На самом деле, у нас есть много алгоритмов: $V_1(x), V_2(x), \dots$.

	Теперь посмотрим на номера этих алгоритмов, чему они эквивалентны и где лежат:
	\[
		\left[
			\begin{aligned}
			n \in W &\Ra \#V_n \equiv a \xRightarrow{a \in \bar S} \#V_n \in \bar S \\
			n \notin W &\Ra \#V_n \equiv \#\Lambda \xRightarrow{\#\Lambda \in S} \#V_n \in S
			\end{aligned}
		\right.
	\]
	Теперь построим $m$-сведение множества $\bar{S}$ к множеству $W$ ($W \le_m \bar S$): $f(n) = \#V_n$.
	В самом деле:
	\[ n \in W \iff \#V_n \in \bar S \]
	Так как $W$ неразрешимо, то $\bar S$ тоже неразрешимо $\Ra$ $S$ неразрешимо.
\end{proof}
