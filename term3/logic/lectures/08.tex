\subsection{Скорость роста примитивно рекурсивных}
\setauthor{Егор Суворов, Елизавета Третькова}

Хотим выяснить, существует ли всюду определённая вычислимая функция, не являющаяся
примитивно рекурсивной.

\begin{Def}
	$n$-кратное применение функции $f$ к $x$ будем обозначать $f^{[n]}(x)$:
	\[ f^{[n]}(x)=\underbrace{f(f(\dots(f(}_{n\text{ вызовов}}x))\dots)) \]
\end{Def}
\begin{Def}
	Функция Аккермана $a_i(x)$ от двух параметров (просто с индексами писать удобнее) при $i, x \ge 0$:
	\begin{gather*}
		a_0(x) = x + 1 \\
		a_{i+1}(x) = a_i^{[x+2]}(x)
	\end{gather*}
\end{Def}
Свойства:
\begin{enumerate}
	\item $a_i(x) > x$ (индукция по $i$)
	\item Для всех $i$: $a_i(x)$ монотонно возрастает по $x$, т.е. $a_i(x) < a_i(x+1)$.
		\begin{proof}
			Индукция по $i$:
			\begin{description}
				\item[База:]
					$i=0$ "--- $a_i(x) = x + 1$, очевидно.
				\item[Переход:]
					$i \to i + 1$ "--- доказали для $a_i$, показываем для $a_{i+1}$.
					Пусть $y > x \ge 0$
					Тогда имеем:
					\[ a_{i+1}(y)=a_i^{[y+2]}(y) > a_i^{[y+2]}(x) > a_i^{[x+2]}(x) = a_{i+1}(x) \]
			\end{description}
		\end{proof}
	\item
		Для всех $x$: $a_i(x)$ монотонно возрастает по $i$.
		\[ a_{i+1}(x) = a_i^{[x+2]}(x) > a_i(x) \]
	\item
		$a_i(a_i(x)) \le a_{i+1}(x)$, так как при $x=0$ имеем в точности равенство, а при $x>0$:
		\[ a_{i+1}(x) = a_i^{[x+2]}(x) = a_i(a_i(a_i^{[x]}(x))) > a_i(a_i(x)) \]
\end{enumerate}

\begin{theorem}
	Если $f(x_1, \dots, x_n)$ "--- примитивно рекурсивная функция, то для некоторого $N$ имеем:
	\[ \forall x_1, \dots, x_n \colon f(x_1, \dots, x_n) \le a_N(\max \{ x_1, \dots, x_n \}) \]
\end{theorem}
\begin{proof}
	Индукция по построению примитивно рекурсивных функций.
	Чуть формальнее: каждая примитивно рекурсивная функция получается за несколько операций из базисных,
	индукция по числу этих операций.
	\begin{enumerate}
	\item Базисные функции "--- подходит $N=0$:
		\begin{enumerate}
		\item Для $0$ очевидно
		\item $s(x) = x + 1 \le a_0(x)$
		\item $\pi_n^k(x_1, \dots, x_n) = x_k \le \max \{ x_1, \dots, x_n \} \le a_0(\max \{ x_1, \dots, x_n \})$
		\end{enumerate}
	\item
		Подстановка: $g(x_1, \dots, x_n) = f(h_1(x_1, \dots, x_n), h_2(x_1, \dots, x_n), \dots, h_k(x_1, \dots, x_n))$.

		Положим $\vec x = (x_1, \dots, x_n)$, а $\max \{ x_1, \dots, x_n \} = x_{\max}$.
		Тогда знаем, что для некоторых $N_0$ (оценка на функцию $f$) и $N_1, \dots, N_k$ (оценки на функции $h_i$):
		\begin{align*}
			g(\vec x) = f(\dots) &\le a_{N_0}(\max \{ h_1(\vec x), h_2(\vec x), \dots, h_k(\vec x) \}) \\
			h_1(\vec x) &\le a_{N_1}(x_{\max}) \\
			&\vdots \\\
			h_k(\vec x) &\le a_{N_k}(x_{\max}) \\
		\end{align*}
		Тогда положим $N'=\max \{ N_0, N_1, \dots, N_k \}$:
		\begin{align*}
			g(\vec x) &\le a_{N'}(\max \{ h_1(\vec x), h_2(\vec x), \dots, h_k(\vec x) \}) \\
			h_1(\vec x) &\le a_{N'}(x_{\max}) \\
			&\vdots \\
			h_k(\vec x) &\le a_{N'}(x_{\max}) \\
		\end{align*}
		Отсюда легко видно, что:
		\[
			g(\vec x) \le a_{N'}(\max \{ h_1(\vec x), h_2(\vec x), \dots, h_k(\vec x) \}) \le a_{N'}(a_{N'}(x_{\max})) \le a_{N'+1}(x_{\max})
		\]
		Таким образом, нашли искомое число: $N=N'+1$.
	\item
		Примитивная рекурсия (аналогично обозначили $\vec x$):
		\begin{align*}
			g(\vec x, 0) &= f(\vec x) \\
			g(\vec x, y + 1) &= h(\vec x, y, g(\vec x, y))
		\end{align*}
		Возьмём общую оценку $N'$ на $f$ и $h$:
		\begin{align*}
			f(\vec x) &\le a_{N'}(x_{\max}) = a_{N'}(\max \{ x_{\max}, 0 \}) \\
			h(\vec x, y) &\le a_{N'}(\max \{ x_{\max}, y \})
		\end{align*}
		Индукцией по $i$ покажем, что $g(\vec x, i + 1) \le a_{N'}^{[i+2]}(\max \{ x_{\max}, i \})$

		\begin{description}
			\item[База $i=0$:]
				\begin{align*}
				g(\vec x, 0 + 1)
				&= h(\vec x, 0, g(\vec x, 0))
				\le a_{N'}(\max\{x_{\max}, 0, g(\vec x, 0)\}) \le \\
				&\le a_{N'}(\max\{x_{\max}, 0, a_{N'}(x_{\max})\})
				\le a_{N'}^{[2]}(\max\{x_{\max}, 0, x_{\max}\})
				\end{align*}

			\item[Переход $(i-1) \to i$:]
				Предполагаем, что $i \ge 1$:
				\begin{align*}
					g(\vec x, i + 1)
					&= h(\vec x, i, g(\vec x, i))
					 \le a_{N'}(\max \{ x_{\max}, i, g(\vec x, i) \}) \le \\
					&\le a_{N'}(\max \{ x_{\max}, i, a_{N'}^{[i+1]}(\max\{ x_{\max}, i - 1 \}) \}) \le \\
					&\le a_{N'}(a_{N'}^{[i+1]}(\max\{ x_{\max}, i \}))
					   = (a_{N'}^{[i+2]}(\max\{ x_{\max}, i \}))
				\end{align*}
		\end{description}

		Теперь мы имеем требуемую оценку на $N=N'+1$:
		\begin{align*}
			g(\vec x, 0) &\le a_{N'}(\max \{ x_{\max}, 0 \}) \le a_N(\max \{ x_{\max}, 0 \}) \\
			g(\vec x, i + 1)
			&\le a_{N'}^{[i+2]}(\max \{ x_{\max}, i \}) \\
			&\le a_{N'}^{[2 + \max \{ x_{\max}, i \}]}(\max \{ x_{\max}, i \})
			   = a_N(\max \{ x_{\max}, i \}) \le \\
			&\le a_N(\max \{ x_{\max}, i + 1 \})
		\end{align*}
	\end{enumerate}
\end{proof}

\begin{conseq}
	Фукнция $b(n)=a_n(n)$ (от одного аргумента $n$) не является примитивно рекурсивной.
\end{conseq}
\begin{proof}
	Пусть является.
	Тогда существует $N$ такое, что $b(n) \le a_N(n)$ для всех $n$.
	Рассмотрим случай $n=N+1$:
	\begin{align*}
		b(n) &\le a_N(n) \\
		b(n) = b(N+1) &= a_{N+1}(N+1) > a_N(N+1) = a_N(n)
	\end{align*}
	Противоречие.
\end{proof}

\begin{conseq}
	Функция Аккермана от двух аргументов не является примитивно рекурсивной.
\end{conseq}
\begin{proof}
	Если $a(i, x)$ является примитивно рекурсивной, то $b(n)=a(\pi_1^1(n), \pi_1^1(n))$ тоже является, что не так.
\end{proof}

\begin{Exercise}
	При фиксированном $k$ функция $a_k(x)$, тем не менее, является примитивно рекурсивной.
\end{Exercise}

\chapter{Исчисление предикатов}
\section{Элиминация кванторов}

\subsection{Мотивация}
Давайте вспомним предикатные формулы. Например, такие: носитель интерпретаций "--- $\Z$, $\mathcal P = \{ = \}$, $\mathcal F = \{ + \}$.
\begin{assertion}
	Предикат $x < y$ невыразим.
\end{assertion}
\begin{proof}
	Вспомним \textit{метод автоморфизмов}: мы предъявляем некоторый автоморфизм $\Z$ (биекцию между элементами $\Z$ и $\Z$), сохраняющий
	все операции (и предикатные, и функциональные) и показываем, что искомый предикат он не сохранит.

	В самом деле: возьмём преобразование $x \lra (-x)$.
	Оно является автоморфизмом:
	\begin{itemize}
	\item $x \lra (-x)$ "--- биекция $\Z \lra \Z$
	\item $(x = y) \iff (-x = -y)$
	\item $-(x + y) = (-x) + (-y)$
	\end{itemize}
	При этом легко предъявить два элемента $\Z$ (при этом выразимость этих элементов неважна, важно лишь их существования): $0$ и $1$, для которых
	предикат $x < y$ меняется от автоморфизма.
	Следовательно, предикат $x < y$ невыразим.
\end{proof}
\begin{Rem}
	Для применения метода автоморфизмов важно предъявлять именно автоморфизм, т.е. именно биекцию, причём сохраняющую \textsl{все} операции.
\end{Rem}

Теперь изменим функциональную операцию: возьмём $S(x)=x+1$ вместо $+$.
Оказывается, что предикат $x < y$ всё еще невыразим, однако множество допустимых автоморфизмов сузилось: это только сдвиги вида $x \lra x+C$,
сохряняющие в том числе отношение $x < y$.
Таким образом, метод автоморфизмов тут неприменим.

Более того, если рассмотреть предикатные формулы над $(\No, =, S)$, то автоморфизмов вообще не окажется (кроме тривиального).
Соответственно, доказать хоть что-то про невыразимость методом автоморфизмов не получится.
Однако это вовсе не означает, что все предикаты выразимы.

Дальше мы покажем более мощный метод, позволяющий, среди прочего, доказывать невыразимость.

\subsection{Над целыми числами}
\begin{theorem}\label{elim_z_eq_s}
	В интерпретации $(\Z, =, S)$ допустима \textit{элиминация кванторов}, то есть любой выразимый предикат можно выразить без кванторов.
\end{theorem}
\begin{conseq}
	Предикат $x < y$ невыразим.
\end{conseq}
\begin{proof}
	От противного: пусть $x < y$ выразим и, следовательно, представляется в бескванторной форме.
	Заметим, что все атомарные формулы имеют вид $S(S(\dots(x)\dots)) = S(\dots(y)\dots)$,
	то есть задают условия вида $x=y+k$, где $k \in \Z$ "--- некоторая фиксированная константа.
	Тогда выбрав из этих констант максимальную по абсолютному значению "--- $K$, можно взять любое число
	$x$ и заметить, что если мы возьмём $y$, достаточно сильно отличающийся от $x$ (хотя бы на $K+1$ по модулю разности), то
	все атомарные формулы будут одинаково ложны независимо от выбора $y$.

	В частности, наш предикат не сможет отличить $y$, сильно больший $x$ от $y$, сильно меньшего $x$.
	Получили противоречие.
\end{proof}

Теперь докажем теорему \ref{elim_z_eq_s}:
\begin{proof}
	Сначала возьмём выразимый предикат $P$ и заменим все входящие в него кванторы всеобщности на кванторы существования:
	\[ (\forall x \colon A) \iff (\lnot(\exists x \colon \lnot A)) \]
	Теперь запустим индукцию по числу кванторов $k$ в формуле.
	База для $k=0$ очевидно: формула уже бескванторная.

	Переход: рассмотрим самый <<внутренний>> квантор в формуле, т.е. выражение следующего вида:
	\[ \exists x \colon \phi(x_1, \dots, x_n, x) \]
	Тут $\phi$ "--- бескванторная.
	Если мы сможем выразить это выражение без кванторов, то переход будет доказан: мы уменьшим число кванторов и воспользуемся индукционным предположением.

	Теперь рассмотрим все автомарные формулы, встречающиеся в $\phi$.
	Уже знакомыми нам рассуждениями легко показать, что они все эквивалентны уравнениям вида $\alpha = \beta + k$, где $k$ "--- какие-то константы из $\Z$, а $\alpha$ и $\beta$ "--- переменные.
	\begin{itemize}
	\item
		Рассмотрим атомарные формулы вида $x = x + k$.
		Очевидно, что при $k=0$ их можно заменить на тождественную истину, а при $k \neq 0$ "--- на тождественную ложь.
		\begin{Rem}
			Без тождественной истины предикат без аргументов $\exists x \colon x=x$ в бескванторной форме не выразить.
			Если же сказать, что мы выражаем только предикаты с ненулевым числом аргументов, то легко выразить тождественную истину и ложь.
		\end{Rem}
	\item
		Значение атомарных формул вида $x_i = x_j + k$ не зависит от $x$.
	\item
		Рассмотрим атомарные формулы вида $x = x_i + k$, назовём их $t_1, t_2, \dots, t_s$.
		Так как их конечно, то существует некоторый $x$, при котором ни одна из них не будет выполнена.
		Построим формулу $\psi$: это $\phi$, в которой все $t_i$ заменены на тождественную ложь.

		Теперь рассмотрим все возможные значения для $x$, которые хотя бы одну формулу из $t_i$ превратят в истину: $\alpha_1, \alpha_2, \dots, \alpha_s$.
		Их тоже конечно, они зависят только от структуры $t_i$.
		Тогда можно переписать исходную формулу в бескванторном виде:
		\[ (\exists x \colon \phi(x_1, \dots, x_n, x)) \iff (\Lor_{i=1}^s \phi(x_1, \dots, x_n, \alpha_i)) \lor \psi(x_1, \dots, x_n) \]
		В самом деле: нам сами значения $x$ неважны, а важно лишь то, какие из $t_i$ обращаются в истину.
		Все возможные варианты мы покрыли.
	\end{itemize}
\end{proof}
\begin{Rem}
	Мы не только доказали теорему, но и предъявили явный алгоритм.
	Основная идея была в том, что сами значения $x$ в кванторах нам неинтересны, нам интересно лишь то, какие
	атомарные формулы в каких комбинацию могут выполняться, а так как атомарных формул конечно, мы смогли предъявить конечное число <<интересных>> $x$.
\end{Rem}

\subsection{Над вещественными и рациональными}
\begin{theorem}
	В $(\Q, =, >, +, \text{рац. константы})$ допустима элиминация кванторов.
\end{theorem}
\begin{proof}
	\begin{enumerate}
		\item
			Избавляемся от квантора $\forall$
		\item
			Применяем индукцию и в переходе берём самый вложенный $\exists$:
			\[ \exists x \colon \phi(x_1, \dots, x_n, x) \]
		\item
			Избавимся от отрицаний в $\phi$, <<пронеся>> их внутрь к атомарным формулам по правилам де Моргана,
			а затем убрав отрицания от атомарных формул:
			\begin{itemize}
				\item $\lnot (x > y) \iff (y > x) \lor (y = x)$
				\item $\lnot (x = y) \iff (x > y) \lor (y > x)$
			\end{itemize}
		\item
			Приводим формулу в ДНФ, причём так, чтобы новых отрицаний не образовалось.
			Это можно сделать при помощи алгоритма с раскрытием скобок, используя формулу: $a \land (b \lor c) \iff (a \land b) \lor (a \land c)$.
			Теперь преобразуем:
			\begin{gather*}
			\exists x \colon (C_1 \lor C_2 \lor \dots \lor C_k) \\
			\Updownarrow
			(\exists x \colon C_1) \lor (\exists x \colon C_2) \lor \dots \lor (\exists x \colon C_k)
			\end{gather*}
			Количество кванторов мы, конечно, увеличили, но сейчас избавимся от каждого в отдельности "--- случаи стали приятнее.
		\item
			Теперь разберёмся с элиминацией кванторов в выражении $\exists x \colon C_i$.
			Так как мы получили $C_i$ из ДНФ без отрицаний, $C_i$ представляет собой конъюнкцию атомарных формул без отрицаний.
			Каждая атомарная формула "--- это линейное уравнение или неравенство над $x_1, \dots, x_n, x$.
			В каждой атомарной формуле, где есть $x$, можно перенести $x$ влево, всё остальное "--- вправо, и нормализовать коэффициент при $x$
			при помощи деления в $\Q$ (возможно, со сменой знака неравенства).

			Таким образом, $C_i$ "--- это просто система уравнений и неравенств.
			Условия, не содержащие $x$, можно оставить, как есть.
			Разберёмся с оставшимися, есть три случая:
			\begin{itemize}
			\item
				Если есть условие вида $x = \dots$, то можно взять любое и подставить во всём выражении $\phi$ вместо $x$ соответствующее выражение,
				получим выражение без $x$, с которого можно безболезненно снять квантор $\exists x$.
			\item
				Если у нас неравенства на $x$ только с одной стороны (например, $x < x_1$ и $x < x_3 - x_2$), то
				все эти неравенства можно просто убрать "--- очевидно, существует достаточно маленький/большой $x$.
			\item
				Остался единственный случай: у нас есть неравенства на $x$ с двух сторон, например:
				\[
					\begin{cases}
					x < t_1, \\
					x < t_2, \\
					\vdots \\
					x < t_s, \\
					x > z_1, \\
					x > z_2, \\
					\vdots \\
					x > z_r, \\
					\end{cases}
				\]
				Тогда существование нужного $x$ есть в точности система $\Land_{i=1}^r \Land_{j=1}^s z_i < t_j$.
			\end{itemize}
	\end{enumerate}
\end{proof}
\begin{Rem}
	В $(\R, =, >, +, \text{вещ. константы})$ тоже допустима элиминация кванторов "--- мы нигде не пользовались рациональностью $\Q$.
	Мы пользовались только отсутствием наибольших и наименьших элементов, плотностью и возможностью делить.
\end{Rem}
\begin{conseq}
	Любая \textit{замкнутая} формула из $(=, >, +, \text{рац. константы})$ одинаково верна и в $\Q$, и в $\R$.
	Например: $\forall x \colon \exists y \colon x + x = y$.
\end{conseq}
\begin{proof}
	Применим наш алгоритм элиминации к формуле над $\R$ и к той же формуле над $\Q$,
	получим одинаковый результат (так как алгоритм действует одинаково).
	Так как формула была замкнутой, мы получим либо тождественную ложь, либо тождественную истину.
\end{proof}
\begin{Rem}
	Умножение добавлять в сигнатуру нельзя.
	Например: $\exists x \colon x \cdot x = 2$ верна в $\R$, но не в $\Q$.
\end{Rem}

\subsection{Пример задачи}
\begin{theorem}
	Пусть имеется единичный квадрат, разрезанный на несколько квадратов со сторонами $r_1, r_2, \dots, r_k$.
	Тогда стороны этих квадратов рациональны.
\end{theorem}
\begin{proof}
	Напишем формулу с параметрами $r_1, \dots, r_k$, которая проверяет существование разбиения: существуют такие координаты углов $(x_1, y_1), \dots, (x_k, y_k)$,
	что никакие два квадратика не пересекаются (то есть не пересекаются либо их проекции по $x$, либо их проекции по $y$), все квадратики лежат внутри единичного,
	а также сумма площадей всех квадратиков равна единице (что не зависит от координат).
	Каждое из этих условий "--- это какие-то неравенства/уравнения от координат и размеров квадратиков.

	В этой формуле можно элиминировать кванторы, избавиться от отрицания и привести в ДНФ.
	Рассмотрим каждый конъюнкт по отдельности, покажем, что все его решения рациональны.
	Конъюнкт эквивалентен системе некоторых неравенств и уравнений на $r_i$.
	Системы без решений сразу рассматривать не будем "--- они неинтересны.

	Возьмём систему с решением $r$.
	Сначала посмотрим отдельно на уравнения, входящие в эту систему.
	Если решение подсистему из уравнений единственно, то оно рационально (так как все коэффициенты рациональны и можно применить формулу Крамера).
	Если же решений подсистемы уравнений бесконечно много, то имеется целая прямая этих решений, причём проходящая через $r$.
	Неравенства на этой прямой высекут некоторый открытый отрезок.
	Очевидно, он непуст, так как $r$ в нём точно лежит.

	Теперь заметим, что целого отрезка решений системы из уравнений и неравенств у нас быть не может.
	В самом деле: пусть у нас есть отрезок $[r, r+h]$, то есть любой набор квадратов вида $r_1 + th_1, \dots, r_k + th_k$
	замощает единичный квадрат.
	Посчитаем их суммарную площаль, получим некоторый многочлен от $t$ степени 2, причём старший коэффициент (равный $h_1^2+h_2^2+\dots+h_k^2$) нулю не равен.
	Стало быть, этот многочлен не может быть равен единице на отрезке $[0, 1]$, противоречие.
\end{proof}
