% Начало в 05.tex
	\begin{proof}
		У нас есть какая-то формула вида
		\[\exists y_1 \forall y_2 \dots y_i \colon Q(y_1, \dots, y_i, x_1, \dots, x_n)\]
		Формула $Q$ разрешима и, соответственно, арифметическая.
		А в начале у нас просто идёт куча кванторов, которые мы можем дописывать в арифметическое выражение.
	\end{proof}

\item\label{mReducibleInvariant}
	$\Sigma_i$ и $\Pi_i$ для $i \ge 0$ <<замкнуты>> (в одну сторону) относительно $m$-сведения.
	Напоминание: $A \le_m B $ ($B$ $m$-сводится к $A$) $\iff \exists f$ (всюду определённая вычислимая функция) такая,
	что $x \in A \iff f(x) \in B$.

	\begin{assertion}
		Пусть $P_1(x_1, \dots, x_n) \in \Sigma_i$ и $P_2 \le_m P_1$.
		Тогда $P_2 \in \Sigma_i$.
	\end{assertion}
	\begin{proof}
		Так как $P_1 \in \Sigma_i$, то существует разрешимый предикат $Q$ и для всех $x_1, \dots, x_n$ верно:
		\[ P_1(x_1, \dots, x_n)=1 \iff \exists y_1, \forall y_2, \dots, y_i \colon Q(y_1, y_2, \dots, y_i, x_1, \dots x_n) \]
		Так как $P_2 \le_m P_1$, то есть $f$ из определения $m$-сводимости.
		Давайте представим $P_2$:
		\begin{align*}
		P_2(z_1, \dots, z_n) &= P_1(f(z_1, \dots, z_n)) \\
		P_2(z_1, \dots, z_n) &= \exists y_1, \forall y_2, \dots, y_i \colon Q(y_1, y_2, \dots, y_i, f(z_1, \dots, z_n))
		\end{align*}
		$Q$ был разрешим, мы кусок аргументов заменили на что-то, вычисляемое всегда останавливающимся
		алгоритмом.
		Значит, результатирующий предикат тоже разрешим.
		Таким образом, $P_2$ имеет ровно такой вид, какой надо для попадания в $\Sigma_i$.
	\end{proof}

\item
	\begin{Def}
		Пусть $X$ "--- множество $k$-местных предикатов, $(k+1)$-местный предикат $u$
		называется универсальным для $x$, если:
		\[
		\forall P \in X \colon \exists p \in \No \colon \forall x_1, \dots, x_n \in \No \colon
		P(x_1, \dots, x_n) = u(p, x_1, \dots, x_n)
		\]
		То есть если любой предикат из $X$ можно получить из $u$ фиксацией первого аргумента.
	\end{Def}
	\begin{assertion}
		Для любого $i \ge 1$ и $k \in \No$ существует универсальный предикат для $k$-местных предикатов
		из $\Sigma_i$, который сам лежит в $\Sigma_i$.
		Аналогично для $\Pi_i$.
	\end{assertion}
	\begin{proof}
		\begin{description}
		\item[База:]
			Для простоты считаем $k=1$ (для двухместных и более предикатов всё точно так же).
			Найдём универсальный предикат для $\Sigma_1$, например:
			\[
			U(n, x) =
			\left\{
			\begin{matrix}
			1, &\text{если $\langle n\rangle(x)$ останавливается} \\
			0, &\text{иначе}
			\end{matrix}
			\right.
			\]
			В самом деле, $U(n, x) \in \Sigma_1$, так как он полуразрешим.
			Теперь покажем, что он универсален.
			Возьмём $P\in \Sigma_1$.
			Пусть полуразрешающий алгоритм для $P$ имеет номер $p$.
			Тогда $P(x)=1$ тогда и только тогда, когда $\langle p \rangle$ останавливается $\iff U(p, x)=1$.
			Значит $U$ универсален для $\Sigma_1$.

			Универсальным для $\Pi_1$ будет отрицание этого предиката ($\lnot U(p, x)$).
		\item[Переход $i \to i+1$:]
			Рассмотрим какой-нибудь $P \in \Sigma_{i+1}$, по определению существует предикат $Q \in \Pi_i$ такой, что для всех $x$:
			\[ P(x) = 1 \iff \exists y \colon Q(y, x) = 1 \]
			Так как $Q \in \Pi_i$, то можем взять универсальный предикат $U_{\Pi_i}$ для двухместных из $\Pi_i$
			(если $P$ больше, чем одноместный, то тут возьмёся универсальный предикат для трёхместных и так далее).
			Значит, существует $q \in \No$ такое, что $Q(y, x) = U_{\Pi_i}(q, y, x)$.
			Тогда для всех $x$:
			\[ P(x) = 1 \iff \exists y \colon U_{\Pi_i}(q, y, x) \]
			Теперь выпишем универсальный предикат для $\Sigma_{i+1}$:
			\[ U_{\Sigma_{i+1}}(p, x) = 1 \iff \exists y \colon U_{\Pi_i}(p, y, x) \]

			Осталось проверить, что $U_{\Sigma_{i+1}} \in \Sigma_{i+1}$, что несложно: он имеет вид $\exists y \colon X$, где $X \in \Pi_i$, что и требуется.
		\end{description}
	\end{proof}
	\begin{Exercise}
		Для $i=0$ свойство неверно.
	\end{Exercise}	
	\begin{Exercise}
		Выписать универсальный предикат явно.
	\end{Exercise}	

\item
	Для любого $i \ge 0$ универсальный предикат для одноместных из $\Sigma_i$ не содержится в $\Pi_i$.
	Тут уже одноместность важна (для более высоких порядков вроде сложнее получается).
	\begin{proof}
		Пусть $U_{\Sigma_i}$ "--- универсальный предикат для $\Sigma_i$, лежащий в $\Pi_i$.
		Возьмём отрицание $T$ этого предиката:
		\[ T(n, x) = \lnot U_{\Sigma_i}(n, x) \]
		\begin{enumerate}
		\item
			Так как $U_{\Sigma_i} \in \Pi_i$ (по предположению), то $T \in \Sigma_i$.
		\item
			Предикат $t(x)=T(x, x)$ тоже лежит в $\Sigma_i$, так как мы просто выполнили подстановку.
		\item
			Тогда давайте выразим $t$ через наш универсальный предикат.
			Существует $k \in \No$ такое, что для всех $x$:
			\[ t(x) = U_{\Sigma_i} (k, x) \]
		\item
			С одной стороны, $t(k) = U_{\Sigma_i} (k, k)$.
			С другой стороны, это $\lnot U_{\Sigma_i} (k, k)$.
			Противоречие.
		\end{enumerate}
	\end{proof}

\item
	Для $i \ge 1$ имеем $\Sigma_i \neq \Pi_i$.
	\begin{proof}
		Есть универсальный предикат $U_{\Sigma_i}$, лежащий в $\Sigma_i$, не лежащий в $\Pi_i$.
	\end{proof}

\item
	$\Sigma_{i+1} \supsetneq \Sigma_i$.
	\begin{proof}
		$\Sigma_{i+1} \supseteq \Pi_i \supsetneq \Pi_i \setminus \Sigma_i \neq \varnothing$.
	\end{proof}
\end{enumerate}

\subsubsection{Картинка с иерархией}
\begin{center}
	\includegraphics[scale=2]{06-sigma-pi-1.ps}
\end{center}

\subsection{Теоремы Тарского и Гёделя}

Обозначим за $\mathcal{T}$ (от слова <<truth>>) множество номеров замкнутых формул в арифметике,
которые истинны.
Например, вот такая арифтметическая формула лежит в $\mathcal{T}$ (Великая теорема Ферм\'а):
\[ \forall x, y, z, n \colon ((n \ge 3 \land x > 0 \land y > 0) \Ra x^n + y^n \ne z^n) \]

\begin{theorem}[Тарского]
	<<Истинность невыразима>>.
	Множество $\mathcal{T}$ невыразимо в арифметике.
\end{theorem}
\begin{proof}
	От противного.
	Пусть $\mathcal{T}$ выразим в арифметике предикатом $T$.
	Тогда $T \in \Sigma_k$ для некоторого $k$ (если содержится в некотором $\Pi_{x}$, то содержится и в $\Sigma_{x+1}$).
	Докажем, что любой арифметический предикат $P$ $m$-сводится к $T$ ($P \le_m T$).

	Возьмём какой-нибудь предикат $P(x)$, который задаётся формулой $\phi(x)$.
	Возьмём функцию $f(x) = \# \phi(x)$, то есть номер формулы $\phi$, в которой единственный аргумент заменили
	на константу $x$, получили формулу с нулём аргументов, взяли её номер.
	\begin{Rem}
	Заменять аргумент можно, например, конструкцией вида $\forall y \colon (y=x) \Ra \phi(y)$, если
	у нас в формулах нет понятия <<константа в чистом виде>>.
	\end{Rem}
	Получили следующее:
	\[ P(x) = 1 \iff \phi(x) = 1 \iff T(f(x)) = 1 \iff T(\# \phi(x)) = 1 \]
	Что есть в точности определение $m$-сводимости $P$ к $T$.
	
	Теперь возьмём произвольный $P \in \Sigma_{k+1}$.
	Так как $P \le_m T$, то $P \in \Sigma_k$, так как $\Sigma_k$ \hyperref[mReducibleInvariant]{замкнуто} относительно $m$-сведения.
	То есть $\Sigma_k = \Sigma_{k+1}$, противоречие.
\end{proof}

\begin{conseq}[Первая теорема Гёделя о неполноте]
	$\mathcal{T}$ не является перечислимым.
\end{conseq}
\begin{proof}
	Если бы $\mathcal{T}$ было перечислимым, то оно было бы и выразимым в арифметике, что неверно.
\end{proof}

\subsubsection{Пояснение из Computer Science}
Предыдущая формулировка несколько отличается от того, что обычно слышат перед курсом логики.
Обычно слышат что-то вроде <<нет системы доказательств, в которой можно доказать все утверждения
про натуральные числа>>.
\begin{Def}
	Система доказательств для множества $A$ (подмножество каких-нибудь строк, <<утверждений>>) "--- это всюду определённый алгоритм $V$ (от слова <<verify>>).
	Параметра два: $x$ (утверждение) и $w$ (<<witness>>, собственно, доказательство).
	Свойства:
	\begin{description}
	\item[Корректность:]
		$V(x, w) = 1 \Ra x \in A$
	\item[Полнота]
		$\forall x \in A \colon \exists w \colon V(x, w) = 1$
	\end{description}
\end{Def}
\begin{Rem}
	Это определение из Computer Science, обобщающее похожие утверждения из логики.
\end{Rem}
\begin{Rem}
	Например, в матанализе мы обычно доказываем, что какое-то утверждение (<<теорема>>) лежит в множестве
	верных утверждений.
\end{Rem}

\begin{theorem}
	Множество $A$ имеет систему доказательств $\iff$ $A$ перечислимо.
\end{theorem}
\begin{proof}
	\begin{description}
	\item[$\Ra$:]
		Предъявим полуразрешающий алгоритм для $A$ (тогда $A$ перечислимо).
		Называется <<алгоритм Британского музея>> (потому что в этом музее есть всё, в том числе доказательства любой теоремы).
		Просто перебираем все $w$, для каждого запускаем $V$ (который всегда завершается).
	\item[$\La$:]
		Пусть $A$ перечислимо, $B$ "--- полуразрешимый алгоритм для $A$.
		Тогда доказательством для $x$ будет являться число $w$ "--- сколько шагов алгоритма $B$ надо выполнить,
		чтобы $B$ завершился и сказал <<$x \in A$>>:
		\[
		V(x, w) =
		\begin{cases}
		1,& \text{если $B(x)$ останавливется после $w$ шагов} \\
		0,& \text{иначе}
		\end{cases}
		\]
	\end{description}
\end{proof}
\begin{conseq}
	Так как $\mathcal{T}$ неперечислимо, то для него нет системы доказательств.
\end{conseq}

\subsubsection{Альтернативное доказательство теоремы Гёделя}
\begin{proof}
	Пусть $\overline W = \{ n \mid \langle n \rangle (n) \text{~не останавливается} \}$ (а $W = \overline{\overline W}$).
	Мы знаем, что $W$ неразрешимо, но перечислимо, значит, $\overline W$ неперечислимо (иначе бы $W$ было разрешимым по \hyperref[postTh]{теореме Поста}).

	Хотим доказать, что $\overline W$ $m$-сводится к $\mathcal{T}$ ($\overline W \le_m \mathcal{T}$).
	тогда будет следовать, что $\mathcal{T}$ неперечислимо, так как $\overline W$ неперечислимо.

	Возьмём функцию:
	\[ f(n) = \# (\langle n \rangle (n) \text{~не останавливается}) \]
	Покажем, что справа стоит какая-то формула.
	В самом деле, <<$\langle n \rangle (n)$ не останавливается>> есть не что иное, как предикат
	<<для любого $t$ алгоритм $\langle n \rangle(n)$ не останавливается за $t$ шагов>>, вторая часть выражается в арифметике
	(так как является разрешимым предикатом), квантор приписать тоже можем.
\end{proof}

\section{Рекурсивные функции}
Это еще один способ определить вычислимые функции, похожий на функциональные языки программирования.
По сути "--- еще одна формальная модель вычислений.

\begin{Def}
	Операция подстановки:
	пусть $h(x_1, \dots, x_k)$ "--- функция, и $g_1, g_2, \dots, g_k \colon \No^n \to \No \cup \{\bot\}$, то можно составить
	функцию
	\[
	h(g_1(x_1, \dots, x_n), g_2(x_1, \dots, x_n), \dots, g_k(x_1, \dots, x_n))
	\]
	Тут $\bot$ обозначает, что функция не определена.
\end{Def}
\begin{Def}
	Операция примитивной рекурсии:
	пусть есть функции $f$, $g$, тогда можно определить $h$;
	\begin{gather*}
	h(x_1, \dots, x_k, 0) = f(x_1, \dots, x_k) \\
	h(x_1, \dots, x_k, y+1) = g(x_1, x_2, \dots, x_k, y, h(x_1, \dots, x_n, y))
	\end{gather*}
\end{Def}
\begin{Def}
	Примитивно рекурсивная функция "--- это функция, которая может быть получена при помощи
	правил подстановки и примитивной рекурсии из следующих базисных:
	\begin{enumerate}
	\item $0$-константа
	\item $S(x)=x+1$
	\item $\pi_k^i(x_1, \dots, x_k)=x_i$
	\end{enumerate}
\end{Def}

\begin{exmp}
	$x+y$ можно определить примитивно рекурсивно:
	\begin{gather*}
	x+0=x=\pi_1^1(x) \\
	x+(y+1)=S(x+y)
	\end{gather*}
\end{exmp}
\begin{exmp}
	$x \cdot y$ можно определить примитивно рекурсивно:
	\begin{gather*}
	x\cdot 0=0 \\
	x\cdot(y+1)=(x\cdot y) + \pi_2^1(x, y) = (x\cdot y) + x
	\end{gather*}
	Формально проекция $\pi_2^1(x, y)$ нужна, но мы её дальше будем опускать.
\end{exmp}
