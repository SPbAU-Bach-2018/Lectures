% Замечание от Пети
\begin{Rem}
	У нас, вообще говоря, функции могли выдавать значение $\bot$ (<<штопор>>), а принимать не вход "--- не могли.
	Писать композицию в таком случае неаккуратно.
	Поэтому мы считаем, что $\bot$ у нас на случай <<значение функции не определено>>, и если он возникает в качестве одного из аргументов, значение любой функции тоже становится $\bot$.
\end{Rem}

Добавим еще несколько примеров (звёздочка обозначает <<было на практике>>):
\begin{enumerate}
	\setcounter{enumi}{2}
	\item$^\star$ $x \dot- y$ (усечённое вычитание): $\max(0, x - y)$.
	\item$^\star$ $S \subset \N^k$ называется примитивно рекурсивным, если:
		\begin{enumerate}
		\item $\chi_s$ (характеристическая функция $f$) является примитивно рекурсивной.
		\item $\exists$ примитивно рекурсивная $f(x_1, \dots, x_k)$ такая, что $S = \{ x \in \N^k \mid f(x) = 0\}$
		\end{enumerate}
		Два этих определения эквивалентны.
		Разница между ними в том, что характеристическая функция принимает всего два значения,
		а вот во втором пункте различных значений функции может быть произвольно много.
	\item$^\star$ Объединение, пересечение, дополнение примитивно рекурсивных множеств примитивно рекурсивно.
	\item Примитивно рекурсивный предикат "--- это частный случай примитивно рекурсивной функции (принимающей только значения $0$ или $1$).
		Предикат примитивно рекурсивен тогда и только тогда, когда множество его единиц примитивно рекурсивно.
		Из предыдущего пункта следует, что если $P$, $Q$ примитивно рекурсивны, то $P\land Q$, $P\lor Q$, $\lnot P$
		тоже примитивно рекурсивны
	\item$^\star$ Предикат $x=0$
	\item$^\star$ Предикат $x\ge y$
	\item$^\star$ Предикат $x=y$
	\item Условный оператор:
		\begin{alignat*}{2}
			f(x) &= \t{if~} r(x)&\t{~then~}&g(x) \\
			     &              &\t{~else~}&h(x)
		\end{alignat*}
		где $r(x)$ "--- примитивно рекурсивный предикат, а $g(x)$ и $h(x)$ "--- примитивно рекурсивные функции.
		\begin{proof}
			\[ f(x) = (1 \dot- r(x))h(x) + r(x)g(x) \]
			Если $r(x)=0$ (неверен), то зануляется первое слагаемое, а второе остаётся.
			Если $r(x)=1$, то наоборот.
		\end{proof}
	\item $x \bmod n$.
		\begin{proof}
			Для начала определим функцию $h(x, n)$ которая прибавляет единицу по модулю,
			если $x<n$:
			\[ h(x) = \t{if~} x+1 < n \t{~then~} x + 1 \t{~else~} 0 \]

			Теперь определяем модуль рекурсивно примитивно:
			\begin{align*}
			0     &\bmod n = 0 \\
			(x+1) &\bmod n = h(x \mod n, n)
			\end{align*}
		\end{proof}
	\item$^\star$\label{limitedQuantification}
		Если $R(x, y)$ "--- примитивно рекурсивный предикат, то следующие два предиката тоже примитивно рекурсивны (<<ограниченные кванторы>>):
		\begin{enumerate}
			\item $S(x, z) = \exists y \le z \colon R(x, y)$
			\item $T(x, z) = \forall y \le z \colon R(x, y)$
		\end{enumerate}
	\item
		Пусть $\Gamma_f$ (график функции $f$, множество пар) "--- примитивно рекурсивное множество,
		причём $f(x) \le g(x)$ (где $g(x)$ примитивно рекурсивна).
		Тогда $f(x)$ тоже примитивно рекурсивна.
		Тут нам неважно, что $x$ "--- это один аргумент, это может быть целый вектор.
		\begin{proof}
			Пусть $\Gamma(x, y)$ "--- характеристическая для $\Gamma_f$.
			Тогда можно записать:
			\[
				f(x) = \sum_{y=0}^\infty \Gamma(x, y) \cdot y
			\]
			В этой бесконечной сумме у нас ровно одно ненулевое слагаемое.
			К сожалению, бесконечных сумм у нас нет, но мы знаем, что можно суммировать только до $g(x)$:
			\[
				f(x) = \sum_{y=0}^{g(x)} \Gamma(x, y) \cdot y
			\]
			Осталось показать, что суммирование $\sum_{y=0}^n h(y)$ примитивно рекурсивно (если $h(y)$ примитивно рекурсивно).
			Потом подставим нужную верхнюю границу.

			Доказываем операцией примитивной рекурсии:
			\begin{itemize}
			\item $\sum_{y=0}^0 h(y) = h(0)$
			\item $\sum_{y=0}^{n+1} h(y) = \left(\sum_{y=0}^n\right) + h(y+1)$
			\end{itemize}
		\end{proof}
	\item Ограниченный оператор минимизации примитивно рекурсивен:
		\[
			f(x) =
			\begin{cases}
				\min_{y \le g(x)} R(x, y), \\
				g(x) + 1, \text{~если такого $y$ нет}
			\end{cases}
		\]
		Здесь $g(x)$ примитивно рекурсивна.
		\begin{proof}
			Воспользуемся предыдущим пунктом.
			По определению $f(x) \le g(x) + 1$.
			Осталось понять, что график примитивно рекурсивен.
			Если игнорировать тот факт, что $y$ может не найтись, то можно написать вот такую характеристическую функцию для графика:
			\[ h(x, y) = R(x, y) \land (\underbrace{\forall y' < y \colon \lnot R(x, y')}_\text{примитивно рекурсивно по пункту \ref{limitedQuantification}}) \]
			Это примитивно рекурсивная функция.
			Можно даже добавить в конец $\land (y \le g(x))$, но тогда у нас в некоторых точках $x$ графика просто не будет.
			Лечится условным оператором:
			\begin{align*}
				\Gamma_f(x, y) = \t{if~} (y \le g(x)) &\t{~then~} h(x, y) \\
				                                      &\t{~else~} (y=g(x)+1) \land (\forall y' < y \colon \lnot R(x, y'))
			\end{align*}
			Альтернативно можно дописать к $h$ условие $y \le g(x)$ и логическое <<или>> результата с веткой \t{else}.
			По смыслу то же самое, но без оператора \t{if}:
			\begin{align*}
				\Gamma_f(x, y) &= (h(x, y) \land (y \le g(x))) \lor \\
				               &\lor ((y=g(x)+1) \land (\forall y' < y \colon \lnot R(x, y')))
			\end{align*}
		\end{proof}
	\item
		Кодирование пар: $[x, y]=(x+y)^2+y$.
		Для разных пар это разные значения (потому что $(x+y)^2 \le (x+y)^2 + y < (x+y+1)^2$)
		Это не взаимооднозначное кодирование, но по паре мы умеем однозначно восстанавливать $x$ и $y$:
		\[ p_1(n) = \min \{ x \le n \colon \exists y \le n: [x, y] = n \} \]
		Аналогично восстанавливается $p_2(n)$.
		Теперь можно строить даже тройки, четвёрки и так далее (например, объединяя пары).
\end{enumerate}

\begin{theorem}\label{primitiveRecursiveTuring}
	Если $g$ "--- примитивно рекурсивная функция и $f(x)$ вычислияется на машине Тьюринга за $\le g(x)$ шагов, то $f$ тоже примитивно рекурсивна.
\end{theorem}
\begin{Rem}
	Альтернативно на паскале: \TODO
\end{Rem}
\begin{proof}
	Был рассказан некий план решения, <<который вы можете самостоятельно дополнить деталями>>.
	Пусть $|\Sigma|=m$ "--- число символов в алфавите машины Тьюринга.
	Мы уже кодировали конфигурацию машины Тьюринга при помощи натуральных чисел: стэк элементов левее головки $l$,
	стэк элементов правее головки $r$, символ $c$ под головкой, состояние $q$.
	Стэки мы храним, как числа в системе счисления с основанием $m$: $a_0+ma_1+m^2a_2+\dots$ (если $a_0$ "--- элемент на вершине).

	Дальше нужна функция $\t{Init}(x)$, возвращающая изначальное состояние машины (закодированную четвёрку),
	то есть ленту с $x$, разложенным в двоичную систему.
	Также нужна функция $\t{Result}(x)$, которая считывает ответ из конфигурации и возвращает.
	Это можно выразить через имеющиеся примитивно рекурсивные функции.

	Осталось реализовать функцию работы машины $M(k, t)$ "--- возвращает конфигурацию, которая
	получится из $k$ через $t$ шагов.
	Она определяется примитивно рекурсивно: в $t=0$ это просто подстановка, а для больших нужно написать здоровенный \t{if} по текущему состоянию.
	Например, операция <<положить в стэк>> "--- это домножение на $m$ и сложние, <<достать из стэка>> "--- взятие остатка, сдвиг головки "--- перекладывание между стэками и текущим символом.
	Это пишется честно, но довольно неприятно.

	Теперь просто запускаем $\t{Result}(M(\t{Init}(x), g(x)))$ и получаем результат.
	Будем считать, что если машина Тьюринга завершила работу, то конфигурация просто перестаёт меняться, тогда нам не надо искать момент остановки ограниченной минимизацией.
\end{proof}

\subsection{Частично-рекурсивные функции}
\begin{Def}
	Пусть $f \colon M \to \N$, где $M \subseteq \N^k$.
	Тогда частично-рекурсивными $f$ считаем следующие:
	\begin{enumerate}
	\item Примитивно рекурсивные функции
	\item Все функции, которые можно получить из частично рекурсивных следующими операциями:
		\begin{enumerate}
		\item Подстановка
		\item Примитивная рекурсия
		\item Оператор минимизации: пусть есть частично рекурсивная функция $g(x_1, \dots, x_k)$,
			тогда частично рекурсивна
			\[ f(x_1, \dots, x_k) = \min \{ y \colon g(x_1, \dots, x_k, y) = 0 \} \]
			Обозначается так:
			\[ f(x) = \mu y \colon g(x, y) = 0 \]
			Иногда $f$ может получиться где-то неопределена, тогда мы возвращаем неопределённость $\bot$.
		\end{enumerate}
	\end{enumerate}
	Если один из параметров функции получается $\bot$, то она сразу возвращает $\bot$.
\end{Def}
\begin{Rem}
	Существенное отличие от примитивно рекурсивных функций "--- минимазиция без ограничений.
\end{Rem}
\begin{theorem}
	Частично рекурсивная функция вычислима на машине Тьюринга.
\end{theorem}
\begin{proof}
	Просто берём и по определению и тезису Чёрча вычисляем.
	Оператор минимизации "--- это цикл \t{while}, который, возможно, зацикливается в случае неопределённости.
\end{proof}

\begin{theorem}
	Функция $f$, вычислимая на машине Тьюринга, является частично рекурсивной.
\end{theorem}
\begin{proof}
	Рассмотрим предикат $S(x, y, t)$ "--- машина Тьюринга на входе $x$ останавливается за $\le t$ шагов и печатает $y$.
	По теореме \ref{primitiveRecursiveTuring} понятно, что $S$ примитивно рекурсивен (упражнение, просто делаем то же самое).
	Теперь минимизируем по $z$ (закодированная пара $z=[y, t]$):
	\[ f(x) = p_1(\mu z \colon \lnot S(x, p_1(z), p_2(z))) \]
	Напоминание: функция $p_1$ возвращает первый элемент пары.
	На самом деле нам неважно, что тут именно минимум "--- ответ от этого не поменяется.
	Отрицание нужно, потому что в определении минимизации мы искали корень, а не единицу.
\end{proof}
\begin{conseq}[Нормальная форма Клини]
	Если $f$ "--- частично рекурсивная функция, то существуют такие примитивно рекурсивные $a$ и $b$ такие, что:
	\[ f(x) = a(\mu z \colon b(x, z) = 0) \]
\end{conseq}
\begin{proof}
	Просто вычисляем $f$ на машине Тьюринга, а затем строим по доказательству теоремы требуемый вид.
\end{proof}

\begin{assertion}
	Перечислимое множество "--- проекция примитивно рекурсивного множества пар.
	Напоминание: множество пар примитивно рекурсивно, если оно имеет вид $\{(\alpha, \beta) \mid f(\alpha, \beta)=0\}$, где $f$ примитивно рекурсивна,
	а проекция "--- это просто множество первых элементов пар.
\end{assertion}
\begin{proof}
	$A$ перечислимо $\Ra$ $A$ "--- область определения некоторой вычислимой функции $f$
	(напоминание: берём полуразрешающий алгоритм, из него получаем функцию $f$).
	Представим $f$ в нормальной форме Клини (вычислимая $\iff$ частично рекурсивная):
	\[ f(x) = a(\mu z \colon b(x, z) = 0) \]
	Здесь $a$ и $b$ примитивно рекурсивны.
	Теперь рассмотрим множество $B=\{ (x,z) \mid b(x, z) = 0 \}$.
	Оно, очевидно, примитивно рекурсивно по построение.
	А проекция первого элемента этого множества "--- в точности те $x$, для которых существует некоторое $z$ такое, что $b(x, z)=0$,
	то есть в точности область определения $f(x)$.
\end{proof}
