\section{} % 1.13
Предтермы "--- переменные, аппликации, абстрации, в точности термы бестипового исчисления.
Утверждение о типизации: $M \colon \tau$.
Объявление "--- утверждение о типизации термовой переменной.
Контекст (базис, окружение), "--- мн-во объявлений различных переменных, контекст можно расширять,
добавляя новую переменную, еще можно смотреть на него как на частичную ф-цию $V \to \mathcal T$.
Утверждение $M\colon \tau$ выводимо в $\Gamma$ ($\Gamma \vdash M \colon \tau$), если можно вывести
по правилам: взять переменную из контекста, взять функцию и переменную из контекста, взять абстракцию по переменной из контекста.
Если есть $\Gamma$ и $\tau$ такие, что $M$ типизируется, то $M$ "--- допустимый терм.

\section{} % 1.14
Предтермы "--- переменные, аппликации, абстракции с указанием типа переменной.
Остальное такое же.
Только выводимость меняется: надо при взятии абстракции указывать её тип (причём этот тип вообще произвольный).

\section{} % 1.15
Тип "--- чисто синтаксическая конструкция $M \colon \sigma$,
дают частичную спецификацию, ловят простые ошибки.
Система Карри (неявная типизация): термы те же, но каждому можно приписать некоторое множество типов (пустое, конечное, бесконечное).
Система Чёрча (явная типизация): каждый тёрм аннотирован, каждый тип имеет уникальный тип, выводимый из аннотации.

Множество типов: переменные типа $\alpha$, $\beta$, \dots, стрелочные типы $(\sigma \to \tau) \in \mathcal T$
(берём начальные буквы для переменных, буквы из конца "--- для произвольных типов).
Ассоциативность: $\sigma_1 \to (\sigma_2 \to \sigma_3)$.
Типизация: переменные как угодно, аппликацию естественно, абстракцию как стрелочный.
Стиль Карри: не указываем в лямбдах тип, стиль Чёрча "--- указываем ($\lambda x \colon \alpha . x) \colon \alpha \to \alpha$).

Лемма об инверсии (лемма генерации): если в $\Gamma$ выводима переменная, аппликация или абстракция, то естественные <<предшественники>>
тоже выводимы (в абстракции в контекст добавляется тип, у Карри "--- под квантором, у Чёрча "--- берётся из терма).
Лемма о типизируемости подтерма: если $\Gamma \vdash M \colon \sigma$, то любой подтерм тоже типизируется в каком-то контексте.
Лемма разбавления: если $\Gamma \subseteq \Delta$ и $\Gamma \vdash M \colon \tau$, то из $\Delta$ тоже.
Лемма о свободных переменных: они должны лежать в контексте для типизации.
Лемма сужения: если выкинем всё, кроме свободных переменных, всё еще типизируем.
Предтерм $x\,x$ нетипизируем, так как типы "--- конечные строки.

В типах тоже можно делать подстановку.
Лемма подстановки типа: если $\Gamma \vdash M \colon \tau$, то можно одновременно заменить типовую переменную $\alpha$ на тип $\tau$ в контексте и в
утверждении, всё ок (для Чёрча надо еще в самом $M$ заменить).
Лемма подстановки тёрма: если подходящая по типу подстановка терма сохраняет тип.
Теорема о редукции субъекта: тип сохраняется при $\beta$-редукциях/

Тёрм в системе Чёрча имеет единственный тип (в частности, любые $\beta$-эквивалентные имеют одинаковый единственный тип).
А у Карри единственности типа нет (возможно добавление ненужных деталей в тип).

\section{} % 1.16
Из Чёрча легко отобразить в Карри: стираем типы.
Из Карри можно поднимать в Чёрча: надо подобрать какие-то типы для абстракций.
Типы обитаемы в обеих системах одновременно.
Задача проверки типа (соответствует ли терм ему), синтеза типа (построить тип по терму), обитаемости типа
(есть ли терм с типом), для Чёрча и Карри всё разрешимо.
ЗПТ выглядит проще ЗСТ, но в аппликации требует сгенерировать какой-нибудь тип для аргумента, поэтому эквивалентны.

Терм слабо нормализуем (WN), если есть последовательность редукций, приводящая к нормальной ($K\,I\,\Omega$).
Сильно нормализуем, если любая приводит к нормальной ($K\,I\,K$).
Система слабо (сильно) нормализуема если все допустимые термы слабо (сильно) нормализуемы.
Обе системы сильно нормализуемы.

\section{} % 1.17
В Карри: главный тип "--- остальные типы получаются из него типовой подстановкой.
Подстановка типа "--- операция $\mathcal T \to \mathcal T$, сохраняющаяя $S(\sigma \to \tau) = S(\sigma) \to S(\tau)$.
Обычно тождественна на всех переменных, кроме конечного носителя.
Тождественную обозначают [], выполняется параллельно (поэтому порядок переменных неважен).
Композиция "--- естественно (порядок важен!).
Образовали моноид с нейтральным [].
Унификатор для $\sigma$ и $\tau$ "--- такая $S$, что $S(\sigma)=S(\tau)$.
Он главный, если любой другой можно из него получить подстановкой.

\section{} % 1.18
Есть алгоритм унификации (ключевой момент: пилим уравнение по стрелке).
Если слева свободная переменная, то либо справа она же (ничего), либо терм и $\alpha \in FV(\tau)$ (ошибка),
либо терм и тогда замена $\alpha \eqcolon \tau$.
Если слева стрелка, а справа переменная, то замена.
Если две стрелки, то надо унифицировать правые концы, всё подставить, а только потом унифицировать левые концы (иначе будет беда).
Завершается, унифицирует, даёт главный унификатор.

\section{} % 1.19
Для любого терма $M$ и контекста $\Gamma$ (причём содержащего все свободные переменные) и типа $\sigma \in \mathcal T$
есть конечное множество уравнений на типы $E(\Gamma, M, \tau)$ (даёт $M$ тип $\tau$) такое, что:
$S \vDash E$ (подстановка унифицирует всю систему уравнений над типами) $\Ra$ $S(\Gamma)\vdash M \colon S(\tau)$;
и в обратную: если выводима типизация, то есть некая $S'$, удовлетворяющая системе, которая на типовых переменных ведёт себя как $S$.
Алгоритм построения: от переменной сказали $\tau \sim \Gamma(x)$, от аппликации "--- ввели свежую $\alpha$ и объединили систему,
для абстракции "--- ввели две свежие переменные, одну в контекст, другую "--- как цель, добавили уравнение $\tau \sim \alpha \to \beta$.

\section{} % 1.20
Главная пара для тёрма "--- такой контекст и тип, что в этом контексте терм имеет такой тип,
а также любую другую пару можно получить из главной некоторой подстановкой.
Теорема Хинди-Миллера "--- про существование алгоритма поиска такой пары (которые выдаёт ошибку тогда и только тогда, когда типа нет).
Алгоритм строит систему уравнений, потом запускает алгоритм унификации системы (систему из двух уравнений можно перевести в одно,
склеив стрелочкой), изначально он приписывает свободным переменным и всему терму различные типовые переменные.

Главный тип "--- тип замкнутого терма, причём любой другой получается из него некоторой подстановкой.
Следствие теоремы "--- есть алгоритм, который по замкнутому терму либо даёт главный тип, либо ошибку.

\section{} % 1.21
Типы можно обозначать за число (кол-во различных значений), тогда \t{bool=2}, потом можно складывать (алгебраические типы)
и умножать (декартово произведение), $y^x$ ($x -> y$), можно абстрагироваться по типу: $Maybe(x)=1+x$.
Список: $L(x)=1+xL(x)$, можно стандартно ввести комбинатор неподвижной точки и получить $L(x)=FIX(\lambda y. 1+xy)$,
это обозначают как $L(x)=\mu y.1+xy$.
Аналогично другие рекурсивные (деревья, натуральные числа).
Комбинатор неподвижной точки: \t{data Mu f = In (f (Mu f))}.

\section{} % 1.22
Сначала вводим копирование-пересборку типа: \t{copy (In x) = In \$ fmap copy x} (рекурсивно пересобирает тип).
Тип был \t{Mu f -> Mu f}, а можно делать пересборку во что-то другое: \t{cata :: Functor f => (f a -> a) -> Mu f -> a}.
Тогда \t{cata phi (In x) = phi \$ fmap (cata phi) x}, для данного функтора $f$ и типа $a$
функция $\phi$ называется F-алгебра.
Например, если редуцируем дерево в \t{Int}, то $\phi$ получит дерево, содержащее вместо детей \t{Int}'ы-результаты вычислений,
и выплюнет в ответ \t{Int}.
Пример: пересборка типа-чисел-Чёрча в натуральные, собственных списков в стандартные, длина собственных списков.

Анаморфизмы: вводим \t{out :: Mu f -> f (Mu f)} (например, как название поля в типе \t{Mu}), тогда в \t{copy} можно убрать
pattern matching аргумента.
Аналогично можно ввеста $f$-коалгебру, в которой меняется уже не сборка, а разборка (т.е. другой \t{out}):
\t{psi::a -> f a}, анаморфизм: \t{ana psi x = In \$ fmap (ana psi) (psi x)}.
Получили типа unfolding: был тип \t{a}, мы его развернули в \t{f a}, потом рекурсивно развернули детей и так далее.

\section{} % 1.23
Зиппер "--- модифицировали рекурсивную структуру, у неё появился фокус "--- текущий элемент, который можно быстро менять.
Также можно менять фокус на соседние (в каком-то смысле элементы).
Обычно зиппер "--- это подструктура плюс контекст.
Для списка "--- пара из головы (контекст) и хвоста (подструктура), для дерева контекст хитрый (надо пойти по родителям).

Можно вспомнить алгебраические типы, $L(x)=1+xL(x)=\frac{1}{1-x}$, можно продифференцировать, получим
$L'(x)=L^2(x)$, это же контекст с дыркой.
То есть это мы выкинули из структуры элемент в фокусе, осталось нечто, вот оно "--- контекст с дыркой.
Производная всегда даст алгебраический тип контекста с дыркой.
Для дерева хороший пример получается.
