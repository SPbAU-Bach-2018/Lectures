\section{} % 2.01
\t{=} "--- иммутабельное связывание (не присваивание), \t{foo = let z = x + y in print z}
(может задавать и функцию, и локальное связывание),
первый символ идентификатора маленький, в GHCI для глобального связывания "--- \t{let},
есть лямбды \t{\\y -> x + y}, ассоциативность как в лямбдах (иногда нужны скобки),
порядок объявления в файле неважен, Haskell ленив.
Guard'ы: \t{factorial n | n == 1 = 1} (смотрят сверху вниз до первого \t{true}).
Можно функции задавать в несколько строк с pattern matching.
Пример с факториалом: наивный и с хвостовой рекурсией (аккумулятор), можно использовать \t{where} и \t{let}
(первая может быть общая для всех guard'ов внутри одной строчки объявления).

\section{} % 2.02
Булы, символ юникода, \t{Int} фиксированного размера, \t{Integer} произвольного размера,
функции (\t{->}), кортежи, void \t{()}, список с элементами одного типа.
Можно писать \t{42::Integer} (а то тип полиморфен у констант).
Конструктор типа \t{Bool}, конструкторы данных "--- \t{True}, \t{False}, все с большой буквы.

Каррирование всегда есть: \t{mult 2} частично применена.
Параметрический полиморфизм: \t{k :: a -> b -> a} (могут входить не конкретные типы,
а переменные), должно работать для произвольных переменных типа.

Программа состоит из набора модулей, управляют пространством имён, есть списки экспорта/импорта:
\t{module A (foo, bar) where} (экспорт), \t{import B (f,g)} (импорт), конфликты можно разрешать
при помощи \t{import qualified} и пользоваться \t{B.f}.

\section{} % 2.03
Оператор "--- комбинация из нескольких спецсимволов, все бинарные и инфиксные (кроме унарного минуса,
его не переопределить).
\t{a +++ b = a + b} "--- нормальный стиль, \t{(+++) = +} "--- функциональный (префиксный) стиль,
да еще и бесточечный (какие-то последние аргументы опущены, всё через функции высших порядков).
Функции можно использовать/определять в инфиксном: \t{a `plus` b}.
Можно задавать приоритет и ассоциатвиность операторов: \t{infix}, \t{infixl}, \t{infixr}
(например, \t{infixl 6 +++} даст плюс).
Сечение "--- частичное применение оператора \t{(2+) == (+) 2} или \t{(+2)}, скобки обязательны.
Оператор \t{\$} "--- аппликация с наименьшим возможным приоритетом.

\section{} % 2.04
$\bot$ "--- это \t{undefined}, неявно лежит во всех типах,
возвращается при ошибках (но не исключениях).
Функция нестрога по параметру, если его игнорирует, иначе строга,
для строгих $f \bot = \bot$ (привет от ленивости).
Форсирование: \t{a `seq` b} сначала вычисляет $a$ (чтобы убедиться, что не $\bot$,
т.е. до WHNF), а потом возвращает $b$, нарушает ленивость.
Аналог seq: \t{const42 \$! undefined} тоже даёт \t{undefined}.
Полезно, чтобы форсировать вычисления (вычисления же кэшируются),
можно для факториала без аккумулятора использовать.

\section{} % 2.05
Pattern matching: берём конструктор данных, в значения "--- переменные.
Можно еще \t{case xs of (x:\_) -> \\n [] -> \\n}, можно использовать в лямбдах,
можно в \t{let} и в функциях.
Если параметр подошёл под конструктор, переменные свяжутся.
Сопоставление идёт сверху вниз, затем слева-направо, либо успехно, либо неуспешно,
расходимость (попытались сопоставить $\bot$ чему-то или же ни один паттерн не подошёл).
As-образец "--- сокращение вроде \t{s\@(x:xs)}, неопровержимы wildcards \t{\_},
ленивые образцы (вдруг нам аргумент не всегда нужен, и иногда устраивает undefined) вроде \t{~(x, y)}.

Перечисление "--- тип с нуль-арными конструкторами
Произведение "--- один бинарный конструктор данных.
Можно полиморфный тип: \t{data Point a = Pt a a} (kind типа будет \t{* -> * -> *})
Можно рекурсивные типы (список "--- либо пуст, либо голова плюс список), обработка
через рекурсию и pattern matching.
Еще бывают \t{Maybe} и \t{Either}.
Строгий конструктор данных: \t{data Complex a = !a :+ !a}, будет вычислять при создании объекта,
а не лениво ждать.
Bang pattern "--- то же самое в сопоставлении в образцах, но это расширение GHC.

\section{} % 2.06
\t{type} "--- как \t{typedef} в плюсах, просто синоним для быстрого набирания кода.
\t{newtype} "--- как \t{data}, единственный конструктор с единственным параметром,
но при этом в runtime дополнительной упаковки нет.
Метки полей (автоматические геттеры): \t{data Point a = Pt {ptx, pty :: a}},
получаем функции \t{ptx}, и \t{pty} бесплатно,
можно еще инициализировать в любом порядке: \t{Pt \{ptx=1, pty=2\}},
pattern matching всё еще везде работает,
можно обновлять значения: \t{myPt4 \{ptx=42\}}.

\section{} % 2.07
У списков есть конструкторы данных \t{[]} и \t{:}, есть сахар для \t{[1,2,3]},
есть функции из Data.List: \t{tail}, \t{take n}, \t{++}, \t{filter pred}, \t{map},
\t{length}.
Можно генерировать бесконечные списки: \t{let ones = 1:ones}, потому что всё лениво
и доступ только к первому элементу.
Есть сахар: \t{[1..10]}, \t{[2..]}, \t{['a'..'z']}.
Есть list comprehension: \t{[a*10+b | a <- [0..9], b <- [0..9]]}.

\section{} % 2.08
Параметрический полиморфизм "--- тип неважен, код одинаковый (\t{id x = x}),
специальный (ad hoc) "--- интерфейс общий, реализация специальная для каждого конкретного типа.
Класс типов "--- набор сигнатур функций, параметризованный общий типовым параметром (\t{class Eq a where}),
имя класса задаёт ограничение (<<контекст>>), можно указывать в сигнатуре функций.
Тип можно делать представителем: \t{instance Eq Integer where}, можно делать полиморфные следования
(\t{instance (Eq a) => Eq [a]}).
Есть методы по умолчанию, есть наследование (\t{class (Eq a, Show a) => MyClass a}), есть deriving
для стандартных классов (\t{deriving Show}).
Можно параметризовать класс кайндом не \t{*}, например \t{class Functor f where} (сам догадается, что \t{f: * -> *}).

В \t{Eq}: операторы \t{==} и {/=}, в \t{Ord} еще \t{max}, \t{min}, и четыре сравнения, можно добавить \t{sort} (ф-ция снаружи),
минимальное определение "--- \t{compare} (возвращает \t{EQ}/\t{LT}/\t{GT}) или \t{<=}.
D \t{Functor}: только \t{fmap :: (a -> b) -> f a -> f b}.

\section{} % 2.09
Словарь для класса "--- запись его методов (\t{MkEq (a -> a -> Bool) (a -> a -> Bool)}),
функции-селекторы могут выбирать из этой записи методы, объявления представителей трансформируются
либо в функции, возвращающие словарь (\t{dEqInt :: Eq Int}), либо в функции-трансформеры словарей (\t{dEqList :: Eq a -> Eq [a]}),
функции принимают словарь в качестве неявного параметра.

\section{} % 2.10
\t{Enum}: можно брать следующий, предыдущий, конвертировать в/из \t{Int}, брать отрезки (enumFrom, FromTo, FromThen с указанием <<шага>>
в виде промежуточного элемента, FromThenTo), минимум "--- \t{toEnum}, \t{fromEnum}.
\t{Bounded}: \t{minBound}, \t{maxBound}.
\t{class (Eq a, Show a) => Num a where}: \t{+}, \t{-}, \t{*}, \t{negate}, \t{abs}, \t{signum}, \t{fromInteger},
есть правила для связи \t{-} и \t{negate}; \t{negate} и 0; контекст \t{Ord} не нужен для комплексных.

Подклассы \t{Num}: \t{Integral} (целочисленное деление, представители "--- \t{Int}, \t{Integer}) и \t{Fractional}
(обычное деление, представители \t{Float} и \t{Double}), автоматического приведения типов нет,
надо \t{fromIntegral :: Integral -> Num} и \t{ceiling}, \t{floor}, \t{truncate}, \t{round} в обратную.
Есть рациональные дроби \t{Ratio a} и \t{Rational} (с \t{Integer}), можно \t{toRational} и \t{5 \% 2},
можно \t{approxRational 4.9 0.1} (для точности).

\section{} % 2.11
\t{foldr f ini = f x (foldr f ini xs)} (повторяет структуру списка), св-во универсальности (система уравнений на $g$, 
\t{foldr} "--- единственное решение, д-во по индукции).
\t{foldl} "--- свёртка как бы циклом \t{for}, хвостовая рекурсия, но невычисленный хвост нарастает, можно добавить \t{seq},
теперь эффективно, но все левые свёртки не умеют работать с бесконечными списками.
Непустые списки можно сворачивать без начального значения.

Сканы (\t{scanl}) "--- список последовательных шагов свёртки, для левых можно бесконечные списки.
Есть тождества между последним/первым элементом сканов и свёртками.
Еще есть \t{unfoldr :: (b -> Maybe (a, b)) -> b -> [a]}, генерирует список, пока не \t{Nothing}.
