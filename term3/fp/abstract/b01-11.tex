\section{} % 2.01
\t{=} "--- иммутабельное связывание (не присваивание), \t{foo = let z = x + y in print z}
(может задавать и функцию, и локальное связывание),
первый символ идентификатора маленький, в GHCI для глобального связывания "--- \t{let},
есть лямбды \t{\\y -> x + y}, ассоциативность как в лямбдах (иногда нужны скобки),
порядок объявления в файле неважен, Haskell ленив.
Guard'ы: \t{factorial n | n == 1 = 1} (смотрят сверху вниз до первого \t{true}).
Можно функции задавать в несколько строк с pattern matching.
Пример с факториалом: наивный и с хвостовой рекурсией (аккумулятор), можно использовать \t{where} и \t{let}
(первая может быть общая для всех guard'ов внутри одной строчки объявления).

\section{} % 2.02
Булы, символ юникода, \t{Int} фиксированного размера, \t{Integer} произвольного размера,
функции (\t{->}), кортежи, void \t{()}, список с элементами одного типа.
Можно писать \t{42::Integer} (а то тип полиморфен у констант).
Конструктор типа \t{Bool}, конструкторы данных "--- \t{True}, \t{False}, все с большой буквы.

Каррирование всегда есть: \t{mult 2} частично применена.
Параметрический полиморфизм: \t{k :: a -> b -> a} (могут входить не конкретные типы,
а переменные), должно работать для произвольных переменных типа.

Программа состоит из набора модулей, управляют пространством имён, есть списки экспорта/импорта:
\t{module A (foo, bar) where} (экспорт), \t{import B (f,g)} (импорт), конфликты можно разрешать
при помощи \t{import qualified} и пользоваться \t{B.f}.

\section{} % 2.03
Оператор "--- комбинация из нескольких спецсимволов, все бинарные и инфиксные (кроме унарного минуса,
его не переопределить).
\t{a +++ b = a + b} "--- нормальный стиль, \t{(+++) = +} "--- функциональный (префиксный) стиль,
да еще и бесточечный (какие-то последние аргументы опущены, всё через функции высших порядков).
Функции можно использовать/определять в инфиксном: \t{a `plus` b}.
Можно задавать приоритет и ассоциатвиность операторов: \t{infix}, \t{infixl}, \t{infixr}
(например, \t{infixl 6 +++} даст плюс).
Сечение "--- частичное применение оператора \t{(2+) == (+) 2} или \t{(+2)}, скобки обязательны.
Оператор \t{\$} "--- аппликация с наименьшим возможным приоритетом.

\section{} % 2.04
$\bot$ "--- это \t{undefined}, неявно лежит во всех типах,
возвращается при ошибках (но не исключениях).
Функция нестрога по параметру, если его игнорирует, иначе строга,
для строгих $f \bot = \bot$ (привет от ленивости).
Форсирование: \t{a `seq` b} сначала вычисляет $a$ (чтобы убедиться, что не $\bot$,
т.е. до WHNF), а потом возвращает $b$, нарушает ленивость.
Аналог seq: \t{const42 \$! undefined} тоже даёт \t{undefined}.
Полезно, чтобы форсировать вычисления (вычисления же кэшируются),
можно для факториала без аккумулятора использовать.

\section{} % 2.05
Pattern matching: берём конструктор данных, в значения "--- переменные.
Можно еще \t{case xs of (x:\_) -> \\n [] -> \\n}, можно использовать в лямбдах,
можно в \t{let} и в функциях.
Если параметр подошёл под конструктор, переменные свяжутся.
Сопоставление идёт сверху вниз, затем слева-направо, либо успехно, либо неуспешно,
расходимость (попытались сопоставить $\bot$ чему-то или же ни один паттерн не подошёл).
As-образец "--- сокращение вроде \t{s\@(x:xs)}, неопровержимы wildcards \t{\_},
ленивые образцы (вдруг нам аргумент не всегда нужен, и иногда устраивает undefined) вроде \t{~(x, y)}.

Перечисление "--- тип с нуль-арными конструкторами
Произведение "--- один бинарный конструктор данных.
Можно полиморфный тип: \t{data Point a = Pt a a} (kind типа будет \t{* -> * -> *})
Можно рекурсивные типы (список "--- либо пуст, либо голова плюс список), обработка
через рекурсию и pattern matching.
Еще бывают \t{Maybe} и \t{Either}.
Строгий конструктор данных: \t{data Complex a = !a :+ !a}, будет вычислять при создании объекта,
а не лениво ждать.
Bang pattern "--- то же самое в сопоставлении в образцах, но это расширение GHC.

\section{} % 2.06
\t{type} "--- как \t{typedef} в плюсах, просто синоним для быстрого набирания кода.
\t{newtype} "--- как \t{data}, единственный конструктор с единственным параметром,
но при этом в runtime дополнительной упаковки нет.
Метки полей (автоматические геттеры): \t{data Point a = Pt {ptx, pty :: a}},
получаем функции \t{ptx}, и \t{pty} бесплатно,
можно еще инициализировать в любом порядке: \t{Pt \{ptx=1, pty=2\}},
pattern matching всё еще везде работает,
можно обновлять значения: \t{myPt4 \{ptx=42\}}.

\section{} % 2.07
У списков есть конструкторы данных \t{[]} и \t{:}, есть сахар для \t{[1,2,3]},
есть функции из Data.List: \t{tail}, \t{take n}, \t{++}, \t{filter pred}, \t{map},
\t{length}.
Можно генерировать бесконечные списки: \t{let ones = 1:ones}, потому что всё лениво
и доступ только к первому элементу.
Есть сахар: \t{[1..10]}, \t{[2..]}, \t{['a'..'z']}.
Есть list comprehension: \t{[a*10+b | a <- [0..9], b <- [0..9]]}.

\section{} % 2.08

\section{} % 2.09

\section{} % 2.10

\section{} % 2.11
