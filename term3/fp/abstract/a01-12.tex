\section{} % 1.01
Императивное: есть последовательные инструкции, меняющие состояния вычислителя
(есть переменные, им можно присваивать значения), есть ветвления и циклы, это
стиль фон Неймана.
Вычислитель переходит из начального состояния в конечное.

Функциональное: программа "--- выражение, выполнение "--- вычисление выражения (редуцирование),
нет переменных, присваивания, циклов, чёткой последовательности нет (на усмотрение языка; разве что зависимости
от аргументов, но помним про ленивость), есть рекурсия вместо циклов и функции высших порядков
(типа \t{map}, \t{foldr}).

ФП: более точная семантика (инварианты), больше свободы для компилятора (+параллелизм), плотнее код,
модульность, бесконечные структуры данных (от ленивости), но не соответствует архитектуре компов
(поэтому тормозит побольше), ввод-вывод "--- нечистые, нужно хитрить.

\section{} % 1.02
В $\lambda$-исчислении термы строятся рекурсивно над мн-вом переменных $V$:
либо просто переменная, либо аппликация термов $(M\, N)$, либо абстракция: $(\lambda x . M)$ если $x \in V$,
можно в бестиповом применять всё ко всему подряд.
Переменные "--- строчные, термы "--- большие буквы.
Внешние скобки опускаются, аппликация ассоциативна влево ($F\,X\,Y=(F\,X)\,Y$),
лямбды "--- вправо (тоже опускаются) и простираются до упора
($\lambda x\, y . x\, y = \lambda x . (\lambda y . (x\, y))$).

Свободные переменные $FV(T)$ "--- ни разу не связаные (определяем индуктивно),
связанные $BV(T)$ "--- связанные хотя бы один раз ($\lambda x . \lambda x . x$ "--- это ок,
внутри действует последний $x$).
Тёрм замкнут (является комбинатором) $\iff$ $FV(T)=\varnothing$, их мн-во обозначают $\Lambda^0$.

$I=\lambda x.x$, $\omega = \lambda x.x\, x$, $\Omega = \omega \omega$, $K$ и $K_*$ возвращают первый/второй аргумент,
$S=\lambda f\,g\,x.f\,x\,(g\,x)$, $B=\lambda f\,g\,x.f\,(g\,x)$ (композиция).
Каррирование: переход от ф-ции нескольких аргументов к функции, принимающей по одному;
если есть тёрм $f(x, y)$, то можно ввести $\Phi=\lambda x . (\lambda y . f(x, y))$,
тогда $\Phi\, X\, Y = f(X, Y)$.

\TODO

\section{} % 1.03
$M[x \coloneq N]$ "--- подставили $N$ вместо свободных вхождений $x$,
определяется рекурсивно (на двух типах переменных, на аппликации, на двух типах лямбд).
Есть проблема с захватом: $(\lambda y. x\, y)[x \coloneq y]$, тогда есть соглашение
Барендрегта: имена связных выбираем так, чтобы они всегда отличались от имён свободных,
проблем не будет.

Лемма подстановки: если $M, N, L \in \Lambda$, есть разные переменные $x \notin FV(L)$, $y$.
Тогда если подставить в $M$ сначала $x\eqcolon N$, а потом $y \eqcolon L$, то это
то же самое, что сначала подставить $y \eqcolon L$, а потом $x\eqcolon N[y\eqcolon L]$.
Нудная индукция.

\TODO

\section{} % 1.04
$\beta$-эквивалентность: при применении лямбды к чему угодно можно подставить параметр:
$(\lambda x . M)N =_\beta M[x\eqcolon N]$.
$\alpha$-экивалентность: переименовали какие-то связные переменные (осторожно с захватом!).
Термы $X=_\alpha Y$ ведут себя одинаково при редуцировании лямбд.

\TODO

\section{} % 1.05
Можно добавить константы из мн-ва $\C$ (например, \t{tru}, \t{fls}, \t{not}, \t{and}, \t{or}),
функции "--- тоже константы в смысле <<константный терм>>,
надо дополнительные правила работы этих термов, добавляются новые аксиомы ($\t{not}\,\t{tru}=_\delta \t{fls}$).
В общем случае мы добавляем правило такого вида: взяли свободную константу-обозначение,
ввели правило $\delta_f\,M_1\,\dots\,M_k =_\delta f(M_1, \dots, M_k)$.
По-хорошему еще стоит доказывать, что теорема Чёрча-Россера выполняется.

\TODO

\section{} % 1.06
$\t{tru} = \lambda\,t\,f.t$, $\t{fls} = \lambda\,t\,f.f$,
\t{if} "--- просто аппликация булева к двум выражениям.
Надо проверить св-ва \t{if} и логических операций.
Конструктор пары: $\t{pair} = \lambda x\,y\,f.f\,x\,y$, $\t{fst}=\lambda p.p \t{tru}$.
Надо проверить свойства композиции конструктора и \t{fst}/\t{snd}.

\section{} % 1.07
Числа Чёрча (неотрицательные целые): $3\equiv \lambda s\,z.s\,(s\,(s\,z))$ (последовательная аппликация,
типа свёртки $n$ раз).
$\t{iszro}=\lambda n . n\,(\lambda x.\t{fls})\,\t{tru}$ (ноль раз свернули "--- \t{tru}, больше "--- \t{fls}).
Можно ввести \t{succ} по определению, потом плюс, умножение (плюс "--- сначала применить параметр $n$
раз, потом еще $m$ раз).

\section{} % 1.08
Для любого $F \in \Lambda$ есть тёрм $X \in \Lambda$, причём $F\, X = X$.
Введём $W=\lambda x . F\,(x\,x)$ и $X=W\,W$, раскроем первую $W$, подойдёт.
Также есть комбинатор $Y$ такой, что $F\,(Y\,F)=F$.
Возьмём тот же $W[F]$ и скажем $Y = \lambda f . W[f] W[f]$, док-во аналогично.

Решаем рекурсивные уравнения: $\t{fac} = n \cdot \t{fac}\,(n-1)$,
в правой части обозначаем функцию за $f$, делаем по ней абстракцию ($\t{fac} = \t{fac'} \t{fac}$,
применяем $Y$-комбинатор к \t{fac'}, получили \t{fac}.

\section{} % 1.09
Терм $(\lambda x . M)\, N$ есть $\beta$-редекс,	а $M[x \eqcolon N]$ "--- его сокращение.
Вводим понятие редукции: бинарное отношение (типа эквивалентность) $R$ называем совместимым
(а отношение "--- конгруентностью), если
можно не нарушая его дописывать к <<одинаковым>> аппликацию слева-справа и абстрагировать по одинаковой переменной.
Если конгруентность рефлексивна, транзитивна (необязательно симметрична), то это редукция.
$\beta$-редукция за один шаг "--- конгруентность (рекурсивно: редексы входят, можно лезть внутрь лямбды,
можно лезть в одну из сторон аппликации), проверить св-ва.
Если замкнуть по рефлексивности и транзитивности, то получаем отношение редукции (многошаговая $\beta$-редукция),
\TODO

\section{} % 1.10

\section{} % 1.11

\section{} % 1.12
