\section{} % 1.01
Императивное: есть последовательные инструкции, меняющие состояния вычислителя
(есть переменные, им можно присваивать значения), есть ветвления и циклы, это
стиль фон Неймана.
Вычислитель переходит из начального состояния в конечное.

Функциональное: программа "--- выражение, выполнение "--- вычисление выражения (редуцирование),
нет переменных, присваивания, циклов, чёткой последовательности нет (на усмотрение языка; разве что зависимости
от аргументов, но помним про ленивость), есть рекурсия вместо циклов и функции высших порядков
(типа \t{map}, \t{foldr}).

ФП: более точная семантика (инварианты), больше свободы для компилятора (+параллелизм), плотнее код,
модульность, бесконечные структуры данных (от ленивости), но не соответствует архитектуре компов
(поэтому тормозит побольше), ввод-вывод "--- нечистые, нужно хитрить.

\section{} % 1.02
В $\lambda$-исчислении термы строятся рекурсивно над мн-вом переменных $V$:
либо просто переменная, либо аппликация термов $(M\, N)$, либо абстракция: $(\lambda x . M)$ если $x \in V$,
можно в бестиповом применять всё ко всему подряд.
Переменные "--- строчные, термы "--- большие буквы.
Внешние скобки опускаются, аппликация ассоциативна влево ($F\,X\,Y=(F\,X)\,Y$),
лямбды "--- вправо (тоже опускаются) и простираются до упора
($\lambda x\, y . x\, y = \lambda x . (\lambda y . (x\, y))$).

Свободные переменные $FV(T)$ "--- ни разу не связаные (определяем индуктивно),
связанные $BV(T)$ "--- связанные хотя бы один раз ($\lambda x . \lambda x . x$ "--- это ок,
внутри действует последний $x$).
Тёрм замкнут (является комбинатором) $\iff$ $FV(T)=\varnothing$, их мн-во обозначают $\Lambda^0$.

$I=\lambda x.x$, $\omega = \lambda x.x\, x$, $\Omega = \omega \omega$, $K$ и $K_*$ возвращают первый/второй аргумент,
$S=\lambda f\,g\,x.f\,x\,(g\,x)$, $B=\lambda f\,g\,x.f\,(g\,x)$ (композиция).
Каррирование: переход от ф-ции нескольких аргументов к функции, принимающей по одному;
если есть тёрм $f(x, y)$, то можно ввести $\Phi=\lambda x . (\lambda y . f(x, y))$,
тогда $\Phi\, X\, Y = f(X, Y)$.

\section{} % 1.03
$M[x \eqcolon N]$ "--- подставили $N$ вместо свободных вхождений $x$,
определяется рекурсивно (на двух типах переменных, на аппликации, на двух типах лямбд).
Есть проблема с захватом: $(\lambda y. x\, y)[x \eqcolon y]$, тогда есть соглашение
Барендрегта: имена связных выбираем так, чтобы они всегда отличались от имён свободных,
проблем не будет.

Лемма подстановки: если $M, N, L \in \Lambda$, есть разные переменные $x \notin FV(L)$, $y$.
Тогда если подставить в $M$ сначала $x\eqcolon N$, а потом $y \eqcolon L$, то это
то же самое, что сначала подставить $y \eqcolon L$, а потом $x\eqcolon N[y\eqcolon L]$.
Нудная индукция.

\section{} % 1.04
$\beta$-эквивалентность: при применении лямбды к чему угодно можно подставить параметр:
$(\lambda x . M)N =_\beta M[x\eqcolon N]$.
$\alpha$-экивалентность: переименовали какие-то связные переменные (осторожно с захватом!).
Термы $X=_\alpha Y$ ведут себя одинаково при редуцировании лямбд.

Аксиомы для $\beta$-преобразований: рефлексивность, транзитивность, можно лезть в любой один
параметр аппликации и внутрь абстракции по переменной с одинаковыми именами (правило $\xi$),
если $M=N$ доказуемо, то пишут $\lambda \vdash M = N$.
Можно добавить аксиомы для $\alpha$-преобразования (проверить, что не будет захвата),
можно для $\eta$-преобразования ($\lambda x . M\, x = M$, если $x \notin FV(M)$.
Индексы Де Брауна (который De Bruijn): связные переменные не именуем, а говорим, сколько лямбд
назад переменная была связана, теперь коллизий нет вообще.

$\eta$-преобразование есть экстенсиональная эквивалентность: две функции одинаковы, если ведут
себя везде одинаково.
Бесточечный стиль записи на этом основан: если $F\, y = G\, y$, то сделав $\xi$ (приписали $\lambda y .$) и $\eta$,
получаем $F=G$.

\section{} % 1.05
Можно добавить константы из мн-ва $\C$ (например, \t{tru}, \t{fls}, \t{not}, \t{and}, \t{or}),
функции "--- тоже константы в смысле <<константный терм>>,
надо дополнительные правила работы этих термов, добавляются новые аксиомы ($\t{not}\,\t{tru}=_\delta \t{fls}$).
В общем случае мы добавляем правило такого вида: взяли свободную константу-обозначение,
ввели правило $\delta_f\,M_1\,\dots\,M_k =_\delta f(M_1, \dots, M_k)$.
По-хорошему еще стоит доказывать, что теорема Чёрча-Россера выполняется.

\section{} % 1.06
$\t{tru} = \lambda\,t\,f.t$, $\t{fls} = \lambda\,t\,f.f$,
\t{if} "--- просто аппликация булева к двум выражениям.
Надо проверить св-ва \t{if} и логических операций.
Конструктор пары: $\t{pair} = \lambda x\,y\,f.f\,x\,y$, $\t{fst}=\lambda p.p \t{tru}$.
Надо проверить свойства композиции конструктора и \t{fst}/\t{snd}.

\section{} % 1.07
Числа Чёрча (неотрицательные целые): $3\equiv \lambda s\,z.s\,(s\,(s\,z))$ (последовательная аппликация,
типа свёртки $n$ раз).
$\t{iszro}=\lambda n . n\,(\lambda x.\t{fls})\,\t{tru}$ (ноль раз свернули "--- \t{tru}, больше "--- \t{fls}).
Можно ввести \t{succ} по определению, потом плюс, умножение (плюс "--- сначала применить параметр $n$
раз, потом еще $m$ раз).

\section{} % 1.08
Для любого $F \in \Lambda$ есть тёрм $X \in \Lambda$, причём $F\, X = X$.
Введём $W=\lambda x . F\,(x\,x)$ и $X=W\,W$, раскроем первую $W$, подойдёт.
Также есть комбинатор $Y$ такой, что $F\,(Y\,F)=F$.
Возьмём тот же $W[F]$ и скажем $Y = \lambda f . W[f] W[f]$, док-во аналогично.

Решаем рекурсивные уравнения: $\t{fac} = n \cdot \t{fac}\,(n-1)$,
в правой части обозначаем функцию за $f$, делаем по ней абстракцию ($\t{fac} = \t{fac'}\,\t{fac}$,
применяем $Y$-комбинатор к \t{fac'}, получили \t{fac}.

\section{} % 1.09
Терм $(\lambda x . M)\, N$ есть $\beta$-редекс,	а $M[x \eqcolon N]$ "--- его сокращение.
Вводим понятие редукции: бинарное отношение (типа эквивалентность) $R$ называем совместимым
(а отношение "--- конгруентностью), если
можно не нарушая его дописывать к <<одинаковым>> аппликацию слева-справа и абстрагировать по одинаковой переменной.
Если конгруентность рефлексивна, транзитивна (необязательно симметрична), то это редукция.
$\beta$-редукция за один шаг "--- конгруентность (рекурсивно: редексы входят, можно лезть внутрь лямбды,
можно лезть в одну из сторон аппликации), проверить св-ва.
Если замкнуть по рефлексивности и транзитивности, то получаем отношение редукции (многошаговая $\beta$-редукция),

Два терма связаны отношением $=_\beta$, если связаны по неориентированным стрелочкам $\to_\beta$.
Терм находится в нормальной $\beta$-форме, если в нём нет редексов-подтермов.
Имеет нормальную $\beta$-форму, если есть эквивалентный ему в нормальной.
$\Omega$ не имеет нормальной формы (надо доказывать, см. позже).
Можно построить редукционный граф, не все конечны, не все бесконечные не имеют нормальной формы.

\section{} % 1.10
Теорема Чёрча-Россера: если $M$ можно средуцировать и в $N$, и в $K$, то их обоих можно доредуцировать
до общего $L$ (это называется конфлюентность).
Теорема: если $M=_\beta N$, то их обоих можно средуцировать в некий $L$,
индукция по генерации $=_\beta$ (либо один следует из другого, либо по транзитивности,
а тогда надо взять общий для промежуточных).
Тогда если $M$ имеет $N$ в качестве нормальной формы, то к нему редуцируется, отсюда
$\Omega$ не имеет нормальной формы (редуцируется только само к себе),
также есть не более одной нормальной формы.

\section{} % 1.11
Разбираем аппликацию до неаппликации (по максимуму влево), если получили
не лямбду слева, то редуцируем все параметры слева направо,
иначе два варианта: в нормальной стратегии сокращаем первый редекс и циклимся,
в аппликативной стратегии сокращаем все аргументы слева направо и только потом первый редекс.
Головная нормальная форма (HNF) "--- залезли до первой абстракции налево, если левый аргумент "--- не лямбда, то HNF (тогда
это переменная, называется головная переменная).
Слабая головная нормальная форма (WHNF) "--- не редекс на верхнем уровне, т.е. либо лямбда, либо HNF (тогда там внутрь не полезем).
Головной редекс "--- самый левый.

Синтаксические конструкции: NF (нормальные формы), NANF (нормальные формы не абстракции), NA (не абстракции),
задаются рекурсивно друг через друга.
Стратегии характеризуются поведением на этих формах (и их комбинациях), операционная семантика.
Вроде $\frac{NA \to NA'}{NA\, N \to NA'\, N}$, аналогичное правило для правого аргумента аппликации (левый д.б. NANF),
для редекса, для залезания внутрь лямбды.
Нормальная всегда сокращает самый левый внешний редекс,
аппликативная "--- самый левый внутренний (то есть может сократить редекс, только если правый аргумент в NF).

Теорема о нормализации: если есть нормальная форма, то нормальная стратегия гарантированно нормализует.
Она возможно неэффективна (считает одно и то же много раз, но можно кэшировать), но не считает лишнее.
Аппликативная $\sim$ <<энергичная>>, как во всех языках.
Часто доводят редукцию не до NF, а до WHNF (потому что зачем лезть внутрь лямбды "--- вдруг параметр не придёт),
еще можно даже не лезть в частично применённые встроенные функции.
А еще почему-то вычисление до WHNF позволяет избежать захвата переменной, ничего переименовывать не надо.

Механизм вызова: <<вызов по значению>> "--- аппликативная стратегия, <<вызов по имени>> "--- нормальная стратегия,
<<вызов по необходимости>> "--- нормальная плюс вычисляем сложные термы только один раз.

\section{} % 1.12
Взяли пары, взяли функцию $(a, b) \to (b, b+1)$, а теперь $-1$ для чисел Чёрча очевиден (за линию).
Примитивная рекурсия: \t{rec m f x} "--- храним в паре текущее значение и номер итерации,
запускаем $f$, стартуя с $x$, делаем $m$ итераций.
Можно считать факториал, сумму чисел $1\dots n$, частичные суммы ряда $\sum h(k)$.
