\section{} % 2.12
\t{Functor} "--- контейнер, в нём есть \t{fmap} (он же \t{<\$>}), выводятся \t{(<\$)} (заменить всё на константу) и флипнутый
\t{(\$>)}, а также \t{void} (меняет всё на void).
Представители: списки, \t{Either e}, \t{(,) s}, \t{(->) e} (с композицией).
Не меняет структуру (законы: \t{fmap id} и композиция).
\t{Pointed} (в Haskell нет, надо явно писать) "--- добавили \t{pure} (вложили элемент в контейнер), закон: \t{fmap g . pure = pure . g}.

\t{Applicative} "--- от \t{Pointed}, добавился \t{<*>}, применяющий функции из левого аргумента к аргументам из правого.
Пример: \t{Maybe}.
Законы: \t{fmap g xs = pure g <*> xs}; \t{pure id}, композиция ф-ций внутри контейнера и поочерёдное применение;
\t{pure} к функции и к элементу; \t{pure (\$ x) <*> g}.
Списки как аппликативы: либо <<все со всеми>> (по умолчанию), либо делаем \t{ZipList} (у него надо, чтобы \t{pure} возвращал бесконечный список)/
Пара как аппликатив ок, если первый элемент "--- моноид.
В аппликативах еще есть \t{liftA2 :: (a -> b -> c) -> f a -> f b -> f c}, и \t{liftA3}.

\section{} % 2.13
Есть нейтральный \t{mempty}, есть ассоциативная операция \t{mappend} (два св-ва).
Можно выразить \t{mconcat} через свёртку, целые числа "--- моноид и по сложению,
и по умножению (создаём \t{newtype Sum a = Sum \{ getSum :: a\}} и выбираем),
можно взять bool по конъюнкции/дизъюнкции.

\section{} % 2.14
Foldable (минимальное определение либо \t{foldMap}, либо \t{foldr}), есть две свёртки и симметричные
\t{foldMap} и \t{fold}, работающие с результатом-моноидом.
Traversable "--- Functor и Foldable, есть \t{sequenceA :: Applicative f => t (f a) -> f (t a)} и \t{traverse g = sequenceA . fmap g} (друг через друга выражаются).
\t{sequenceA} обходит Traversable и вытаскивает наружу аппликатив (было дерево, а в каждом элементе "--- \t{ZipList} длина 3, стал один \t{ZipList} из трёх деревьев с числами).
Представители: \t{Maybe}, списки, реализация похожа на Functor, только добавились \t{pure}, \t{<\$>} и \t{<*>} между вызовами.

\section{} % 2.15
Монады: либо хранят состояние, либо несколько результатов вычисления, либо что-то еще.
Извлекать значения нельзя.
В теории был бы \t{Pointed} плюс \t{join}, но в реальности есть \t{return} (\t{pure}),
есть \t{>>= : m a -> (a -> m b) -> m b} (bind), есть \t{fail :: String -> m a} (по умолчанию кидает exception).
Есть \t{>>} (\t{>>=}, игнорирующий текущий результат), приоритеты у всех маленькие.
Законы: \t{return a >>= k $\equiv$ k a}, \t{m >>= return $\equiv$ m} (тривиальность \t{return}), \t{(m >>= k) >>= k' $\equiv$ m >>= (\\x -> k x >>= k')}
(ассоциативность эффектов монады).

do-нотация: \t{do \{e1; e2\}} $\iff$ \t{e1 >> e2}; \t{do \{p<-e1; e2\}} $\iff$ \t{e1 >>= \\p -> e2} (если не сопоставилось "--- вызывается \t{fail}); \t{do \{let v = e1; e2\}} $\iff$ обычный \t{let}.
Монада может менять ход вычислений и свою структуру по ходу дела, аппликатив не может (пример: все пары $1 \le a \le b \le 3$ в do).

\section{} % 2.16
\t{Maybe} "--- либо результат, либо ошибка в любой момент вычислений.
Список "--- как аппликатив, пример с \t{True <- return (x /= y)}.

\section{} % 2.17
\t{newtype IO a = IO (RealWorld -> (RealWorld, a))} (почти так), всё очень магическое,
гарантии: побочные эффекты происходят ровно один раз и в заданном порядке.
Есть \t{getChar}, \t{getLine}, \t{getContents}, \t{putChar}, \t{putStr}, \t{putStrLn}, \t{print a},
\t{interact :: (String -> String) -> IO ()}.
Есть шаблон свёртки: \t{sequence\_ :: [m a] -> m() = foldr (>>) (return ())} (можно заставить считать конечное значение).
Есть \t{mapM f = sequence . map f}.
Через них можно выразить всякие \t{putStr}.

Файлы: \t{openFile :: FilePath -> IOMode -> IO Handle} (строка, \t{WriteMode}),
потом можно \t{hPutChar :: Handle -> Char -> IO ()} (а также \t{Str}, \t{StrLn}, \t{hPrint}),
также \t{hGetContents}, \t{hClose} (осторожно с ленивостью, а то прочитает после закрытия файла, надо \t{seq}),
лучше использовать \t{withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r}.

\section{} % 2.18
\t{Reader = Monad ((->) r)}, можно читать из некоторого окружения, \t{>>=} сначала выполняет первое, потом передаёт окружение во второе.
\t{newtype Reader r a = Reader \{runReader :: (r -> a)\}}, т.е. сначала накапливаем хвост из вычислений, а уже потом
делаем \t{runReader env}.
Функция \t{ask :: Reader r r} возвращает окружение, \t{asks :: (r -> a) -> Reader r a} запускает над ним чистую функцию,
\t{local :: (r -> r) -> Reader r a -> Reader r a} модифицирует окружение локально (меняет первым, запускает второй аргумент, подсовывает
результат в конец, окружение глобально не меняет).

\t{newtype Writer w a = Writer \{runWriter :: (a, w)\}}, если есть \t{Monoid w}, то есть instance (как будто пишем в лог $w$).
Есть функция \t{tell :: w -> Writer w ()} (пишет в лог), можно подслушивать промежуточные вычисления при помощи
\t{listen :: Writer w a -> Writer w (a, w)} или \t{listens :: (w -> b) -> Writer w a -> Write w (a, b)} (добился map $w \to b$).
Можно модифицировать лог \t{censor :: (w -> w) -> Writer w a -> Writer w a}.

\section{} % 2.19
\t{newtype State s a = State \{runState::s->(a,s)\}}, можно \t{execState} для получения конечного состояния,
можно \t{evalState} для получения конечного значения.
Есть \t{get::State s s}, \t{put::s -> State s()}, \t{modify::(s->s)->State s ()} и \t{gets} (get + map).
Есть \t{replicateM n = sequence . replicate n} (повторить $n$ раз монаду).
Есть монада \t{ST} для реально изменяемого состояния, там есть \t{STRef} (локальный, с хитрой гарантией), \t{IORef} (без локальности и безопасности),
их можно создавать и менять.

\section{} % 2.20
\t{Alternative} "--- наследник \t{Applicative}, моноид над ними, удобен для парсеров (либо попарсить так, либо сяк).
Умеет \t{empty}, \t{<|>}.
Смысл "--- для \t{Maybe} вернуть первое успешное вычисление.
\t{some v :: f a -> f[a]} (добавляет $v$ в начало к каждому из элементов от \t{many}),
\t{many} "--- \t{some <|> pure []} (либо хотя бы один элемент, либо ничего).

\t{MonadPlus} "--- наследник \t{Monad}, есть \t{mzero} и \t{mplus}, аналогично \t{Alternative}.
Также нужны законы (альтернативу, кстати, тоже): \t{mzero >>= k = mzero}, и одно из двух:
\t{(a `mplus` b) >>= k = (a >>= k) `mplus` (b >>= k)} или \t{(return a) `mplus` b = return a}.
Использовать можно, чтобы ставить guard'ов в do-нотации "--- если надо оборваться, просто возвращаем \t{mempty}.

\section{} % 2.21
Есть мультипараметрические классы, есть функциональные зависимости (говорим, что если есть два параметра, то один однозначно
должен определяться из другого, а то иначе сам не догадается и будет пытаться вывести обоих из контекста).
Определяем \t{class Error e} с \t{noMsg::e} и \t{strMsg::String->e}.
Определяем \t{MonadError e m} с \t{throwError e -> m a} и \t{catchError m a -> (e -> m a) -> m a},
главный представитель "--- \t{Either e}, использование "--- \t{do \{action\} `catchError` handler}.
Можно в функциях использовать не конкретных представителей, а полиморфный \t{MonadError DivByError m}, тогда
будут другие механизмы обработки ошибок.
Если есть \t{Error}, то можно сделать сразу \t{MonadPlus}, чтобы находить первый успешный запуск.

\section{} % 2.22
Трансформер оборачивает монаду, даёт свои функции, а чтобы обратиться к оборачиваемой, надо использовать \t{lift}.
Закон: пофиг, где делать \t{return} (\t{lift . return = return}) и левая дистрибутивность: \t{lift (m >>= k) = lift m >>= (lift . k)}.
Трансформер для \t{Maybe}: \t{MaybeT m a = MaybeT \{ runMaybeT :: m (Maybe a) \}}.

Примеры: если ошибка означает полный FATAL, то следует применять \t{StateT} к \t{Error},
а если состояние при ошибке не портится "--- \t{ErrorT} к \t{State}.

\section{} % 2.23
Линза "--- это штука, которую можно использовать в функциях \t{view} (инфиксное \t{^.}),
\t{set} (\t{.~}) и \t{over} (\t{\%~}, меняет в соответствии с функцией), чтобы менять
подструктуры (например, для пар есть \t{\_1}, \t{\_2}).
Композиция линз "--- линза (внезапно).
Законы: \t{view} на результат \t{set} даёт что надо (и наоборот), два \t{set} подряд "--- только последний.
Наивный подход неэффективен, там нет композиции и есть барьер конструктора данных.

Ван Лаарховена: \t{type Lens s a = forall f . Functor f => (a -> f a) -> s -> f s} (экзистенциальный тип,
т.е. тут говорим, что конкретная линза работает вообще независимо от функтора, одинаково на всех функторах).
Упаковка: \t{lens get set = \\ret s -> fmap (set s) (ret \$ get s)}.
Распакова: берём подходящие функторы, для геттера "--- \t{fmap} игнорит свою функцию,
для сеттера "--- \t{Identity} и как \t{ret} передать \t{const a} ($a$ "--- новое значение для установки).
Композиция линз, внезапно, работает, надо руками проверить (не запутаться в каррировании и композиции двухаргументных функций).
Линзы также можно писать полиморфные (через классы типов), а еще можно делать так, чтобы они модифицировали тип структуры.
