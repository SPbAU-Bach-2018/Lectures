Разница между абстрактными классами и интерфейсамми стёрлась. Осталось, пожалуй, только то, что интерфейсы не могут хранить состояние
(у них все поля -- это \java"public static final")

Если есть \java"compose", то первой применяется функция, переданная параметром: \java"T(B(x))"
Статическим метод быть не может, так как юзаем \java"apply", а реализация ну хоть ты тресни практически всегда одинаковая.
Теперь это не беда -- запишем метод в интерфейс с модификаором \java"default"

Что делать, если мы реализуем несколько интерфейсов и у них есть одинаковые методы по умолчанию.
Становится непонятно, какой метод использовать% -- а-ха-ха, привет проблемы от C++ >:3
.
Тогда такой код не компилируется -- Java это гарантирует.
Как с этим бороться? Примерно так же, как в C++ -- явно указать, какой метод изволите использовать. Написать руками.

Функциональный интерфейс "--- ровно(!) один метод можно/нужно реализовывать ручками.
Абстрактные классы с ровно одним абстрактым методом тоже считаются функциональными интерфейсами ф этой идеологии.

Зачем нам все это? Мы хотим лямбды.

В Java[8] это просто синтаксический сахар: чтобы не городить много ненужного синтаксиса мы реализуем сразу метод и покороче.
Прикомпиляции автоматически оборачивается в создание нового класса и т.д., и т.п.
А если в методе ещё и команда одна, то "---  ооооо! "--- можно так и вообще фигурные скобочки не писать!
%барин изволят проявлять лояльность чрезвычайную!

Если параметры в лямбде "--- ничего, то надо написать пустые скобочки.

Ссылки на методы: если захотелось уже готовый метод куда-то передать.

Можно пробежаться по списку и посоздавать себе юзеров. А так ссылка на конструктор обычно редко нужна.


Рекомендуется уметься решать: только с помощью \java"stream"'ов выдать по файлу первые 10 слов
(по количеству вхождений) с приписанными количествами

Лямбды являются замыканиями: мы когда их используем, то обращаемся к чему-то вне нашего контекста.
Лямбда неявно тащит вместе с собой ссылки на все внешние объекты, которые в ней используются.%ути-пути хомячок
\java"Effective final" "--- это название технологии. Если объект такой, то "--- плюшка восьмой Java "--- 
\java"final" можно было не писать.

Примитивные типы до 8 Java всегда хранились на стеке. А теперь из-за замыканий, если какой-то несчастный \java"int" потребовался
лямбде, то будет сохранён в куче "--- просто потому что все необходимые ей для замыкания элементы лямбда хранит в куче.
