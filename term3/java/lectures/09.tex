\section{Java memory model}
В контексте многопоточности.
\subsection{Три свойства какие-то}%Котик, поправь, пожалуйста Х)
	\begin{itemize}
	\item{Атомарность}
	Не все операции атомарны. Причём не только с \java"long" и \java"double", а и с другими типами при некоторых операций.
	\item{Видимость}
	Чтобы спокойно программировать, мы хотим, чтобы переменные всегда были корректны -- это видимость. Она гарантируется
	ровно в одном из трёх случаев:
	\begin{enumerate}
		\item
			После изменений поток $1$ освободил блокировку, которую захватил поток $2$
		\item
			После изменения поток $1$ создал поток $2$
		\item
			Поток $2$ дождался потока $1$. Тогда ему видны все изменения, сделанные первым потоком.
			Это самый правильный способ.
	\end{enumerate}
	Если мы не делаем ничто из вышеперечисленного, то потоки могут увидеть любой возможный вариант развития событий и изменения переменных.
	
	\begin{javacode}
		int a = 0;
		int b = 0;
		
		//T1
		a = 1;
		b = 2;

		//возможные значения пары (a, b):
		//(0, 0), (1, 0), (1, 2)
		//(0, 2)!
		//Потоки выполняются на разных ядрах процессора. Для каждого потока бужет свой кусочек кеша процессора.
		//Чтобы изменения оказались в оперативной памяти должно пройти некоторое время, и в каком порядке 
		//наши переменные будут туда переведены -- неизвестно.
	\end{javacode}

%у каждого потока есть своя независимавя память(в кеше процессора её видно только ему), 
%потом в общую оперативку данные сбрасываются. Значит, второй поток не должен подглядывать в оперативную память до того,
%как закончится первый(как его данные подгрузятся в оперативку; это типа первого/третьего варианта).
%Правила в Java:
%После получения блокировки поток обязательно сбрасывает свой кеш полностью и загружает из оперативки.
%Когда отдаём блокировку, поток ОБЯЗАН синхронизировать свои данные с оперативной памятью.
%
%Это те причины, по которым блокировки -- это долго: общение с оперативкой медленное.
	
	join() происходит через synchronized(по какому-то мифически-мистическому объекту типа потока).

%У -- упорядоченность

	\item{Упорядоченность}
		Гарантируется, что в итоге программист получит ровно то, что задумал. Но порядок -- не гарантирован:
		компилятор(а у нас два: тот, который в байткод, и JIT-компилятор) может в рамках оптимизации кода переставлять инструкции.
	\end{itemize}
	
\subsection{Volatile-переменные}
	Иногда мы не хотим про всю вышеперечисленную штуку думать. Для этого есть volatile-переменные: все операции с ними атомарны,
	а работают они с общей памятью.

	Надо помнить одну вещь: volatile -- это плохо. %как-то очень категорично
	Ну, то есть долго -- операции с общей памятью всё-таки. Поэтому прежде чем их использовать(не зря же они всё-таки есть),
	надо хорошо подумать(о производительности, например).

\subsection{Про Singleton}
	Если нет синхронизации, может получиться несколько helper'ов -- плохо в singleton'e
	Если она есть, то долго(после того, как хелпер создан, потоки все равно строго по очереди вызывают getHelper, хотя
	уже смело могут все вместе).
	Double-Checked Locking: изначально не работает. Потому что при \java"new" сначала выделяется память,
	значение ссылки инициадизируется и только потом запускается конструктор. А мы уже решим, что можно пользоваться -- ну и получим
	объект в невалидном состоянии. Что нам нужно, чтобы конструктор выполнялся аттомарно? Переменную helper сделать volatile -- тогда
	конструктор будет атомарным.
	В реальности в данном конкретном случае можно использовать \java"final": они точно являются \java"volatile".
	Надо только понимать, что \java"final" запрещает менять дальше.

	Есть же ещё один вариант singleton'a, c неленивой инициализацией, "--- он многопоточный. Но тут мы не можем 
	нормально отреагировать на исключение конструктора "--- не обернёшь же инициализацию поля в \java"try cathch".
	Можно написать статическую секцию инициализации, и уже внутри неё \java"try-catch"-секцию. А можно и просто статический 
	для инициализации поля.

\section{Блокировки и условия}
	Мы не можем брать synchronized в одном методе, а отдавать в другом. И ещё его не запихать в if для проверки, занято или нет.

	Специально для нас в java.utils.Concurrent есть интерфейс \java"Lock".
	\begin{itemize}
	\item
		lock()
	\item
		lockInterruptibly() -- если вам очень надо, а блокировка занята, то отберёт у другого потока % совочек
		блокировку и вызовет у него% совкомБамк()
		\java"interrupt"
	\item
		tryLock()
	\item
		unlock()
	\end{itemize}
	
	Но это интерфейс. А нам нужна реализация "--- это \java"ReentrantLock".
	\java"isFair()" "--- "честность" блокировки: честная -- это когда первым \java"lock" получает тот, кто первым за ним обратился.
	Это работает сильно медленнее, чем нечестный \java"lock".
