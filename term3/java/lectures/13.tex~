\section{Разбор летучки}
\begin{itemize}
\item
{
	A a = null;
	try {
		a = new A();
	} finally {
		if(a != null) {
			a.close();//но если в finally выкинется исключение, то оно забьёт первое, выкинутое в try.
//Это плохо, try-with-resources делает не так: он выбрасывает первое, а второе делает как deprecated
		}
	}
}//чтобы ссылка не сохранялась


надо так:

Throwable t = null;
try {
	A a = null;
	try {
		a = new A();
		...
	} catch (Throwable e) {
		t = e;
		throw e;
	} finally {
		...
	}
} catch (Throwable e) {
	if(e != t) {
		t.addSuppressed(e);
		throw t;
	}
}

\item
	Inner и Nested/
	Все внутренние невяно внутри себя сохраняют ссылку на экземпляр внешнего класса. => имеют доступ к полям внешнего класса, в т.ч. и приватным
		Исп в ситуациях, когда нужен класс, имеющий доступ к внутреннему содержимому класса(например, итератор)
	Вложенные -- не имеют ссылки, поэтому джоступ только к static (в т.ч.и private)
		тестирование и сокрытие кода(например, в BST класс node -- мы не хотим, чтобы им кто-то пользовался%мы -- маленькая жадина
						другая ситуаци: несколько классов с итерфейсом итератор(ну не итератор, но что-нибудь типа того, чего нужно несколько штук, но чтобы не нужен был доступ во внешний класс)

\item
	lock vs synchronized:
1. много условий condition vs один wait
2. получение блокировки по набору объектов%маленькая жадина доволен
3. брать и отдавать блокировку не в одном и том же куске кода
4. можно проверить, можно ли взять блокировку
5. можно насильно захватить блокировку и, что важно, есть разные политики выдачи блокировки: read-write \& Co

\item
	equals -- есть в презентации

\item
	Error -- ошибка джава-машины. Единственный содерж способ обработки -- писание в лог.
Exception обязательно нужно обрабатывать; вызван пользователем -- надо обрабатывать(файл не открылся)
RuntimeException -- необяз; вызван программистом(его ошибка: nullPointerException)

\item
	volatile -- любое изменение переменной приводит к автоматическому изменению её в общей памяти(медленно).
Атомарность некоторых операций(например, конструктора: не volatile сначала создаётся ссылка, потом вызывается 
инкремент-декремент для volatile примитивных типов)

\item
	? super Apple: классть в него любые Apple и наследников, доставать только Object
	? extends Apple: класть только null, потому что там можнт быть несколько слоёв наслдования и мы случайно моем положить более верхние в список более нижних
\end{itemize}

\section{Команды над stream'ами}
Стримы бывают двух типов: объектов и примитивных типов.
Методы с ними бывают тоже двух типов: терминальные/конечные и промежуточные.

Промежуточные -- возвращают всё ещё стрим. filter, 
skip(пропустить N первых элементов), 
distinct, 
map(тип может поменяться;ыункция не должна возвращать void; кладёт результат работы функции, которую выполнил), 
peek(берёт объект, выполняет функцию, кладёт объект(ту же самую ссылку) обратно), 
limit, 
sorted, 
если хотим получить конвенйер примитивных типов, то не можем использовать обычным map -- исп mapToInt и ко,
flatMap принимает команду, которая из объекта делает поток


Терминальные операции
findFirst -- берёт первое яблоко, подходящее под условие и останавливает контейнер; @return Optional(внутри -- null, если ничего не нашлось)
findAny -- @returns Optional; отличается от первого поведением на параллельных потоках
collect -- собирает объекты из потока и что-то с ними делает
count -- %про неё Благодетелю скзать нечего, как и про ***Match
min, max -- без параметра -- естественным образом, с параметром -- надо передать функцию сравнения?
forEach -- аналог peek, но она терминальная. Не гарантирует порядок ыполнения команд в том порядке, в котором элеименты лежат в стриме, при паралдлельном испольнении. Для этого есть forEach

\section{Пример}
Сумма квадратов чисел, оканч на 5

Второй пример.
Есть словарь. Есть к нему буфферед реадер. Есть ещё пафс, путь в файлово системе. list vs walk: walk -- рекуурсивный.
.chars() устрочки -- поток символов(типа Int*thumb up*)

Третий пример.
Генерируем случайные числа. closedRange включает правую границу тоже.
concat доклеивает второй в конец первого
Потоки можно делать из массивов или просто из нгабора элементов

Пример сложнее
Из всех цифр, которые встречаются в числах, больших ста, берём четвёртую и пятую.


Для потока int'ов findFirst вернёт первый ненулевой

В min передаём компаратор в новом виде: comparing(как получить то, по чему сравнивать; то, чем сравнивать)

reduce -- левая свёртка

Слудеющий пример считает факториал числа. Но он большой и не влезает в Int'ы, поэтому нам приходится джелать BigInteger. Но чтобы 'nj преобразовать, мы делаем mapToObj/
В чем прелесть? Можно же и с помощью for'a написать. Ответ: как только напишем слово parallel, это станет быстрее -- выяисление факториала можно распараллелить.


Последние два примера. Или три.
Проверка на то, является ли строчка хитрым палиндромом: выкидываем все небуквы и нецифры, toLowerCase'им их и поверяем.
Зачем потоки? код поэлегантнее. appendCodePoint -- это чтобы добавлять к stringBuilder'у не строчку, а символ.

Обратите внимание: порядок, в котором мы пишем операции, может существенно влиять на производительность.(попробуйте поперемещать sort туда-сюда)

А вот теперь действительно последние два примера.
filter не обязательно ничего не делает. Обратите внимание на порядок выполнения. Элементы последовательно проходят черезх весь конвейрер.
Это хорошо, потому что обработается только то реальное количество элементов, которые нужны. Ну, sorted да, sorted выковыривает -- ну да с ним всё и так хитро

Почему, когда мы поменяли местами filter B sorted, у нас исчез вывод команды sorted? Потому тчо один элемент остался.

