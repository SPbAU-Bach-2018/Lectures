\chapter{Потоки}

﻿Потоки можно воспринимать как стек вызовов (каждый поток имеет стек вызовов).

В любой нормальной операционной системе есть планировщик потоков.

У JVM свой планировщик потоков (не зависит от планировщика ОС).

Есть потоки-демоны, а также пользовательские потоки 
(JVM завершает программу, когда завершились все пользовательские потоки, при этом демоны завершаются вне звисимости от того, что они делали)


\section{Создание потоков}
Сущности:
\begin{itemize}
	\item
		Класс поток "--- Thread (создание потоков и работа с ними)
	\item
		Интерфейс Runnable (поток сам по себе Runnable) - описывает то, что запускается в потоке (имеет один метод run)
\end{itemize}


Создание потока как объекта класса Thread. 
\begin{javacode}
Thread t = new Thread(new Runnable() {
	public void run() {
    		System.out.println("Hello"); 
		// Тут один поток выполняет одну задачу, мы его не можем переиспользовать, 
		//а создание потока - очень дорогая операция, поэтому так лучше не делать
	}
});
\end{javacode}

Чтобы запустить поток - команда \java"t.start();"

Нужно не путать \java"t.start()" и \java"t.run": первое "--- это создание потока, а \java"run()" "--- просто вызов метода.

\begin{javacode}
NameRunnable nr = new NameRunnable(); // Создали новую задачу
\end{javacode}
Создаем три потока, которым в качестве параметра передаем эту задачу.

Мы делаем start и между потоками управление переходит как-то.
А если сделать run, то они будут все дружно по очереди работать в main.

%до этого -- взять у Насти

Конструктор потока: можно передать задачу(а можно не передавать), можно задать имя(можно не задавать).

%в примере про one-two-three будет наглядно, если запустить сначала как есть, а потом start заменить на run --
%сразу видно, что run() просто выполняет действия, как обычная функция, а start() реально запускает поток
%ещё нагляднее будет, если версию со start запустить несколько раз
%Так что дебаг в обычном смысле малоэффективен рпи многопоточности

\section{Свойства потока}
\begin{itemize}
\item\textbf{\java"daemon"}
	Правда ли поток "--- демон.
\item\textbf{Приоритет}
	Влияет на то, насколько часто ему дают выполняться на процессоре.
\item\textbf{Состояние потока}
	Самое главное его свойство.
	\begin{itemize}
	\item\textbf{new}
		Создан, не запущен.
	\item\textbf{runnable}
		Запущен(но может ещё не выполняться).
	\item\textbf{running}
		Активное выполнение(переключением управляет планировщик потоков).
	\item\textbf{dead}
		Закончился.
	\item\textbf{waiting/blocking}
		Это \java"blocked" $\lor$ \java"waiting" $\lor$ \java"timed\_waiting"
	\end{itemize}
\end{itemize}

\java"getState()" "--- возвращает состояние потока.

\section{Взаимодействие потоков}
Самое простое и типичное действие "--- команда \java"sleep", заснуть. 
Поток прерывает своё выполнение на время, \textit{не меньшее} чем то,
которое мы попросили.
\java"Thread.sleep()"(только милли-/наносекунды) или \java"TimeUnit.<единица измерения>.sleep()"(всякие более долгие времена).

\section{yield}
\java"yield()" "--- символ того, что нас можно прерывать пока. 
Полезность? 
Пусть есть два потока, которым лучше закончиться примерно одновременно.
Тогда, чтобы планировщик потоков сделал(дал) примерно по одинаковому процессорному времени обоим(примерно равномерно),
\java"yield()" и присутствует сегодня здесь.
Осторожно: не рекомендуется использовать, если нет особо тонких мест в производительности.

\section{Приоритеты}
По умолчанию приоритет равен $5$.
Почти никакие ОС не поддерживают прям $10$ приоритетов. В винде чуть поменьше, в Linux чуть побольше, в маке примерно столько же.
Поэтому рекомендуется пользоваться именно этими тремя константами: уж три-то приоритета в любой ОС найдётся.%худо-бедно

\section{блокировка другого потока}
Методы \java"sleep" и \java"yield" "--- статические.
Нельзя попросить уснуть другой поток.

\section{ожидание окончания потока}
\java"join()" просит наш поток остановиться и дождаться, пока выполнится другой поток. 
\java"t.join()" заставляет текущий поток дождаться окончания потока \t{t}. Применение? Программа, считающая интеграл, должна дождаться,
пока посчитаются интегралы на каждом кусочке.

\java"joib(millis)" -- это делается для того, чтобы программа не зависала.

Следующая штука приведёт к dead-lock'у

t1			t2
t2.join()		t1.join()

Если же при этом указать millis, то deadlock'a не произойдёт.

\section{прерывание потока}
\java"interrupt()" является лишь рекомендация для другого потока, чтобы он шёл лесом

Исключение \java"interrupted" кидается, если поток прервали, когда он чего-то ждал/бездействовал(\java"sleep", \java"join").
Это способ явно показать, что его не нормально разбудили, а \java"interrupt".


\chapter{Синхронизация кода}
Всё вышесказанное малоприменимо в реальной жизни. Реально мы используем одни и те же данные. И ладно бы мы их только читали --
но так мы же их ещё и пишем.
long a = 1
long -- это 8 байт. Java-машина за 1 раз изменяет only четыре байта. И не дай бог первые 4 отредактировала первая программа,
а в это время вторые 4 -- вторая.
Чтобы это нормальнло работало, есть синхзронизация кода. А также понятия блокировок и критических секций.

Одной и той же блокировкой одновременно может владеть only один поток.

syncronized(o) {}
оба потока должны синхронизироваться по одному и тому же объекту. И нельзя синхронизироваться по примитивным типам.
Обычно синхронизируются по тем объектам, которые изменяют.

Куда ещё можно писать syncronized? Методам.
Эквивалентно "почти", потому что первый шустрее
Синхронизация тогда происходит по \java".this"

Если у нас в классе есть 2 метода -- getValue и incValue, -- то их нужно делать синхронизованными.
Если inc  в какой-то момент начал, но не закончил, то get вернёт не то, а другой inc прибавит не к тому

Если у нас меняется что-то маленькое, что можно за 1 раз увеличить, то всё равно синхронизировать надо.
Для inc'a ясно, потому что иначе у нас оба могут увеличить случайно старое значение вместо последовательного старое -> новое -> итоговое
Но и get тоже надо. Но вызов -- это тоже не атомарная операция, поэтому у нас между вызовом get'a и возвращением им значения
значение могло подрасти.
Но есть ещё и вторая причина, но АМ скажет о ней чуть дальше.

syncronized для статического метода синхронизируется по классу. Никакие два статических синхронизованных метода класса не могут
работать одновременно.

\section{примерчики}
произовдитель-потребитель: с syncronized медленно, а без него точно нельзя. Или надо научиться засыпать вместо активного ожидания.
По этому поводу просим любить и жаловать...

\chapter{Мониторы и условия}
Если было несколько потоков, которые ждали, то непонятно, кто тот единственный счастливчик, которому прилетит одиночный \java"notify()".
(На деле выбирается случайным образом)

Команда wait() блокировку отдаёт
\begin{javacode}
syncronized (o2) {
	o2.wait();//теперь другие могут занять o2
					syncronized(o2) {
						...
						o2.notify();//мы тыкнули wait(), теперь он пристальным взглядом за нами следит, и как
						...	    //только мы отпустим блокировку, тут же заберёт её обратно и полностью проснётся
						...	    %разбудили древнее зло, блин))
					}
	...
	...
}
\end{javacode}
вот так это выглядит :^:o

wait() нужно вызывать в while'e, чтобы там всякие такие спонтанные пробуждения побороть.

