\chapter{Классы и ООП}

С прошлой лекции: всё, как в плюсах, только шапочка другая. И swap не написать.
У всех примитивных типов строго определённый всегда одинаковый размер. Есть обёртки для каждого примитивного типа.

\subsection{Классы}

Если значение не указано, то поле инициализируется значением по умолчанию.
Для ссылок "--- \t{NULL}, примитивных типов "--- $0$, \java"boolean" "--- \t{false}

\subsection{Методы}
Есть статический полиморфизм.

\subsection{Конструкторы}
Если конструктора в классе нет, то генерится конструктор по умолчанию -- ничего не делает и параметров не принимает.

\subsection{Деструкторы}
Их нет. Есть метод \java"finalize()", он будет вызван у объекта перед тем, как его удалит сборщик мусора.
Удалять надо те объекты, до которых нельзя добраться из стека вызовов.
А что если \java"finalize()" добавляет ссылку на объект в некий глобальный список, то есть до него становится можно добраться.
Java-машина его всё равно удалит, и это способ её завалить. Это одна из причин, по которой \java"finalize()" сейчас в состоянии 
\t{deprecated}, только для обратной совместимости, пользоваться им нельзя, да и не нужен он нам в Java.
Помимо того, что не факт, что ваш объект сборщиком мусора вообще будет когда-то удалён -- то есть \java"finalize()"
не будет вызван вообще.


\subsection{Создание экземпляра}
Через слово \java"new". Кроме двух случаев:
\begin{itemize}
	\item
		\java"Integer a = 5;"
	\item
		%\begin{javacode}
		\java{String str = "...";}
		%\end{javacode}
\end{itemize}

\subsection{Наследование}
\java"extends";
В отличие от плюсов здесь есть только один тип наследования "--- публичное наследование.
При этом множественного наследования нет.
Все классы имеют единую иерархию, во главе которой стоит \java"java.lang.Object"

\subsection{Конструктор в наследнике}
Cлово \java"super", если нужнол что-нибудь от родителя

\java"this()" "--- вызов своего конструктора.

\subsection{Интерфейсы}
В плюсах некоторым аналогом абстрактных классов.
Всё в интерфейсе "--- публичное.
После \java"implements" можно писать сколько угодно нужных интерфейсов, которые будут реализованы в этом классе.

\subsection{Абстрактные классы}
Точный аналог абстрактынх классов в плюсах.
Нельзя создать объект этого класса.
Некоторые методы могут быть не реализованы.

Отличие от интерфейса: абстрактный класс может хранить состояние, там нет нормальных полей, есть только методы.
И не все методы в абстрактном классе публичны.

\subsection{java.lang.Object}
\begin{itemize}
	\item
		\java"toString()"
	\item
		\java"equals()"
	\item
		\java"hashCode()"
	\item
		\java"getClass()"
	\item
		\java"wait()"
	\item
		\java"notify()"
	\item
		\java"notifyAll()" "--- для многопоточного программирования, как и notify
%а swap можно написать
	\item
		\java"finalize()"
	\item
		\java"clone()"

\end{itemize}


\section{Модификаторы}
Задание, которое чисто случайно можно схлопотать на зачёте, если АМ захочется:
придумайте самую длинную цепочку модификаторов, которую реально можно ипользовать.

\begin{itemize}
	\item 
		\java"public"
	\item
		\java"private"
	\item
		\java"protected"
	\item 
		по умолчанию(отсутствие модификатора)
		
		Зачем нужен пакетный режим доступа? Потому что в Java нет \cpp"friend"-классов.
		Правило хорошего тона: не оставлять поля без модификатора без очень жёсткой необходимости.
\end{itemize}

\subsection{final}
\begin{itemize}
	\item 
		\java"final" для поля -- операция присваивания может быть проведена ровно один раз.
		
		Почему аккуратнее со ссылками? Потому что ссылку-то на неё мы поменять не можем, а вот внутреннее состояние "--- пожалуйста.
	\item
		У метода это позволяло (до пятой версии) убрать виртуальность от метода и соптимизировать программу. 
		А потом ввели JIT-компиляцию, и с тех пор оно само всё понимает.
	\item
		У классов. Зачем запрещать наследоваться от класса?
\end{itemize}

\begin{javacode}
private final int i = 0;//константа времени компиляции
public static final int N = 10;//самая настоящая константа, которая никогда не меняется и пишется большими буквами
private fincal int j;//у всех объектов может быть разной, но в рамках одного объекта "--- постоянной
\end{javacode}

\subsection{Инициализация}
Значение по умолчанию есть только для полей, а для переменных в функции, например, "--- нет.
%\begin{javacode}
%int i;//не поле
%\end{javacode}

\subsection{Инициализация полей}
В Java принято \t{все} переменные примитивного типа инициализировать руками, чтобы избежать глупых ошибок.

\subsection{Статичекие секции}
А статические секции инициализации запускаются при первой встрече названия класса в коде(при первом обращении).
секция инициализации \i{обычно} создаются до выполнения конструктора, выполняется, соответственно, только один раз.

Раньше можно было написать
\begin{javacode}
class A {
	static {
		System.out.print("Hello");
		System.exit(0);
	}
}
//Потом сделать
//java A
\end{javacode}


И оно бы напечатало что-то, несмотря на отсутствие метода \java"main"(он его не успевал поискать).
Но только до Java7(теперь всё равно сначала ищет \java"main", а потом идёт всё выполнять).

\section{Ягодки. Ээээ, исключения}
EOL "--- exception oriented language(о Java).
В плюсах исключения "ущербные чутка".

\subsection{Причины ошибок}
\begin{itemize}
	\item
		Проверяемое исключение "--- вы обязаны его обработать, иначе не скомпилится.
	\item
		Runtime exception "--- непроверяемые исключения.
	\item
		\java"getStackTrace()" "--- показывает, в каком месте исполнения программы произошло исключение.
\end{itemize}

\t{radix} "--- основание системы счисления

Параметром конструктора исключения передаётся текст.
\java"throws" "--- знак того, что метод может кидать исключение.



\begin{javacode}
public class Main {
	
	public static void foo(int a, String s) throws IOException {
		if(s == null) {
			throw new IOException("Aaaaagh! Bird!");//обрабатываемое: обяз. слово throws и обрабатывать
			//throw new NuberFormatException(...);//необрабатываемое исключение
		}	
		System.out.ptinln(s.roLowerCase() + " " + a);
	}

	public static void bar(String s) {
		foo(3, s);//либо приписать throws к методу bar, либо обработать это исключение
	}
	
	public static void main(String[] args) {
		foo(5, null);//приписывать throws к main'у "--- это катастрофически плохая идея :)
	}
}
\end{javacode}

\subsection{Перехват}
Внутри \java"try" "--- код, который может сгенерить исключение, внутри \java"catch" "--- обработчик

Есть ещё одна секция "--- \java"finally". Она выполняется в любом случае, если надо "--- после \java"catch", если пробрасывается
на другой уровень "--- до проброса.


\section{Применение исключений в коде}
Правило обработки исключений:
исключение надо обрабатывать там, где у вас достаточно данных, чтобы его обработать.

\subsection{Управление на исключениях}
Во-первых, исключения "--- это небыстро.
Во-вторых, затираются настоящие ошибки "--- мы просто не отличим их от нащего стандартного способа выйти из цикла.

\subsection{Запись в лог}
Для себя "--- норм, но пользователю как-то неинтересно это читать.

\subsection{Перехват базовых исключений}
Все наследники отловятся туда же "--- вряд ли мы хотим всё одинаково обрабатывать.

\subsection{Пользовательские исключения}
Принято хотя бы один свой конструктор(от строки-причины писать).

\subsection{Обёртывание исключений}
Правильно "--- генерировать своё новое исключение, заворачивая в него старое.
(чтобы обрабатывающий код мог узнать первоначальную причину исключения)

\subsection{Может ли конструктор кидать исключение}
Правило такое: если конструктор недоделан, то переменная становится null.
\begin{javacode}
ExampleClass b = new ExampleClass(...);
\end{javacode}
