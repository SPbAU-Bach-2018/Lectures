\chapter{Collections frameworks}
Коллекция -- неупорядоченный контейнер, причём в двух смыслах: 
нет заданного порядка обхода и нет на элементах сравнения.

Проверка элемента на вхождение в коллекцию производится по \java"equals()".

%это к какому-то слайду
Почему \java"Object"? В нём определён \java"equals()"
Почему \java"Collection<?>"? Потому что нам всё равно, потому что в \java"equals()" можно передать любой \java"Object".

\java"remove" удаляет только один объект.

\java"unsupportedOperationException" "--- например, если попытались сделать remove в немодифицируемой коллекции.

\java"Scanner" -- позволяет работать не с битами, а уже с объектами.

Операций у коллекции мало.
\java"Iterator" написан в интерфейсе коллекции, это тоже интерфейс. Параметризован тем же типом, что и коллекция.
%[blonde mode on]
Это такая стрелочка, которая ходит между элементами.
%[blonde mode off]
Команда \java"remove()" удалит тот элемент, который мы только что перепрыгнули.

\java"Iterator" кидает два исключения: при достижении конца коллекции и второе.
По договорённости итерторами нельзя пользоваться, если коллекция изменяется.
Это сделано по нескольким причинам:
\begin{enumerate}
	\item
		Избежать инвалидации.
	\item
		Итератор может быть не только обёрткой указателя, а \java"next()" может работать неконстантное время. 
		Из-за этого бывает удобно сразу упорядоченно выгрузить коллекцию в массив.
		И вот там порядок сильно нарушится при изменении коллекции, 
		и итератор "очень сильно" инвалидируется при добавлении/удалении.
		
		При этом \java"remove()" делать можно, потому что он про внутреннюю структуру итератора что-то знает.
		
\end{enumerate}

В примере применения итераторов \java"final" "--- это просто для поддержки штанов, ничего более. 
Просто \t{element} всё равно будет ссылочкой на элемент коллекции,
поэтому элемент внутри коллекции мы так(через $=$) не поменяем в любом случае, значит присваивание нам скорее не нужно.

Интерфейс \java"Iterable" "--- те, у кого можно брать итератор. У них можно делать укороченный, синтаксически сладкий \java"for".

В примере плохо, что у нас после последнего слова тоже будет запятая. Лучше исправлять это методом "первое слово + for[запятая-слово]",
а не делать ещё \java"if" с \java"hasNext()", чтобы было меньше проверок.

Нельзя внутри коллекции создавать объекты типа T. Внyтри коллекции нельзя создать массив типа T.
Поэтому нет метода \java"T[] toArray();". Возвращается тот массив, который коллекции передали, заполненный её элементами.

В коллекции всего много. Поэтому нам сделали класс \java"AbstractCollection". 
\java"remove()" писать необязательно. Почти всегда в своих коллекциях мы его писать не будем. 
Гораздо проще реализовать $4$($3$) метода, чем всю ту кучу. Через них всё остальное можно реализовать.


Какие разные виды коллекций мы знаем?

\subsection{Множество(Set)}
Каждый элемент встречается только один раз.
Но ещё же есть всякие пересечения-объединения. 

У нас появляются важные требования к \java"equals()". Хотя с чего бы? Зачем мы сюда тащим всю эту математику про отношения сюда?

\begin{itemize}
\item
	\java"point.equals(colorPoint)" "--- координаты совпадают \rightarrow вернётся \java"true".
\item
	\java"colorPoint.equals(point)" "--- цвета не совпадают \rightarrow вернётся \java"false". 
\end{itemize}
В итоге нарушилась симметричность "--- неудобно.

Надо что-то делать! Ладно, будем пытаться приводить к \java"coloPoint"'у, и если не получается, то вызывать \java"super.equals()"
Всё, теперь-то мы молодцы? Нет: \java"point", \java"colorPoint1" и \java"colorPoint2" "--- нарушается транзитивность, 
потому что при сравнении с первой все результаты будут  \java"true", 
а при сравнении второй с третьей "--- \java"false"

Варианты решения: послойное сравнение.
\begin{javacode}
this.getClass().equals(that.getClass());
\end{javacode}
То есть для равенства мы потребуем совпадение типов.

\java"canEqual()" "--- в слайде на \java"Point" vs \java"ColorPoint" в любом порядке даёт \java"false". Какой профит? 
А мы могли бы написать просто 
\begin{javacode}
if(o.isInstanceOf(ColorPoint)) {
	//сравнивай, как Point, просто по координатам
}
\end{javacode}
%наследник точки -- волосатая точка

\subsubsection{Hashset \& LinkedHashset}
\java"LinkedHashset" -- заодно хранится списочек в порядке добавления.

%Хьюстон, кажется, нам нужны хеши

Согласованность с \java"equals()" "--- стрелочки в обратную сторону нет, потому что коллизии.

\subsection{Списки}
\java"List" -- наследник коллекции, \java"Generic"-класс.

Всякие поиски принимают \java"Object" \rightarrow сравнивается по \java"equals()".

Постоянное \java"get(i)" компилируется в то же самое, что и проход итератором, но это в \java"ArrayList"'e.
А вообще в \java"get" может быть какая-то логика, так что в общем случае лучше писать итератор.

\java"AbstractList", конечно, тоже есть. 
Но реализовывать нужно чуть-чуть другой набор методов. При таких методах можно не реализовывать свой итератор,
потому что он его возьмёт из \java"get()"'a, но лучше реализовать, потому что \java"get()" может работать неконcтантное время.

\java"AbstractSequentalList" -- это тот, в котором выгоднее писать итератор, то есть где \java"get()" долгий.


\subsection{Очереди и деки}
Элементы из очереди выдаются в некотором порядке. Приоритеты задаём мы в своей реализации. У очереди может быть ограниченный размер.
Она вправе не принимать какой-то элемент(например, потому что память закончилась) (тогда будет брошено исключение IllegalStateException).

В очереди запрещено хранить null.
Методы, не бросающие исключения, делают то же самое, что и бросающие, но возвращают null, 
если требуемого элемента нет(поэтому-то его и нельзя хранить).

Куда же без \java"AbstractQueue". Надо реализовывать неброские[в плане исключений неброские] методы, 
потому что исключения -- недешёвая операция.


\section{Отображения(mapping)}
Это не наследник коллекции, потому что его параметризуем двумя... параметрами

\section{Упорядоченные коллекции}
Упорядоченные в плане "есть порядок на множестве", то есть их можно сравнивать между собой.

Зачем нужны и \java"Comparable", и \java"Comparator"? Мы можем хотеть несколько компараторов, а \java"equalsTo()" у нас единственный.
\begin{itemize}
	\item
		\java"SortedSet" "--- \t{set}, на элементах которого задан порядок.
	\item
		%ой, кто-то напутал с классами и интерфейсами ><
		\java"TreeSet" "--- обычно реализоввано как красно-черное дерево с некоторыми модификациями.
	\item
		\java"NavigableSet"
\end{itemize}

\java"Map"'ы тоже разные
\begin{itemize}
	\item
		\java"SortedMap"
	\item
		\java"TreeMap"
	\item 
		\java"NavigableMap"
\end{itemize}

\section{Алгоритмы}
Класс \java"Collections" "--- в нём лежат все эти утилитные методы.
\java"Collection" "--- это интерфейс.

Операция \java"shuffle()" применяется только к спискам, потому что перемешиваются номера.

В сортировке испольщуется не \t{MergeSort}, и даже не совсем \t{TeamSort} "--- всё зависит от типа объектов и размера коллекции

Лирическое отступление: по аналогии есть класс \java"Arrays". Класс, содержащий все те же самые утилитарные методы, но для массивов.

\section{Вывод}
Коллекции бывают упорядоченные и неупорядоченные.

Ещё. В чём разница между двумя кодами?
\begin{javacode}
ArrayList<> l = new ArrayList();
for(int i = 0; i < l.size(); i++) {
	System.out.println(l.get(i));
}
\end{javacode}
и
\begin{javacode}
List<> l = new ArrayList<>();
for(a: l) {
	System.out.println(a);
}
\end{javacode}
Правило такое: нужно использовать что-то наиболее общее, если возможно. Если же мы используем что-то специфическое, 
то максимально точно указывать тип.

\section{Текущие объявления}
Скоро будет кр. Лучше дома попробовать реализовать какую-нибудь коллекцию, типа BST.

C 9го числа будет три лекции подряд про андроид -- пятница-среда-пятница.
К 21му надо сдать архитектуру практику -- его надо спросить про то чего он от нас хочет.
