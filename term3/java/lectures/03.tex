\chapter{Interface}
Немного ключевых слов:
\begin{itemize}
	\item
		\java"public"
	\item
		\java"static" "--- единственный для всех экземпляров.
			После 8 Java стало можно делать статические методы в интерфейсе.
\item
		\java"final" "--- значение(поля, переменной) задаётся только один раз.
			Поэтому создание полей в интерфейсе "--- 
			это такой способ задать константы, глобальные константы.
		\end{itemize}


\section{String}
\begin{itemize}
	\item
		Нет гарантии, что это массив(зависит от реализации java-машины).
	\item
		Неизменяемы.
		
		Зачем? При копировании кусочков можно со стопроцентной уверенностью сказать, что нам достаточно двух ссылок, а не 
		полноценной копии "--- экономим память.

		Но с Java.7.43 подстрока всё-таки создаётся отдельно, потому что там есть потенциальные утечки памяти.		
\end{itemize}

Что можно делать со строками:
\begin{itemize}
	\item
		Запросить длину.
	\item
		\java"charAt()" "--- взять символ на определённом месте, работает константу.
	\item
		\java"toCharArray()" "--- амортизированно константа: один раз эта строчка реально копируется, потом ссылочки наводятся.
		Реальная копия создаётся только при попытке поменять массив "--- до этого там \it{что-то}
\end{itemize}

\java"indexOf()" "--- первое вхождение подстроки.
\java"lastIndexOf()" "--- последнее вхождение подстроки.

\subsection{Конкатенация}
'+' "--- можно складывать только примитивные типы, обёрточные типы и, вот, строчки.

Кажется, плюсик долго работает(если только у компилятора нет возможности пооптимизировать "--- работу с константными строками, например).
Утверждается, что это плохой и долгий код:
\begin{javacode}
for(...)
	str = str + 'A';
//эта штука работает не совсем за линию, потому что там, как в векторе, но
//у нас захламляется память: был str-> |||||||
//                                     |||||||A
//                           str теперь ссылается на вторую строку, а первый объект надо чистить 
\end{javacode}

А \java"StringBuilder()" сработает за суммарную длину всех строк, которые надо склеить "--- сначала посчитает, потом склеит.
Если надо 28 захардкоженных строковых литералов сложить, то надо использовать плюсик, потому что эти литералы ещё
при компиляции сольются вместе -- соптимизируются.
Для склейки двух строк \java"concat" и плюсик "--- одно и то же, так что \java"concat" можно не использовать

\section{Regexp'ы}
Есть из коробки.
%"\\\(\([\^\)]*\)\\\)"
%\\ --> \
%скобочки
%то есть найдём содержимое круглых скобок, если они есть в строке, конечно


\chapter{Generics}
В Java нет шаблонов.

Для чего всё это.
\java"ArrayList" "--- что-то типа вектора в плюсахъ.

Как выглядит цепочка наследования для объекта \java"(Object)2":
$2 \rightarrow \text{Integer} \rightarrow \text{Object}$

Чем этот код нехорош? В него можно положить всё, начиная от крокодила до апельсина. Это было до пятой версии(пользоваться было невозмонжо).
А после пятой весрсии появились дженерики.
Что же это?
Пусть то, что у нас там лежит, мы всегда хотим приводить к строке. Но у нас всё сломается, \java"integer" к \java"String"'у не приводится.
Пишем \java"<String>".
При попытке добавить всё, что угодно, кроме \java"String"'a, мы получаем ошибку компиляции.


Как это должно быть устроено внутри?
Параметризуемся \t{automobile}.
Изначально мы можем туда положить автомобильчик и наследников.
Если автомобильчик $\rightarrow$ \java"Object", то это ж надо помнить, что положили, чтобы не \java"Object" обратно выдавать.

На этапе компиляции \java"Generic" гарантирует, что ничего лишнего мы не положим, а на выходе получим то, что укажем в <>.


\section{Как работает}
\java"Generic" компилируется только один раз.
Вся информация про \java"T" стирается "к чёртовой матери"(c) и "условно" всё заменяется на \java"Object". Проблема: в \t{runtime} мы не знаем,
от какого типа мы создались, то есть внутри \java"Generic"-класса мы не можем создать объекты типа \t{T}.
Инфа стирается и приписывается только к \java"add()" и \java"get()".


Нельзя выполнять преобразования типа
\begin{javacode}
ArrayList<String> = ArrayList<Object>
\end{javacode}
Два случая(и оба плохие >:3 ):
\begin{enumerate}
	\item
		\java"Integer"'y присваивается \java"Object".

		Плохо, если в \java"Object" добавим строчку, то потом из \java"Integer"'a попытаемся это достать и получим ошибку
	\item
		\java"Object"'y присваивается \java"Integer"
		Попробуем добавить в \java"Object" строчку, но сразу получим ошибку
\end{enumerate}

\java"ArrayList" "--- список, реализованный на массиве(он реализует интерфейс \java"List").
\java"List" "--- интерфейс, просто список.

\section{Преобразование типов}
Так писать можно, но выдаётся \t{warning}. В плюсах на \t{warning} можно забить, а в Java так не принято, надо без них, 
поэтому нужно ручками писать \java"SupressWarnings("unchecked")".

\section{Примеры испо... Проблемы}
\begin{enumerate}
	\item
		"Итератор "--- это такая лягушка, которая прыгает между листиками"(c)
%^000000000
%iterator.next()
%0^00000000
%00^0000000
%...
%000000000^0

		Почему от \java"Integer" не работает? Потому что запрещено приравнивание разных типов.
		\java"Collection<?> c" "--- вот это мы называем "более элегантный подход", чем в C++.
		То есть "мне всё равно, какую коллекцию я получаю на вход".
		Только команда \java"next()" будет выдавать \java"Object", потому что она не знает ничего.
		Такой код принимает на вход абсолютно любую коллекцию.
	\item
		Мы хотим передавать не абы что, а только \java"Shape" или его наследников -- пожалуйста:
		\begin{javacode}
		...<? extends Shape>...
		\end{javacode}
		Тут итератор будет возвращать "--- самый высокий возможный тип "--- \java"Shape"
	\item
		%апельсинчики, крокодильчики и автомобильчики
		%апельсины, крокодилы и автомобильчики
		Итог: параметризуем метод.
	\item
		В Java нельзя сравнивать объекты -- нельзя перегрузить операторы больше-меньше. Надо реализовывать интерфейс \java"Comparable"
		(он параметризованный).
		\java"class Integer implements Comparable<Integer>"
		\java"class Integer implements Comparable<Object>"
	
		\java"<? super T>" "--- любой класс-родитель Т.
		До этого не работало, потому что кружочек был \java"Comparable" не от кружочка, а от чего-то выше него "--- от фигуры. 
		Это адекватно, просто надо это явно указать.

	\item
		\java"get()" "--- выдаётся \java"Object", и это точно, а там может быть всё что угодно. Это ошибка компиляции.

		\java"typeCapture"

		Компилятор проверит, что везде тип \t{T}, всё совпадает и мы молодцы, и только после этого всё стирает и приводит к \java"Object"'у.
\end{enumerate}

Есть в Java золотое правило программированрия: если ваш тип данных является \java"Generic-типом", 
то везде, где нужно что-то параметризовывать, оно должно быть параметризовано наиболее общим типом данных.

Отличие от плюсов:
\begin{enumerate}
	\item
		\java"T tmp = new T();" писать нельзя
	\item
		Если мы подразумеваем, что где-то что-то есть, то надо писать \java"extends".
	\item
		Dся информация о типах стирается.
\end{enumerate}

\subsection{ЕЩё один пример}
\begin{javacode}
class Fruit {}

class Apple extends Fruit{}

class Antonovka extands Apple {}

public class Main {
	public static void foo(ArrayList<? extends Apple> l) {
//		l.add(new Apple()); не компилится -- вдруг это был список антоновки?
//можно положить _только_ одну вещь -- null, он имеет все типы на свете
//бессмысленно, беспощадно, но можно
		Apple a = l.get(0);//доставать яблоки можно
	}
	public static void bar(ArrayList<? super Apple> l) {
//сюда можно положить Apple или его наследников
//а доставать можно наиболее общий тип для всех этих super -- Object
		l.add(new Apple());
		l.add(new Antonovka());
		l.get(0);
//на самом деле информация стирается не вегда до Object'a, a до наибольшего общего типа
	}
	public static void main(String[] args) {
	
	}
}
\end{javacode}
