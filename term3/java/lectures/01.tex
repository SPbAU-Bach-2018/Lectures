\chapter{Введение}

\section{Информация про курсовой проект по Java}

\begin{itemize}
	\item Должен быть написан под Android
		
	\item Должен использовать возможности андроид: геопозиционирование, смс-ки, функции мобильника, touch-screen...

	\item Тема должна иметь хоть какую-то связь с реальностью, а не быть высосанной из пальца
	
	\item Можно делать парой, если совсем масштабно "--- можно трое, но это придётся обосновать

	\item Сдача проекта будет трёхэтапной:
		\begin{enumerate}
			\item Защита архитектуры приложения
			
				Код им в этот момент безынтересен.
				Происходит примерно в октябре.
		
			\item Proof of concept
		
				Необходимо представить некое приложение, демонстрирующее функционал и возможности проекта.
				(это может быть заглушка на заглушке)
		
				Происходит примерно в ноябре.
		
			\item Сдача приложения

				Происходит ближе к зачётной неделе.
		\end{enumerate}
\end{itemize}

Нужная для написания кода информация будет приходить по ходу семестра, 
но можно и бежать впереди паровоза или мучить практиков
(ответы на эти наши вопросы "--- это одна из их задач >:3)

Сейчас надо думать над проектом и делиться на команды.
Тему проекта надо будет согласовать с Антоном Михайловичем.

При желании тема может касаться архитектуры ЭВМ, 
которую нам также будут читать в этом семестре.

\section{От авторов}

Данный конспект рекомендуется употреблять в качестве вспомогательной
добавки к Слайдам%Благодетеля
, любое количество раз в день по необходимости, 
утром, вечером, днём или ночью. При повышенной впечатлительности "--- 
натощак ;)



\section{Зачем мы учим Java?}

\begin{itemize}
	\item В проге на С++ сложно найти ошибку, а если используется 
		ещё и оптимизирующий компилятор, то и вообще.
		Java создавалась с учётом ошибок C++, 
		на ней должно быть проще писать.
	
	\item Но ещё есть C\#, и его тоже можно изучать. 
		C\# на Java похож. Но он сложнее. 
		И он основывался на Java и её ошибках при создании,
		но там есть микрософтовская гигантомания. 
		Зная Java, его можно спокойно выучить.
	
	\item Основная плюшечка Java не кроссплатформенность
		(компиляторы C++ есть правда на все платформы, а вот
		Java-машитны "--- не на все), а память. 
		Вручную необходимо лишь выделять память, 
		а всю работу по освобождению берёт на себя виртуальная 
		машина. Это более безопасно(Java-машину можно 
		ограничивать в правах) и это ещё и своеобразная 
		песочница "---
		если что, сломается машина, а не вся операционная 
		система, как могло быть с C++.
	
	\item При этом главный минус "--- производительность.

		На самой первой Java-машине все работало в 10 раз 
		медленнее, чем на C++, не считая время на запуск.
		Сейчас это не так "--- сейчас есть 
		just-in-time компиляция(и адаптивная jit-компиляция). 
		Машина умная и длогадывается, что некоторые куски
		кода не используются. Например
		
		\begin{javacode}
			j = 0;
			for(int i = 0; i < 1000; i++) {
				if(j > 0) {
					/*...*/
				}
			}
		\end{javacode}

		Этот цикл выполнится пару раз, а потом на него 
		радостно забьют.

	
	\item Ещё один плюс "--- очень широкая стандартная библиотека,
		хорошая библиотека для работы с многопоточностью и
		кросс-платформа для отрисовки графики, чего нет в  C++
\end{itemize}


\section{Напоследок}
	Есть 6 версий Java. Мы говорим про стандартную SE. 
	ME сейчас не используется(она для старых мобильников).
	EE "--- серверные возможности. 
	Card "--- современная для исполнения на совсем маленьких устройствах.
	
	Принципиально это всё один язык, но различаются стандартные 
	библиотеки и оптимизации в компиляторе.


	Разных виртуальных машин тоже очень много. 
	Самые известные: oracle java и openJdk
	(принята в качестве стандарта, она с седьмой версии)
	IBM J9 продвигается как серверная версия

	

\chapter{Язык Java}

\section{Некоторый синтаксис}

Жестко закреплёные и принятые соглашения по code style "--- 
code conventions: если написать иначе, то
работать будет, но все скажут "фуууу".

Основные правила, которые надо помнить:
\begin{enumerate}
	\item названия всех классов "--- с большой буквы(и CamelCase)
	
	\item все функции, методы и поля пишутся с маленькой буквы
	
	\item названия всех констант пишутся полностью большими буквами
		(и, да, разделяются подчёркиваниями)
	
	\item this пишутся только там, где это необходимо, 
		чтобы скомпилировалось
\end{enumerate}

Комментарии есть, они как в C++. Но есть у них ещё одна функция "---
javadoc. Если текст комментария начинается со значка \[*\], 
то документацию можно будет генерить автоматически.

В программе должен быть класс, у которого будет метод 

\begin{javacode}
public static void main(String[] args)
\end{javacode}

где \java"args" "--- массив строк, 
если при запуске передаются какие-то параметры.

Ещё одно кардинальное отличие от C++: там массив "--- это кусок памяти, 
попиленный на кусочки. 
А в Java это объект, у которого есть один параметр "---
length, чтобы можно было узнать длину своего массива 
и не схлопотать выход за его пределы и т.п.

По умолчанию оно само сделает код возврата 0.

Есть плюшка: другой цикл for "--- foreach:
\begin{javacode}
	for(String str: args) {
		/*...*/
	}
//String "--- тип переменной
//args "--- коллекция, которую переменная пробегает
\end{javacode}
%и значение str -- это не индекс, а именно очередной элемент коллекции

При использовании \java"javac", 
если нужны какие-то нестандартные классы,
надо править \java"-classpath"

Запустить свою программу(содержащую класс):
\java"java ClassName". Важно, что расширение писать не надо.





\section{Package и иже с ним}

\java"package" "--- пока что это для нас "как namespace". 
В Java принято, чтобы все классы находились внутри каких-то пакетов, 
названия их строго регламентированы.
%перевёрнутое доменное имя

Пока \java"public" пишем к каждому методу отдельно.

У строки для определения длины используется не поле, как у массива, 
а метод \java".length()".
\java".charAt(i)" "--- это потому что нельзя \java"[]"





\section{Наследование}
Синтаксис отличается
%вот это поворот!
от синтаксиса C++: заместо двоеточия и сопровождающей его компании
ключевых слов и названий классов используется \java"extends"
и название класса после него. 
При этом множественного наследования нет. 
Поля заводятся аналогично C++, только модификатор доступа надо писать.

Единственный метод, название которого пишется с большой буквы "--- 
конструктор, потому что его название совпадает с наванием класса.

\java"virtual" мы не пишем, потому что все методы "--- \java"virtual".
Если надо вызвать родительский "--- 
пишем \java"super.methodName(...)"

\begin{javacode}
return result*num;
\end{javacode}

Не пишем \java"this.num", потому что code style.





\section{import}
\java"import" используется, если мы хотим импортировать классы
(чтобы не писать их полное название)

\begin{javacode}
import ru.spbau.kuznetsov.test01.parser.Parser;
\end{javacode}

Полезно писать целиком, а не со звёздочкой, 
чтобы избежать конфликтов имён.





\section{Объекты}

Объекты создаются только одним способом "--- 
на heap'e с помощью \java"new".

В Java совсем нет указателей. Нет амперсандов. 
Всё, что есть "--- ссылки. И работать с ними как со ссылками.
(с точки зрения плюсов аналогично механизму smart\_pointer'ов)


\section{Примитивные типы}

Все примитивные типы в Java имеют строго регламентированный размер. 
И все они "--- signed.
Все без исключения остальные типы "--- 
ссылочные(и пишутся с большой буквы).
Объекты этих типов передаются по ссылке.
Все эти ссылочные типы "--- классы. И все они наследуются от 
\java"java.lang.Object", у которого есть следующие методы:

\begin{itemize}
		
	\item \java"String toString()" "--- 
		то есть абсолютно все классы умеют 
		приводить себя к строке

	\item \java"boolean equals(Object obj) "--- 
		дефолтно два объекта равны, 
		если у них одинаковый адрес в памяти

	\item \java"int hashCode"
\end{itemize}


\subsection{Отличия примитивов от плюсовых}

\begin{enumerate}

	\item Нет автоматического приведения никаких других типов 
		к \java"boolean".
	
		\java"if(x = 3) {...}" не работает, 
		потому что \java"if(3) {...}" не работает, 
		так как нет автоматического приведения $3$(числа) 
		к \java"boolean".

		О логических операциях:
		\begin{itemize}
			\item $\&\&$, $||$ "--- ленивые операторы
			\item $\&$, $|$ "--- полные операторы
		\end{itemize}

		Для \java"boolean" есть обёртка \java"Boolean". 
		Из полезного в ней:
		\begin{itemize}
			\item \java"boolean parseBoolean(String)" "--- 
				по $true$/$false$ выдаёт 
				нормальный \java"boolean".
			\item \java"String toString(boolean)" "--- 
				в обратную сторону.
		\end{itemize}


	\item Тип \java"char" занимает два байта и он беззнаковый. 
		И это номер символа в юникоде.
		Его класс-обёртка "--- \java"Character" "--- 
		его методы, вроде, понятные.


	\item Четыре целочисленных типа.
		Можно писать число через подчёркивание "--- 
		чтобы числа большие читались лучше ><

		Целочисленное деление здесь "--- 
		это взятие неполного частного.

		Переполнение, как и в C++, не исключительная ситуация.

		В обёртках полезного немного, но есть 
		\java"MIN_VALUE", 
		\java"MAX_VALUE", 
		\java".toString(typename)", 
		\java".parseTypename(String)".


	\item Вещественных типов два.
		Деление на ноль не исключительная ситуация.


	\item Преобразование типов бывает явное и неявное.
		
		При округлении просто отбрасыватся дробная часть.

		Пример на то, как (не)работает неявное приведение:
		\begin{javacode}
		byte a = ...;
		byte b = ...;
		a = a + b;//не компилится, потому что
			  //автоматически привелось к int'у
		a = (byte)(a + b);
	\end{javacode}

\end{enumerate}



\subsection{Из принципиальных отличий от примитивов C++: Autoboxing}

Есть возможность автоматически заводить переменные типа обёртки
(с пятой Java).

Зачем нужны такие переменные?
\begin{itemize}
	\item Передавать переменную как объект(то есть не по значению).
	\item (важно) Запрещено создавать коллекции примитивов. 
		То есть если бы такого преобразования не было, 
		было бы тяжело.
		Но примитивные типы всё равно нужны,
		так как занимают меньше места и хранятся на стеке.
\end{itemize}


\subsection{Важные замечания: комментарии к примерам на слайдах.}
Чем там единичка так принципиально от тысячи отличается? 
Объекты сравниваются по адресу в памяти. 
И Java-машина кеширует 256 маленьких чисел,
какие "--- зависит от настроек Java-машины, на это лучше не полагаться. То есть чтобы сравнивать обекты, 
надо использовать метод \java"equals()".

Если переопределять \java"equals()", 
то и \java"hashCode()" тоже надо переопределять.


\subsection{Передача аргументов}
Примитивные типы передаются по значению, все остальные "--- по ссылке.

Так почему в примере все равно осталась единичка?

%вообще-то, вот поэтому
%-.
%1|
%_. <-------------x
%^
%|
%|
%|
%x
%
%стало
%
%-.
%1|
%_. <-------------x
%
%
%
%                 .-.
%x--------------> |3| (и радостно уничтожилось потом)
%                 ._.

Потому что нельзя объект поменять, можно поменять его внутреннее 
значение [все дружно помахали ручкой механизму указателей].
Класс \java"Integer" поменять нельзя, 
и никак нельзя поменять его внутреннее значение.
То есть swap для \java"Integer"'a написать не получится. %а так хотелось

%в следующих сериях:
%ооп

