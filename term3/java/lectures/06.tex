\chapter{Reflection}
\section{Основное}
Пакеты \java"java.lang" и \java"java.lang.Reflect".
Есть класс \java"Class<T>", дающий информацию о типе: все его методы, поля, родители.

Получить можно разными способами:
\begin{itemize}
	\item
		Используя метод \java"getClass()":
		\java"Class<String> c = "a".getClass();//вернёт Class"
	\item
		\java"Integer.TYPE" эквивалетнен \java"int.class"
\end{itemize}

\java"forName" позволяет получать классы по имени. Удобно используется в плагинах
(нашёл себе в папке кучу файликов и все проверил, класс ли, и, может, использовать как-то).

\begin{javacode}
//это комментарии к кусочку примера из лекции

Initable.class//подгружается java-машиной, 47 захардкожено. 
//А чтобы выдать staticFinal2, 
//сначала его надо вычислить -- и это есть до этого выполнить
//статическую секцию инициализацию.
\end{javacode}

Имя класса:
\begin{itemize}
	\item 
		Каноническое "--- с прописанным пакетом.
	\item 
		Полное "--- с внешним классом через точку, если таковой есть.
	\item 
		Простое "--- ну, просто название :)
\end{itemize}

Ещё несколько полезных функций:
\begin{itemize}
	\item
		\java"isAssignableFrom()" "--- является ли вторая штука нашим наследником.
	\item
		\java"isInstance()" "--- можно ли объект привести к нашему классу.
		\java"instanceof" работает быстрее, 
		потому что на этапе компиляции компилятору может быть известна информация об \t{x} и сработает быстрее
		(иначе всё точно так же через рефлексию)
\end{itemize}

\subsection{O том, как и где можно использовать cast(), а где нужно}
\begin{javacode}

//foo -- статический метод и в классе А, и в классе В
A x = new B();
x.foo(); //статические методы не виртуальны, поэтому вызовется из класса А
((B)x).foo();//работает только если B известен
//если B неизвестен
Class bClass;
(bClass.cast(x)).foo();
\end{javacode}

\t{Замечание в тему:} в отличие от \java"isInstance", \java"==" даёт \java"true" только в случае иточно совпадения типов сравниваемых объектов. 
Из соответствующего примера с лекции можно заметить, что \java"Class" является синглтоном.

\section{Применение}
Реально Reflection используют, чтобы добраться до внутренностей какого-то класса.

\begin{itemize}
	\item{Modifiers}
		\java"getModifiers" возвращает массив констант(\java"ABSTRACT", \java"FINAL" и т.д.).
	\item{Fields}
		\begin{itemize}
			\item
				\java"getFields()" вернёт все публичные поля, в том числе и родительские.
			\item
				\java"getDeclaredFields()" вернёт все поля вне зависимости от модификатора доступа, но не из родителей. 
				То есть мы реально имеем доступ к любым приватным данным.
			\item
				\java"getType()" "--- \java"returns Class"
			\item
				\java"get(Object)" "--- тот объект, у которого мы хотим вытащить значение поля.
				То есть мы знаем имя поля и хотим к нему обратиться, но у какого объекта...
				Вот в \java"get()" и передадим, у какого объекта.
		\end{itemize}
		\java"B.class.getField("y").get(b);//так можно написать"
	\item{Methods}
		\begin{itemize}
			\item
				\java"getMethod(name, Class... Parameters)" "--- к имени нужно ещё добавлять принимаемые типы.
			\item	
				\java"invoke()" "--- позволяет вызвать в том числе и приватный метод. Если метод \java"static", 
				то в качестве \java"object" можно передать \java"null"(благо нам всё равно, что именно передавать).
		\end{itemize}
	\item{Constructor}
		\begin{itemize}
			\item
				Вместо \java"B.class.getConstructor().newInstance();" можно, 
				если хочется просто конструктора по умолчанию, написать \java"B.class.newInstance()"
		\end{itemize}
\end{itemize}

Но нельзя просто так безнаказанно вызывать и использовать приватные методы, поля и т.п. >:3
%Ничего в этом мире не бывает просто так
Если мы попытаемся, то вылетит исключение.
Но его, конечно, можно обойти: сделать \java"setAccessible(boolean)" "--- пометить, что мы правда хотим нарушить инкапсуляцию.

\java"field.setAccessible(true)" "--- по этой переменной теперь можно будет добираться до соответствующего поля в любом случае.
В то же время если у нас будет ещё одна такая же переменная \java"field2", в которой \java"setAccessible()" не сделан, 
то через неё это сделать будет нельзя.

Если метод ожидает увидеть на вход примитивы, то в \java"invoke()" передаём ему мы обёртки. 
И как мы это делаем? Массивом \java"Object"'ов.


\section{Массивы}
Зачем ему методы \java"get" и \java"set"? Почему не \java"[]" делать?
\java"newInstance()" возвращает \java"Object[]".

\section{ClassLoader}
Описывает механизм загрузки классов.
Можно сделать свой "--- кастомная загрузка класса в java-машину.
(можно, например, хранить свои классы в базе данных/в интернете и подкачивать их оттуда)

\java"ClassLoader"'ы образуют дерево(иерархическое). Если какой-то \java"ClassLoader" из этой иерархии просят загрузить класс \t{X}, 
то он сначала обежит поспрашивает потомков, не грузил ли кто из них,
и если нет, догрузит сам. Если в поддереве уже загружено несколько, то вернёт первый найденный. Если кто-то изпредков уже грузил \t{X}, 
то нам его уже грузить нельзя.

\section{Выводы}
Типичными примерами использования \java"Reflection"'a являются 
\begin{itemize}
	\item
		Сериализация(требуется передать все данные объекта или класса, невзирая на модификаторы доступа).
	\item
		Система плагинов(возможность работы с любыми классами, получая их имена автоматически благодаря \java"forName").
\end{itemize}
