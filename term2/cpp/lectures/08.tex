Новые операторы:

\begin{enumerate}
	\item \cpp'const_cast'
	\item \cpp'reinterpret_cast'
	\item \cpp'static_cast'
	\item \cpp'dynamic_cast'
\end{enumerate}

Первые три происходят во время компиляции, четвёртый "--- в момент работы программы.

\cpp'const_cast' позволяет менять наличие \cpp'const' у типа, точнее, снимать его:
\begin{cppcode}
void f(const char* p)
{
	char *p1 = const_cast<char*>(p);
}
\end{cppcode}

Это, кстати, может приводить к падению программы:
\begin{cppcode}
const char s[] = "Hello!";
char s2* = const_cast<char*>(s);
s2[0] = 'h'; // падение, так как строчка лежит в защищённой области памяти.
\end{cppcode}

Зачем это вообще?
Предположим, что вы используете библиотеку, которая была написана ещё когда слово \cpp'const' не существовало.
Для вызова такой функции из современного кода придётся использовать \cpp'const_cast'.
Сам \cpp'const_cast' эквивалентен простому привидению типа указателя в Си, его легче видеть и находить в коде.

\cpp'reinterpret_cast' позволяет приводить один тип к абсолютно другому, просто перевоспринимая память, отведённую под первый тип, как второй.
Если вспомнить интрузивные списки, то именно этот приём мы хотели там применить. Работает оно ровно так же, как в Си, но опять-таки это легче воспринимать и находить в коде.

\cpp'static_cast' используется для:
\begin{enumerate}
\item
	Приведения типов между примитивными типами:
\begin{cppcode}
double d = 1.5;
int i = static_cast<int>(d);
\end{cppcode}
	Между указателями на совсем разные типы это уже не работает.

\item
	Привидение указателей в/из \cpp'void *'

\item
	Привидения типов, описанные пользователем.

\item
	Приведение указателей на разные классы, отслеживая, можно ли приводить (является ли один класс предком другого).
	Пусть у класса \t{A} есть два наследника \t{B} и \t{C}, а также сторонний класс \t{D}.
\begin{cppcode}
B* pB = new B();
A* pA = static_cast<A*>(pB);
D* pD = new D();
pa = static_cast<D*>(pD); // Ошибка компиляции

C* pC = static_cast<C*>(pA); //Компилируется, но некорректно
\end{cppcode}
	Заметим, что в последнем случае действие могло быть корректным, если бы \cpp'pA' указывал на \cpp'C',
	но на этапе компиляции, в общем случае, проверить это невозможно.
	Вообще говоря, это нормальная практика "--- мы передаём по указателю на родителя некоторого наследника,
	и, если мы уже знаем, кто он, то можем привести тип.
\end{enumerate}

Перед тем, как займёмся \cpp'dynamic_cast', рассмотрим его механизм "--- RTTI (Run-Time Type Information).
Он позваляет проверить по указателю на некоторый класс, какой же он на самом деле,
но только в одном случае "--- если у класса есть хотя бы один виртуальный метод.
Тогда, как мы помним, у класса есть таблица виртуальных функций, которая хранится одна на класс.
Тогда RTTI добавляет туда поле: структуру \cpp'type_info':
\begin{cppcode}
#include <typeinfo>

const type_info& ti = typeid(*pB);
cout << ti.name();
\end{cppcode}
Вы получите имя класса из объектного класса.
Его точное имя не получите, так как работает манглинг (mangling).
У структуры так же определены операторы \cpp'==' и \cpp'!=':
\begin{cppcode}
if (ti == typeid(B))
	//...
\end{cppcode}

Зачем это использовать?
Ну пусть есть список элементов интерфейса и все отрисовать, причём код их отрисовки зависит от системы,
и поэтому в модели (Model) лежать не должен.
Мы просто для каждого выясняем его тип и обрабатываем.
Получается немного убого, гораздо лучше эту задачу решает шаблон Посетитель (Visitor pattern).

Вернёмся к \cpp'dynamic_cast':
\begin{cppcode}
A* pA = new B();
C* pC = static_cast<C*>(pA); // Некорректно
C* pC = dynamic_cast<C*>(pA); // Или отработает,
							  // Или запишет NULL
if (pC != NULL)
	//...
\end{cppcode}

\section{\t{mutable}}

Представим, что у нас есть матрица, и у неё хотим считать определитель.
Если мы будем много раз вызывать этот метод, то каждый раз он будет вычисляться, что затратненько.
Предположим, что мы кешируем значение определителя:
\begin{cppcode}
class Matrix {
private:
	//...
	bool isUpdated; //менялась ли матрица?
	double det;
public:
	//...

	void set(int i, int j, double x) {
		//...
		isUpdated = true;
	}

	double determinant() const {
		if (isUpdated) {
			det = //...
			isUpdated = false;
		}
		return det;
	}
};
\end{cppcode}
Всё бы хорошо, но... \cpp'const' у определителя уже ставить нельзя.
Можно бы убрать, но тоже не хорошо: у константных объектов нельзя узнать определитель.
Тогда можно просто указать \cpp'mutable' у наших полей: оно означает, что эти поля можно менять даже из константных методов:
\begin{cppcode}
class Matrix {
	//...
	mutable bool isUpdated;
	mutable double det;
	//...
};
\end{cppcode}
