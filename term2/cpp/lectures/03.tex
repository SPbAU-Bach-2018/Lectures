\chapter{STL}
\setauthor{Юрий Кравченко} 

STL (Standart Template Library) состоит из:
\begin{itemize}
	\item Контейнеры (\cpp'vector', \cpp'map', ...) "--- структуры для хранения динамического количества объектов
	\item Алгоритмы
	\item Ввод/вывод
\end{itemize}
 
Также в C++ было принято называть заголовочные файлы без \verb'.h', например: \cpp'#include <vector>'.
Тогда, подключение стандартной библиотеки C выглядит странно: \cpp'#include <stdlib.h>'.
При этом просто откинуть для них \verb'.h' нельзя "--- тогда \verb'string' и \verb'string.h' совпадут.
Поэтому сделано было так: \cpp'#include <cstdlib>'.
 
\section{Пространства имён (namespace)}
 
Как мы знаем, имена разных сущностей не должны совпадать. В связи с ростом количества слов гарантировать их уникальность уже очень сложно, особенно при использовании библиотек. Как с этим бороться?
 
Можно объявлять некоторые элементы внутри других.
Например, вспомним \cpp'shared_ptr'.
Ему нужен был класс \cpp'stoarge' "--- довольно распростронённое имя.
Мы могли бы объявить его внутри класса \cpp'shared_ptr', не добавляя его в глобальное пространство имён:
\begin{cppcode}
class shared_ptr {
	class stoarge {
		//...
	};
 
	//...
};
 
//...
 
shared_ptr::stoarge a;
\end{cppcode}
Как видно, класс теперь имеет полное имя \cpp'shared_ptr::stoarge'.
Теперь \cpp'stoarge' без уточнений виден только внутри \cpp'shared_ptr'.
 
Исторически сначала сложился компилятор C++, а потом стандартная библиотека. Из-за этого у многих были свои реализации структур данных.
Поэтому возникло обобщение идеи такого сокрытия не только для классов "--- создание пространств имён:
\begin{cppcode}
// Complex.h
 
namespace au {
	class Complex {
		//...
	};
}
 
//Comlex.cpp
 
namespace au {
	Complex::Complex(int Re = 0, int Im = 0) {
		//...
	}
}
 
// или
 
au::Complex::Complex(int Re = 0, int Im = 0) {
	//...
}
\end{cppcode}
 
Есть правила хорошего тона при использовании пространств имён. Пусть мы хотим написать двумерную матрицу комплексных чисел:
\begin{cppcode}
#include "Complex.h"
 
class Matrix {
	au::Complex **data;
}
\end{cppcode}
И в конструкторе тоже придётся писать
\begin{cppcode}
Matrix::Matrix(...) {
	data = new au::Complex[...];
}
\end{cppcode}
 
Как видно, если пространство имён длинное, то писать придётся много.
Часть людей считает, что так и нужно, часть считает, что можно использовать более короткий синтаксис:
\begin{cppcode}
using namespace au; //Всё из пространства имён стало доступно
 
Matrix::Matrix(...) {
	data = new Complex[...];
}
\end{cppcode}
Если в файлах с кодом на это можно согласиться, то в заголовочных файлах такое не поддерживается.
Представим, что в проекте появился ещё один класс \cpp'Complex'.
Тогда при использовании заголовочного файлов вашей матрицы возникнет ошибка (двойное определение), при которой разбираться придётся не автору.
 
Пространства имён могут быть вложенны:
\begin{cppcode}
namespace ru {
	namespace spb {
		namespace au {
			class stack;
		}
	}
}
 
ru::spb::au::stack;
\end{cppcode}
 
Важно отметить, что если внутри пространства имён \cpp'ru.spb.au' нужно использовать что-то из глобалного пространства имён, перекрытое чем-то внутри пространства имён, можно сделать \cpp'::stack'.
 
Собственно, вся стандартная библиотека хранится в пространстве имён \cpp'std'.
 
\section{Линейно упорядоченные контейнеры (\texttt{vector}, \texttt{list})}
 
Линейно упорядоченные контейнеры "--- контейнеры, которые, не внедряясь в реализацию, хранят элементы в линейном постоянном порядке добаления. Требования к типу данных внутри контейнера (должны быть написаны программистом или компилятором следующие публичные элементы):
\begin{enumerate}
	\item Конструктор копирования
	\item Опрератор присваивания
	\item Конструктор по умолчанию
\end{enumerate}
 
\subsection{\texttt{vector}}
 
\cpp'vector' хранит элементы в динамическом массиве подряд в одном куске памяти.
Его поле \cpp'capacity()' описывает текущий размер выделенной памяти, \cpp'size()' "--- количество хранимых элементов.
Они не совпадают для избежания частого расширения массива, массив увеличивается редко, но в сколько-то раз (вспоминаем курс алгоритмов).
 
Интерфейс:
\begin{enumerate}
	\item Добавить в конец новый элемент за $O(1)$ (амортизированно)
	\item Удалить из конца за $O(1)$
	\item Вставка и удаление из середины за $O(n)$
	\item Доступ к $i$-му элементу за $O(1)$
\end{enumerate}
 
\begin{cppcode}
vector<int> a;
a.push_back(1);
a[0] = 2; // Не проверяет границы индекса, очень быстрый
x = a.at(15); // Проверяет границы, может бросить исключение
std::cout << a.size() << " " << a.capacity() << std::endl;
// a.pop_back();
 
a.reserve(200); // capacity = 200, size = 1
a.resize(500); // capacity = size = 500
\end{cppcode}

Задачка: что делает эта строчка? 
\begin{cppcode}
vector<int>(v).swap(v);
\end{cppcode}
Ответ: уменьшает capacity до минимально возможного.

\subsection{Итераторы}

Итератор "--- некоторое обобщение указателя для контейнеров.
Они определены внутри соответствующего им класса и поэтому создаются так:
\begin{cppcode}
class_name::iterator name;
\end{cppcode}
Чтобы не писать такую длинную строку, можно использовать \cpp'typedef':
\begin{cppcode}
typedef class_name::iterator new_name;
\end{cppcode}
или auto (начиная с С++11):
\begin{cppcode}
auto name = other_name.begin();
\end{cppcode}
D каждом контейнере, для которого определён итератор, есть методы \cpp'begin()' и \cpp'end()', которые возвращают итераторы на начало и послеконец соответственно. У любого уважаюшего себя итератра должны быть:

\begin{enumerate}
	\item \cpp'operator ++' (инкремент)
	\item \cpp'operator --' (декремент)
	\item \cpp'operator *'
	\item \cpp'operator !='
\end{enumerate}

В качестве примера можно привести вывод зачений вектора
\begin{cppcode}
for (auto i = v.begin(); i != v.end(); ++i) {
	std::cout << *i;
}
\end{cppcode}

Часто многим методам контейнера можно/нужно передавать в качестве параметра итератор или метод возвращвет итератор на что-либо. Например так:
\begin{cppcode}
auto it = m.find(4);
m.erace(it);
m.insert(it, 5);
\end{cppcode}
для удобства использования есть \cpp'reverse_iterator'. В них операторы \cpp'++' и \cpp'--' инвертированы, 
а методы контейнера \cpp'rbegin()' и \cpp'rend()' возвращают \cpp'reverse_iterator' на конец и доначало соответственно.

\subsection{Инвалидация указателей}

Стоит помнить, что иногда при добавлении/удалении элемента или иных методах, меняющих расположение элементов в памяти, может пройти инвалидация итераторов. Это может стать причиной баги.