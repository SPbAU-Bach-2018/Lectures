\section{Исключения}

Какие бывают ошибки? Выделяют 2 типа:
\begin{enumerate}
	\item происходят в момент исполнения по вине окружения (нехватка памяти, неправильное имя файла, некорректный ввод данных)
	\item по вине программиста, т. е. некорректность программы (например передача нулевого указателя и попытка получения доступа к его полям, нехватка delete)
\end{enumerate}

Требования к программам отличаются, но всегда нужно учитывать ошибки первого типа. Если ставить везде проверки, то это замедляет выполение программы (например вектор с безопасным доступом, вместо массива – накладные расходы на проверку прикаждом обращении по индексу). Язык С++ тратит некоторые ресурсы для проверки ошибок.

\subsection{Assert}

Существует макрос \texttt{assert(bool)}. Если выражение \texttt{true} – ничего, если \texttt{false}, то вызывается функция авариного завершения прграммы.

Например мы пишем функцию \texttt{strlen(char* p)}, пусть мы договорились, что никогда не передаём нулевые указатели:

\begin{cppcode}
int strlen(char* p) {
    assert(p != NULL);
    ...
}
\end{cppcode}

в макросе написано что-то похожее на:
\begin{cppcode}
#define assert(bool) \
#ifdef DEBUG \
if (!bool) exit(); \
#else \
; \
#endif
\end{cppcode}

Т.е. в готовом продукте на месте assert'ов проверок не будет

\begin{Rem}
	assert лежит в <assert.h>
\end{Rem}

Ошибки первого типа нельзя обрабатывать assert'ом, т.к. assert в realise'ной версии не сохранится, а ошибки всё равно могут возникнуть, кроме того если бы он работал всегда, то при проблемах программа просто бы падала --- это не то, что ожидает пользователь.

\textbf{Обработка:}
\begin{enumerate}
	\item сообщени об ошибке
	\item освободить ресурсы (память, открытые файлы)
	\item возобновить работу (например – браузер не вываливается, когда не получает ответа и делает ещё несколько обращений, или другой пример: если неверный ввод, то спросить ещё раз)
\end{enumerate}


\subsection{Обработка ошибок в языке C}
Рассмотрим следующий пример:

\begin{cppcode}
    FILE *fp;
    fp = fopen("a.txt", "+");
    if (!fp) {
         // вывод: произошла ошибка
    }
\end{cppcode}

Так обрабатывались ошибки в C. Какие проблемы могли возникнуть? Файл мог не открыться по двум причинам:
\begin{enumerate}
	\item не существует файл
	\item нет прав доступа
\end{enumerate}

Мы судим по значениям, которые возвращает \texttt{fopen}, а указатель может принять только одно “некорректное” значение \texttt{NULL}, т.е. 2 ошибки никак не обозначить, да и не хорошо это указателем шифровать ошибку.

Или другой пример:

\begin{cppcode}
class Array;
int Array::get(index);
\end{cppcode}

Не понять получили ли мы значение или произошла ошибка.

Ещё пример: функция \texttt{atoi} --- аналогично, во время ошибки 0, но и значение  при аргументе 0 --- 0.

Как с этим разбирались в языке C? Существовала глобальная переменная \texttt{errno}, в которой хранился код ошибки. Но и этот способ тоже не лишён проблем:

\begin{cppcode}
f();
// если забыть здесь проверить errno(), то вызов g() перезапишет значение
g();
\end{cppcode}

Ещё один недостаток постоянных проверок --- загромождедние кода, рядом с каждой функцией возникает \texttt{if}.

Возникают вопросы:

нельзя ли разделить обработку ошибок и код возврата?

нельзя ли из блока с ошибкой переходить в отдельный блок с обработкой?

Вспомним шаблон Model $\la$ View на примере игры крестики-нолики:

\begin{cppcode}
//Model
move(int x, int y, ...) {
     if (на x, y уже стоит фигура) {
         printf("плохой ход");
     }
}

// модель не знает как выводить на экран, поэтому мы должны
// как-то сообщить в view об ошибке, где она будет обрабатываться.

// Model
int move(int x, int y, ...) {    // добавили int как вовращаемое значение
     if (на x, y уже стоит фигура) {
          printf(“плохой ход”);
          return -1;
     }
}
\end{cppcode}

Пример:

\texttt{f()} - обработка $\Ra$ \texttt{g()} $\Ra$ \texttt{h()} - ошибка

Тогда \texttt{g()} выглядит так:

\begin{cppcode}
g() {
     int ret = h();
     if (ret < 0)
          return ret;
}
\end{cppcode}

Хочется писать поменьше такого кода, чтобы если функция не могла обработать ошибку, то выбрасывала её выше.

Предположим мы решили нашё проблему через goto, а \texttt{g()} вглядит так:

\begin{cppcode}
g() {
    MyArray a;
    h();
}
\end{cppcode}

Возникает проблема: мы не освобождаем ресурсы, в коде выше у объекта \texttt{a} не будет вызван деструктор.

Т.е. нам нужен механизм двигающийся по стеку и вызывающий во всех фреймах деструкторы.


В итоге, что мы теперь хотим от обработки ошибок:
\begin{enumerate}
	\item Нужно, чтобы информация об ошибке хранилась в классе, чтобы можно было указать достаточно информации
	\item Разделять код выброса ошибки и код обработки
	\item Передавать управление к блоку обработки, чтобы по пути особождались все стек-фреймы.
\end{enumerate}

\subsection{Обработка исключительных ситуаций в С++}

Рассмотрим синтаксис на примере ниже:
\begin{cppcode}
int f() {
    if (...) {
        throw w; // здесь выбрасываем исключение: throw <любой тип>
    }
}

int g() {
    try {    // блок, из которого могут выброситься исключения
        f();
    }
    catch(<тип ошибки> except) {    // обработка исключений
        ...    
    }
    catch(<тип ошибки> except) {    // catch-блоков сожет быть несколько
        ...
        throw except2;    // из catch-блока тоже можно выбрасывать исключения
    }
}
\end{cppcode}

Так выглядит стек программы:


\begin{tabular}{|c|}
\hline 
f() \\ 
\hline 
g() \\ 
\hline 
main() \\ 
\hline 
\end{tabular}\\

При выбросе исключения мы раскручиваем стек и освобождаем ресурсы.

Если нигде в стеке нет обработчика исключений., программа аварийно завршается.

Для каждого типа ошибок можно создать свой класс и обрабатывать, только их.

Можно отловить все ошибки:
\begin{cppcode}
catch(...) {
    throw;    // т.к. нет переменной исключения, 
                // то чтобы бросить выше исполбзуем throw без параметров.
}
\end{cppcode}

\subsection{Исключения в С++ (лекция Кудинкина)}

\textit{Некоторый материал ниже повторяется с тем, что написано выше, но для целостности конспекта, пусть будет}

C --- errno

В C++ exceptions --- обработать ошибку не там, где она образовалась

\begin{cppcode} 
void foo(...) {
    /* ... */
}

void bar(...) {
    foo(/* ... */);
}
\end{cppcode}

Как узнать об ошибке на С? Возвращаем код ошибки. Если мы в данной функции не можем обработать значение, то возвращаем его выше, если возращаемое значение используется, то вводим дополнительный аргумент через указатель для ошибки.

try-catch С++:
\begin{cppcode}
int foo(...) {
    throw 1;
}

int bar () {
    try {
        foo;
    }
    catch (int e){
        throw e;
    }
}
\end{cppcode}

\subsection{Где нельзя выбрасывать исключения}
Где нельзя выбрасывать исключения?

\subsubsection{try-function block}

Try-function блок подменяет тело функции на try-блок

\begin{cppcode}
void foo() try {
    // ...
} catch (...) {
    // ...
}
\end{cppcode}

Есть ли разница между функциями, приведёнными ниже?

\begin{cppcode}
void foo() try {
    // ...
} catch (...) {
    // ...
}

void foo() {
    try {
        // ...
    } catch (...) {
        // ...
    }
}
\end{cppcode}

Для обычных функций (не конструкторов) разницы нет.

В конструкторах список инициализации идёт после слова try:

\begin{cppcode}
X::X try : i(0), l(1) {
    // ...
} catch (...) {
    // ...
}
\end{cppcode}

Разница для конструкторов, что ошибка могла быть ещё на стадии инициализации полей, поэтому обычный try-catch, внутри тела их не поймает.

\begin{cppcode}
X::X() try : i(0) {
    int *i = new in[1ll << 63];
} catch(bad_alloc x) {
    printf(...);
}
\end{cppcode}

Заметим, что если ошибка произошла в списке инициализации, то какое-то поле объекта непроинициализированно и мы не сможем установить состояние объекта, нельзя будет вызвать деструктор. На данном уровне мы не сможем обработать ошибку, поэтому нужно выбросить наверх, вместо завершения программы, т.к. наверху кто-нибудь сможет его обработать.

Если внутри catch нет throw, то пойманное исключение будет проброшенно наверх.

\subsubsection{Вернёмся к исходному вопросу...}

Вернёмся к исходному: где мы всё-таки не сможем выбрасывать исключения? --- в деструкторе.

Пусть где-то произошло исключение, исключение пробрасывается вверх по стеку, все локакльные объекты должны быть уничтожены, будут вызваны деструкторы (stack unwining). Пусть в деструкторе какого-то объекта произошло исключение, теперь 2 исключения, что делать?