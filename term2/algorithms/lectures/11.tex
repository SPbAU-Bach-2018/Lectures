\setauthor{Дмитрий Лапшин}

\section{Оптимизации Куна}

Пусть есть Алгоритм Куна.
За сколько он найдёт паросочетание размера $K$ в двудольном графе на $V$ вершинах и $E$ рёбрах?
$O(K(V+E))$.

Пусть все степени не более $D$.
Тогда можно улчлшить Кун до $O(K^2D)$: каждый DFS обойдёт не более $K + 1$ вершины первой доли,
так как в паросочетании всего $K$ вершин, а тогда из каждой такой вершины мы рассомтрели $D$ рёбер.
Итого $O(KD)$ на DFS (если мы умеем быстро обнулять метки) и $O(K)$ итераций.

Рассмотрим ещё такой код:
\begin{cppcode}
for (bool run = true; sun; ) {
	run = false;
	used = {0, 0, ...};
	for (int i(0); i != n; ++i)     // |
		if (hasNoPair[i] && dfs(i)) // | O(V + E)
			run = true;             // |
}
\end{cppcode}
Этот алгоритм будет очень жадно улучшать паросочетания, в том числе на первом шаге оно будет работать как жадная эвристика.
Ассимптотика такая же, просто гораздо быстрее.

\chapter{Потоки}
\section{Потоки}

\begin{Def}
	Пусть есть ориентированный взвешанный граф $G = \left<V, E\right>$,
	на котором у каждого ребра есть неотрицательная характеристика $c$ "--- \textit{пропускная способность},
	и две выделенных вершины: исток $s$ и сток $t$.\
	\begin{Rem}
		Можно рассматривать $c$ как функцию $c\colon E \ra [0, \infty)$.
	\end{Rem}
	Потоком называется такая функция $f\colon E \ra \R$, такая, что:
	\begin{enumerate}
	\item
		Поток в каждой вершине, кроме истока и стока, сохраняется:
		\[ \forall v \notin \{s, t\}, \sum_{e \in E\colon v \to u} f(e) = \sum_{e \in E\colon u \to v} f(e) \]

	\item
		Поток не превосходит пропусной способности.
		\[ \forall e \in E, f(e) \le c(e) \]
	\end{enumerate}

	Также мы для работы с потоками введём \textbf{обратные рёбра}.
	Они будут позволять нам понимать, сколько потока можно пустить обратно.
	У каждого ребра $e\colon v \ra u$ будет парное $e'\colon u \ra v$ с нулевой пропускной способностью, причём
	\[ \forall e \in E, f(e') = -f(e) \]
	Также, обратным к обратному ребру будет исходное ($e'' = e$).

	Тогда второе свойство можно перезаписать, используя обратные рёбра: сумма по всем исходящим рёбрам должна быть ноль:
	\[ \forall v \notin \{s, t\}, \sum_{e\in \tilde E\colon v \to u} f(e) = 0 \]
	поскольку все входящие рёбра исходного графа перейдут исходящие, обратные к ним, и с другим знаком.
\end{Def}
\begin{Rem}
	Если мы хотим рассмотреть поток в неориентированном графе, достаточно у обратных рёбер сделать пропускную способность такую же, как у исходных рёбер.
\end{Rem}
\begin{Rem}
	Начиная с этого места обратные рёбра рассматриваются наравне с обычными, если не оговорено иначе.
\end{Rem}
\begin{Def}
	Величиной потока называется сумма по всем исходящим из истока рёбрам:
	\[ |f| = \sum_{e\colon s \ra u} f(e) = -\sum_{e\colon u \ra t} f(e) \]
\end{Def}

Задача максимизации потока: найти поток максимальной величины.
\cimg{11-flow-max.jpg}{}
\begin{Def}
	\textbf{Разрезом} называется дизъюнктное разбиение $V = S \sqcup T$, что $s \in S$ и $t \in T$, то есть:
	мы разбили множество вершин на две группы, при этом исток и сток не лежат в одной группе.
\end{Def}

\begin{Def}
	Величиной разреза называется сумма пропускных способностей рёбер между долями
	\[ c(S, T) = \sum_{\substack{e\colon v \ra u \\ v \in S, u \in T}} c(e)\]
\end{Def}

\begin{Def}
	Величиной потока через разрез называется суммарный поток между долями
	\[ f(S, T) = \sum_{\substack{e\colon v \ra u \\ v \in S, u \in T}} f(e)\]
\end{Def}

Тогда понятно, что
\[ f(S, T) \le c(S, T) \]

\begin{lemma}
	Величина потока через любой разрез равна величине самого потока:
	\[ \forall f, \forall S, T\, |f| = f(S, T) \]
\end{lemma}
\begin{proof}
	Посчитаем сумму потока из всех вершин из $S$.
	С одной стороны, каждая вершина кроме $s$ даст нулевой вклад, и эта сумма равна сумме рёбер из $s$, то есть величине потока.

	Теперь по рёбрам: внутри $S$ сумма потока ноль: каждое ребро имеет обратное, а остались только рёбра через разрез.
	Таким образом, величина потока через разрез равна величине потока.
\end{proof}

\begin{lemma}
	\[ \max |f| \le \min_{\left<S, T\right>} c(S, T) \]
\end{lemma}
\begin{proof}
	\[ \forall f, \forall \left<S, T\right> |f| = f(S, T) \le c(S, T) \]
\end{proof}

\begin{Def}
	Циркуляцией называется поток нулевой величины.
\end{Def}
Например, поток по циклу или пустой поток.

\begin{Def}
	Остаточной сетью на графе с потоком называется новый граф на этих же вершинах, где из пропускных способностей вычли поток:
	\[ \left<G, c\right>_f = \left<G, c - f\right> \]
	В том числе, например, обратные рёбра могут получить положительную пропускную способность, если имели нулевую.
\end{Def}

\begin{Def}
	Дополняющий путь "--- путь из $s$ в $t$, на котором все рёбра имеют меньший поток, чем пропускная способность.
\end{Def}
Заметим, что такой путь позваляет увеличить поток: мы прибавляем что-то ко всем рёбрам пути и вычитаем из всех парных им.
Можно руками проверить все три свойства нового потока.

Это определение можно переформулировать как путь из $s$ в $t$ в остаточной сети.

\section{Теорема и алгоритм Форда"---Фалкерсона}

Следующий алгоритм находит максимальный поток:
\begin{cppcode}
while (ThereIsWay()) {    // Пока есть дополняющий путь в остаточной сети...
	for (auto e: way) {   // ...(ищем через dfs(s))...
		f[e] += 1;        // ...прибавить по всем его рёбрам...
		f[pair[e]] -= 1;  // ...единицу
	}
}
// получили максимальный поток
\end{cppcode}
Время работы: $O(|f| E)$.

Докажем его:
\begin{proof}
	Поскольку поиск дополняющего пути не удался, то есть разрез: что посетил DFS (множество $S$) и не посетил ($T$).
	Заметим, что тогда все рёбра из $S$ в $T$ насыщены, то есть
	\[ |f| = f(S, T) = c(S, T) \]
	А значит получили поток, равный разрезу.
	Значит поток максимальный, а разрез минимальный.
\end{proof}
Между прочим, научились по максимальному потоку находить миниамальный разрез.

Можно немного улучшить Форда"---Фалкерсона: прибавлять максимум из того, что можно пустить по пути.

\begin{theorem}[Теорема Форда"---Фалкерсона]
	Максимальность потока равносильна отсутствию дополняющего пути.
\end{theorem}
Доказательство само возникло по ходу доказательства алгоритма.

\begin{conseq}
	\[ \max |f| = \min_{\left<S, T\right>} C(S, T) \]
\end{conseq}

\begin{Rem}
	Для целых пропукных способностей есть максимальный целочисленный поток.
	Посмотрим, как работает Форд"---Фалкерсон: он на каждом этапе даёт целочисленный поток, значит и в конце тоже будет целочисленный.
\end{Rem}

\begin{lemma}
	Существует максимальный поток.
\end{lemma}
\begin{proof}
	Заметим, что разрезов конечное число, минимальный точно существует.

	Если только целые пропусные способности, то уже всё получилось: запустим наш алгоритм Форда"---Фалкерсона.
	Для вещественного случая можно построить граф, что Форд"---Фалкерсон никогда не остановится.
	Но поможет кое-кто другой...
\end{proof}

\section{Алгоритм Эдмонса"---Карпа}

\begin{cppcode}
while (bfs()) {           // Пока есть кратчайший дополняющий путь...
	df = min{c - f}       // ...взять максимум, что можно прибавить на пути...
	for (auto e: way) {
		f[e] += df;       // ...и прибавить это к каждому ребру
		f[pair[e]] -= df;
	}
}
\end{cppcode}

\textbf{\Large Ниже написано то, чего не лекции не было, но явно должно было быть(Оля)}
Время работы алгоритма $O(VE^2)$
\begin{proof}
Одна итерация поиска пути и проталкивания потока работает за $\O(E)$.

Осталось доказать, что таких итераций будет $\O(VE)$.

Докажем, что расстояние до каждой вершины не убывает после каждой итерации. 
\begin{proof}
    Пусть, после итерации существует вершина, расстояние до которой от s увеличелось. 

    Рассмотрим, ближайшую к s такую вершину. Пусть $\rho_2(v)$ - расстояние до вершины, после
    проталкивания потока. $\rho_1(v)$ "-- ДО.

    Тогда рассмотрим минимальный путь и вершину до v. Пусть это вершина u.

    $\rho_2(u) \ge \rho_1(u)$(Так как v ближайшая плохая вершина).

    Если ребро (u, v) было до итерации, то $\rho_1(v) \le \rho_1(u) + 1 \le \rho_2(u) + 1 = \rho_2(v)$  противоречие.

    Пусть ребро (u, v) появилось после итерации. Значит увелечение потока происходило на пути 
    с ребром v $\to$ u. Значит
    
    $\rho_1(v) = \rho_1(u) - 1 \le \rho_2(u) - 1 = \rho_2(v) - 2$. Противоречие.
\end{proof}

    Если докажем, что каждое ребро может становиться насышеным, не более чем $V$ раз, то
    победа.
    
    После каждой итерации хотя бы одно ребро становиться насышенным, ребер $E$.

    Если ребро (v, u) насытилось один раз, то что бы оно насытилось во второй должно 
    перед этим нужно пройти по ребру (u, v).

    $$\rho_1(v) = \rho_1(u) - 1$$
    $$\rho_2(v) = \rho_2(u) + 1$$
    $$\rho_2(u) > \rho_1(u)$$
    Значит, что бы пройти по ребру еще один раз нужно что бы расстояние до веришины u увеличилось. 
    Максимальное расстояние может быть V и расстояние только увеличивается, значит, насышенным
    ребро будет становиться максимум V раз. Что и требовалось.  
\end{proof}

Этот алгоритм доказывает существование потока для вещественного случая. 
\textbf{\Large Выше написано то, чего не лекции не было, но явно должно было быть(Оля)}

\section{Декомпозиция потока}

\subsection{Не пересекаются по рёбрам}

Задача: найти $k$ различных по рёбрам путей между двумя вершинами.
Скажем, что в старт ограничен поток величины $k$, всё рёбра пропускают 1.
Тогда найдём максимальный поток.
Осталось выделить пути.

\begin{lemma}
	В потоке ненулевой величины есть путь с положительным потоком.
\end{lemma}
\begin{proof}
	Пусть нет такого пути: на лицо разрез нулевой величины.
\end{proof}

Декомпозиция потока раскалдывает его на пути и циркуляцию.
Хотим конечное число путей.
Найдём путь по рёбрам с неотрицательным потоком от истока до стока.
Тогда заберём с этого пути минимум из потоков.
Тогда хотя бы одно ребро <<пересохнет>>.
Это $O(E^2)$.

Осталось понять, как это к нашей задаче.
Всё просто: не могут два пути из декомпозиции пройти по одному ребру, у него всего 1 пропускная способность.
Всего $O(kE)$: мы всё за $k$ шагов сделаем, так как хотя бы на 1 меняем поток.

Разгоним декомпозицию.
\[ T = E \cdot dfs + E \]
Разгоним DFS до $O(V)$.
Пусть он нашёл цикл.
Выкинем весь этот цикл (вычитаем из рёбер максимум по потоку).
Тогда DFS за $O(V)$ или найдёт цикл, или найдёт путь до $t$.

Оптимизация: если мы что-то вычли, нет смысла откатываться вообще назад, продолжим работу.
Тогда при выходе из вершины уже всё, что могли, из неё уже сделали.
Удалим ребро в неё.

\subsection{Вершины не повторяются}
Раздваиваем вершины (вершина переходит в вершина"---ребро"---вершина, у ребра пропускная способность 1).

\subsection{Неориентированные графы}
Тут два способа: или говорим, что у каждого ребра обратное парное имеет такую же (а не нулевую) пропускную способность,
или просто тупо говорим, что ребро распадается на два ориентированных с ещё двумя парными.

Сейчас пользуемся первой идеей.
Если искали рёберно непересекающиеся пути, то решение всё ещё работает.
Только ответ надо правильно выписывать.
Пусть мы прошли по ребру и туда, и обратно.
Но тогда поток по этим двум рёбрам на самом деле нулевой, и при декомпозиции мы увидем немного другие пути, без этих рёбер.
Всё хорошо.

\subsection{По вершинам не пересекаются, неориентированный граф}
Всё работает же: получили ориентировнный граф, раздвоили вершины.

\subsection{Немножко ещё!}
Есть три вершины, нужно из $A$ и из $B$ найти разные пути в $C$. Тут просто пустить поток величины 2.

А ещё есть четыре вершины, и мы хотим найти из $A$ в $B$ и из $C$ в $D$.
И это решается... Никак. Это NP.

\subsection{Паросочетание в двудольном графе}
Добалвяем исток и сток, рёбра из первой доли во вторую.
Чтобы сеть задавала паросочетания, все рёбра из истоки в сток пропускают 1, в середине "--- бесконечно много.
\cimg{11-flow-pairs}{0.5}
Это аж $O(VE)$.

Вспомним, что такое контролирующее множество: построим разрез по максимальному потоку.
Тогда все рёбра через разрез не в середине: они идут или в первую долю, или из второй (в середине пропукная способность бесконечна).
Рассмотрим множество вершин в двух долях, которые являются концами этих рёбер.
\cimg{11-flow-control}{0.5}
Тогда ровно эти вершины будут контроллирующим множеством, причём их будет ровно величина разреза, то есть ровно поток, то есть ровно паросочетание.
Так мы нашли минимальное контроллирующее множество.
Почему они контроллирующее?
Пусть есть ребро паросочетания, не контроллируемое выбранным множеством.
Тогда оно идёт из вершины первой доли, принадлежащей $S$ (так как ребро из $s$ в неё не через разрез), в вершину второй доли, принадлежащей $T$ (так как ребро из неё в $t$ не через разрез).
Но тогда есть путь из $S$ в $T$ по ненасыщенному ребру (середина не может быть насыщена). Противоречие.

Также увидеть контроллирующее множество можно из алгоритма Куна, так как $S$ "--- ровно множество помеченным Куном вершин
(начали из первой доли вершин не в паросочетании, направо шли по прямым рёбрам, обратно "--- по паросочетанию, по обратным к насыщенным рёбрам).

Собственно, тут Форд"---Фалкерсон работает точь-в-точь, как алгоритм Куна.

\section{Масштабирование (Scaling)}

Улучшим любой поиск потока. Сначала ищем пути по $2^k$. Если не нашли "--- уменьшили $k$.

Время: цикл по $k$ за $O(\log U)$ итераций.
Внутри каждая за $O(E)$ DFS-ов: каждый путь пропускает не более, чем $2^{k+1}$ (иначе прошлая итерация ещё не закончилась).
Тогда есть разрез величины не более $2^{k+1}E$.
Тогда мы за $2E$ путей его высушим.

Получили $O(\log U E^2)$.

На вещественных вполне себе тоже норм: только спускаемся до погрешности.
Время
\[ O\left(\log \left(\frac{U}{\epsilon}+1\right) E^2\right) \]

А если толкать сколько найдём, то в реальности оно за $O(E^2)$ работает, что очень быстро.

\section{Заметки о реализации}

Форда"---Фалкерсона пишем, как Куна: прямо по дороге пропускаем поток:
\begin{cppcode}
bool dfs(int v) { // возвращает, нашёл ли путь
	if (was[v]) return false;
	was[v] = true;

	if (v == t) return true; // нашли путь
	for (auto& e: edges[v]) { // по рёбрам из v, в том числе обратным
		if (e.f == e.c) continue; // ребро насыщенно, не идём
		if (dfs(e.u)) { // если по ребру пошли и нашли путь до t
			e.f += 1; // пустили поток по ребру
			e.back->f -= 1; // вычли поток из обратного
			return true;
		}
	}
	return false; // ничего не нашли
}
\end{cppcode}