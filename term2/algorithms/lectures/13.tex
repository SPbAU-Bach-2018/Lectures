\section{Построение суффиксного массива за \texorpdfstring{$O(n)$}{O(n)}}
\setauthor{Глеб Валин}

\subsection{\t{Get} "--- нахождение подстроки}

\subsubsection{Решение, использующее суффиксное дерево}
Напоминание: суффиксное дерево "--- сжатый бор всех суффиксов строки (умеем строить за $O(n)$).

Решим вначале задачу поиска подстроки:

\textbf{Online:}
	\begin{enumerate}
	\item Cтроим суффиксное дерево
	\item Откладываем от корня строчку
	\item Если остались в дереве - ok
	
	Если нужно посчитать число вхождений: $count = size[v]$, где $size[v]$ "--- размер поддерева вершины $v$
	\end{enumerate}

\subsubsection{Решение, использующее суффиксный массив}

Напоминание суффиксный массив (suffix array далее SA) "--- это отсортированный массив суффиксов.

\paragraph{Binary Search:}

Выполним бинарный поиск по SA, как результат мы получим отрезок ($L = lower\_bound, R = upper\_bound$), в котором все суффиксы начинаются с нужной нам строчки.
За сколько это работает?
	\begin{itemize}
		\item $O(\underbrace{|s_i|}_{\text{сравнение}}\underbrace{\log |text|}_{\text{BS}})$ "--- eсли сравнивать строчки просто по символьно
		\item $O(\underbrace{|s_i|}_{\text{предподсчёт хешей}} + \underbrace{\log |s_i| \log |text|}_{\text{сравнение + BS}})$ "--- сравниваем, используя хеши
	\end{itemize}	 

\paragraph{SA + LCP:}

Теперь решим эту задачу, используя SA и LCP.

\subparagraph{Обозначения:}
\begin{itemize}
	\item	$LCP(i, j) = \min_{k \in [i, j + 1)} LCP(k, k + 1)$
	\item $LCP(L, S) = SL$	
	\item $L$ "--- левая граница бинарного поиска
	\item $R$ "--- правая граница бинарного поиска
	\item $M$ "--- середина
\end{itemize}

Будем хранить SA используя массив $p$ (перестановка индексов) типа \texttt{int}, где значение ячейки "--- начало суффикса.

$LCP$ "--- только соседних суффиксов.

Нужно оптимизировать бинарный поиск.

Заметим, что:
 \begin{equation*}
	SM \geq \max
		 \begin{cases}
		  	\min(SL, LM) \\
		   	\min(SR, RM)
		 \end{cases}
\end{equation*}
 
Тогда можно записать следующее:

\begin{cppcode} 
 SM = max(min(SL, LM), min(SR, RM));
 while (s[SM] == m[SM]) {	// пока максимум увеличивается - пусть увеличивается
 	SM++;	
 	if (s[SM] > m[SM])
 		L = M, SL = SM;
 	else
 		R = M, SR = SM;
 }
 \end{cppcode}
 
Нужно за O(1) находить LM и MR. Умеем, используя Фарах-Колтон-Бендера, но будем проще "--- используем дерево отрезков.
Поймём, что отрезок BS "--- это некоторая вершина ДО, тогда построим ДО на суффиксном массиве. Минимум на отрезке хранится в нужной вершине ДО.

Время работы алгоритма: $O(|s_i| + \log |text|)$

\subsection{Построение за SA за \texorpdfstring{$O(n \log n)$}{O(n log n)}}
\textit{Все индексы брать по модулю}

Сейчас мы научились искать подстроку используя SA, научимся же строить SA.

Сделаем все суффиксы одинаковой длины "--- допишем в конец нули. Заметим, что:
\begin{enumerate}
	\item циклические сдвиги строки $s$ "--- это суффиксы строки $ss$.
	\item если их отсортировать и отбросить всё, что будет стоять после дописанных нулей, то мы получим SA
\end{enumerate}

Исходя из этого мы можем сделать следующее: приписать в конец символ \texttt{\#}, который будет самым 'лёгким'  и 
будем рассмотрим Digital Sort циклических сдвигов строки этой строки. 

Digital Sort работает за $O(n(n + \Sigma))$:
\begin{cppcode}
	for (int i = n - 1; i >= 0; ++i)
		countSort(i) // цифровая сортировка по i-ому символу
\end{cppcode}
	
Сейчас наша задача ускорить сортировку. На данный момент сортировка совершает переход: $k \ra k + 1$,  научимся делать $k \ra 2k$.
	
Рассмотрим диапазон $[i, i + k)$: занумеруем его элементы следующим образом:
\[ color[i] < color[j] \Lra strcmp(s + i, s + j,  k) < 0 \]
	
\textbf{База:}

\begin{enumerate}
	\item $O(n + \Sigma)$ "--- Count Sort
	\item Занумеровали
\end{enumerate}
	
\textbf{Переход:}

	Строка длины 	$2k$, состоит из 2х строк длины $k$, сравнить между собой мы их можем за $O(1)$, зная значения $color$ и $p$
	
\cimg{13_img1.png}{}
	%<картинка, иллюстрирующая строчку>
	
	%$2k$: $i$"----"-----$k$"----"-----|"----"-----$k$"----"----|
	
	Тогда, чтобы отсортировать все блоки длины $2k$, их нужно отсортировать по парам значений $\langle color[i], color[i + k] \rangle$
	
	Когда алгоритм останавливается? Когда $k \geq n$ "--- тогда можем сказать, что циклические сдвиги длины $n$ уже отсортированы, что нам и было нужно.

\paragraph*{Реализация:}
\begin{cppcode}
// в конце строки s - терминальный нуль
// n - длина строки с учётм терминального
// t - временный массив, то для цветов, то для нового суфф-массива
// p - суфф-массив
// cnt - счётчик count-sort'а
// color - массив цветов
// C - число различных цветов

for (int i = 0; i < n; ++i)
		++cnt[s[i] + 1];
for (int i = 1; i < 127; ++i)
		cnt[i] += cnt[i - 1];
for (int i = 0; i < n; ++i)
		p[cnt[s[i]]++] = i;
for (int i = 1; i < n; ++i)
		color[p[i]] = color[p[i - 1]] + (s[p[i - 1]] != s[p[i]]);
	
int C = color[p[n - 1]] + 1;
for (int k = 1; k < n; k *= 2) {
		memset(cnt, 0, sizeof(cnt));
	for (int i = 0; i < n; ++i)
			++cnt[color[i] + 1];
	for (int i = 1; i < C; ++i)
			cnt[i] += cnt[i - 1];
	for (int j, i = 0; i < n; ++i) {
			j = (p[i] - k + n) % n;
			t[cnt[color[j]]++] = j;
	}
	
	memcpy(p, t, sizeof(t));
	
	t[p[0]] = 0;
	for (int i = 1; i < n; ++i) // пересчёт цветов
		t[p[i]] = t[p[i - 1]] + (color[p[i]] != color[p[i - 1]] || color[(p[i] + k) % n] != c[(p[i - 1] + k) % n]);
	C = t[p[n - 1]] + 1;
	
	memcpy(c, t, sizeof(t));
}
\end{cppcode}

Приведённая выше сортировка нестабильна, чтобы сделать сортировку стабильной нужно вконце отсортировать 
по этой паре	$\langle color[i], i \rangle$ за $O(n)$ (перебираем строки по $i$ и сортируем подсчётом по $color[i]$).

\subparagraph{Optimize 1:}
\begin{cppcode} 
	if (color[p[n-1]] == n - 1) break;
		// если все строки различные, т.е. и по первым k символам
		// мы их правильно отсортировали
\end{cppcode} 

\subparagraph{Optimize 2:}
\begin{cppcode} 
	if (period < n && period / n) 
		sort(period);
\end{cppcode}

\subsection{Алгоритм Касаи "--- LCP за \texorpdfstring{$O(n)$}{O(n)}}
Алгоритм Касаи позволяет найти LCP для соседних элементов SA.

SA "--- массив $p$, тогда пусть $\tilde{p}[p[i]] = i$ "--- т.е. позиция в суффиксном массиве другими словами обратная перестановка.

Заметим, что:
\begin{enumerate}
	\item $LCP[p[i], p[j]] = \min_{k \in [i, j)} LCP(p[k], p[k + 1])$
	\item если $LCP$ между парой суффиксов больше $1$, то когда мы удалим первый символ "--- порядок суффиксов не изменится:
			\[LCP(p[\tilde{p}[i]], p[\tilde{p}[i] + 1]) = LCP(i, p[\tilde{p}[i] + 1]) > 1 \Ra s[i + 1:] < s[p[\tilde{p}[i] + 1] + 1:]\]

\cimg{13_img2.png}{}
	
	\item у этих же суффиксов без первого символа $LCP$ на $1$ меньше:
		\[ LCP(p[\tilde{p}[i]], p[\tilde{p}[i] + 1]) = LCP(i, p[\tilde{p}[i] + 1]) > 1 \Ra LCP(i, p[\tilde{p}[i] + 1]) = LCP(i + 1, p[\tilde{p}[i] + 1] + 1) + 1 \]
\end{enumerate} 

Теперь, будем вычислять $LCP$ в порядке уменьшения длины суффикса. 

Пусть мы знаем $LCP(p[\tilde{p}[k]], p[\tilde{p}[k] + 1]) = LCP(k, p[\tilde{p}[k] + 1])$, как нам выразить из 
того что записано выше $LCP(k + 1, p[\tilde{p}[k + 1] + 1])$?

\[ LCP(k, p[\tilde{p}[k] + 1]) - 1 = LCP(k + 1, p[\tilde{p}[k] + 1] + 1) =  \]
\[= \min (LCP(k + 1, p[\tilde{p}[k + 1] + 1]),...) \leq LCP(k + 1, p[\tilde{p}[k + 1] + 1]) \]

Из неравенства следует, очередной раз считать $LCP$ нкжно не с первого символа, а с $LCP(k, p[\tilde{p}[k] + 1]) - 1$.
Таким образом, идея следующая: инициализируем начальное значение $LCP$ (в коде ниже обозначена, за \texttt{k}) нулём и увеличиваем, пока можем.

(в коде ниже $\tilde{p} \equiv \texttt{p\_}$)
\begin{cppcode}
for (int i = 0; i < n; ++i) 
		p_[p[i]] = i;		// получаем обратную перестановку

for (int j, k = 0, i = 0; i < n; ++i) {
		j = p_[i];
		if (k > 0) --k;
		while (j + 1 < n && s[i + k] == s[(p[j + 1] + k)])
			++k;
		LCP[j] = k;
	}
\end{cppcode}

\paragraph*{Комментарии для циклических сдвигов:}

\textit{мне кажется что здесь лажа, проосьба: если вам лень исправлять, то хотя бы скажите, как правильно}

Из-за того, что используем, что после удаления символа строки идут в том же порядке, алгоритм не работает 
на циклических сдвигах.

Рассмотрим строчки $s$ и $t$, если это суффиксы, то всегда выполняется 
$s$ < $t$. Если это циклические сдвиги, то  может $s = t$. Пусть сортировка стабильна. 

\cimg{13_img3.png}{}

x -- позиция цикл сдвиг $as$, y -- если удалим $at$, то перейдём

\[ \langle as, x \rangle,  \langle at, y \rangle, as = at  \Ra x < y \]

$i + 1 \ra s$

$j + 1 \ra t$

$y + 1 > x + 1$

Не всегда выполняется, т.к. индексы берутся по модулю.

Нужно добавить в код перед \texttt{while}:
\begin{cppcode}
	if (p[j] == n - 1 || p[j + 1] == n - 1) 
		k = 0
\end{cppcode}

\subparagraph{Время работы:}

Для циклических сдвигов: $(\text{число увеличений \texttt{k}}) \leq n + \text{число уменьшений \texttt{k}} \leq 2n \Ra O(n)$

Для циклических сдвигов: $(\text{число увеличений \texttt{k}}) \leq n + \text{число уменьшений \texttt{k}} \leq 4n \Ra O(n)$


\subsection{Карккайнен-Сандерс. Построение SA за O(n)}
	
	\subparagraph{Время работы:} 
	
	$T(n) = O(n) + T(2/3n) + O(n) \Ra T(n) = O(n)$
	
	$|s| = n$

	$0 \leq s_i \leq 2n$
	
	\subparagraph{Алгоритм (сортировка суффиксов):}	
	\begin{enumerate}
	\item Занумеруем  символы за $O(n)$ "--- перешли к числовому алфавиту. 	Допишем в конец строкеи 3 нуля.
	\item Разобьём на тройки символов, пусть тройка символов "--- новый сивол, т.е. мы получили строку в новом алфавите.
		\[ \forall i \colon s_i s_{i+1} s_{i+2} = w_i \]
		\[ 0 \leq w_i < n \Ra O(n) \]
	Строчку можно представить 3 типами: 
			\begin{enumerate}
				\item $w_0w_3w_6...$ "--- просто вся строка
				\item $w_1w_4w_7...$ "--- без первого символа
				\item $w_2w_5w_8...$ "--- без первых двух символов
			\end{enumerate}
	Суффиксом $n$-ого типа, будем называть суффикс $n$-ого представления строки, 
	можно заметить что в обычном представлении индексы этих суффиксов дают остатки 
	по модулю 3 равные номеру их типа.
	\item Пусть \[ A = \underbrace{\underbrace{w_0 w_3 w_6 \cdots}_{s}  \texttt{\#} \underbrace{w_1 w_4 w_7 \cdots}_{s[1:]}}_ {\frac{2}{3} n} \]
	\item Делаем рекурсивный вызов от $A$, так мы отсортировали суффиксы 
	0-ого и 1-ого типов. На выходе мы получили суффиксный массив для этой строки.
	\item Заметим, что суффикс строки типа 2 "--- это символ + суффикс типа 0 $\Ra$ т.к. положение 
	суффиксов типа 1 известно суффиксы типа 2 можно сортирвоать как пару DigitalSort:
	\[\text{тип 2} = \langle \text{символ}, \text{суффикc A, точнее положение в SA} \rangle \Ra \text{Digital Sort} \Ra O(n)\]
	\item Теперь нужно просто слить 2 отсортированных массива: Merge(Sorted(тип 0-1), Sorted(тип 2)) $\Ra$ $O(n)$

	Какой	как сравнивать? Мы можем использовать преобразование между суффиксами разных типов.

	Если 0 и 2 типы:
	 \begin{equation*}
	\text{их сравнивать умеем: }
		 \begin{cases}
		  	0 \ra 1 \\
			2 \ra 0
		 \end{cases}
\end{equation*}

	Если 1 и 2:
	 \begin{equation*}
	\text{их сравнивать умеем: }
		 \begin{cases}
		  	1 \ra 2 \ra 0 \\
			2 \ra 0 \ra 1
		 \end{cases}
	\end{equation*}
	
	\end{enumerate}	