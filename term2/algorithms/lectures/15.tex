\chapter{Теория чисел}

\section{Системы счисления}

Хотим быстро переводить числа. Будем делать это методом "разделяй и влавствуй".

Пусть в двоичной системе счисления $2n$ цифр.

\begin{cppcode}
Go(A, 2n) 
	calc(2^n) 			// n \log n
	A_1 = div(A, 2^n)		// n \log n
	A_0 = A - A_1 * 2^n 	// n \log n
	x_0 = Go(A_0, n)
	x_1 = Go(A_1, n)
	return x_1x_0
\end{cppcode}

Время работы: $O(n \log^2 n)$

\section{Факторизация}

Хотим разложить число на простые множители.

Лучшее время, за которое умеют сейчас: $O(const^{\sqrt[3]{k}})$, где $k$ "--- длина числа ($\log n$).

\subsection{Алгоритм, основанный на эвристике Полларда O($e^{\frac{1}{4}k}$)}

Рассмотрим две последовательности: $x$, $y$:
\begin{enumerate}
	\item $n = pq, p <= q$
	\item $x_0 = rand()$
	\item $x_{i+1} = f(x_i)$ "--- от 0 до $n-1$, значит зациклится.
	\item $y_i = x_i \bmod p$
	\item Парадокс дней рождений: период $x = \Theta(\sqrt{n})$
	\item $T_p$ "--- период $y = \Theta(\sqrt{p}) = \Theta(n^{\frac14})$
	\item $S_p$ "--- предпериод $y$
\end{enumerate}

\begin{cppcode}
seed
rand()
	seed *= 239
	return seed
f(x)
	return (x^2 + 3) % n
\end{cppcode}

Тогда:
\begin{enumerate}
	\item $diff := x_{S_p + T_p} - x{S_p}$
	\item $diff \vdots p, \not\vdots n$
	\item $gcd(diff, n) \neq 1, n$
\end{enumerate}

\begin{cppcode}
if (not Prime(n))
while (1)
	x_0 = rand()
	i = 0, j = 1
	while gcd(x_j - x_i, n) == 1	// если n не простое, то конечен
		i++, j +=2			// ищем период
	if gcd(x_j - x_i, n) != 0 /*n*/ 	// \log n
		break;
\end{cppcode}

\section{Проверка на простоту}

\subsection{Тест Ферма}

\begin{lemma}
$n$ "--- простое $Ra$ $ \forall a = 1 .. n-1: a^{n-1} \equiv 1 (n) $
\end{lemma}

\begin{cppcode}
test(n)
	a = rand [2...n-1]
	return a^{n-1} % n == 1
\end{cppcode}

Возвращает составное $Ra$ точно составное, иначе может ошибиться.

Числа Кармайкла:

$\forall a = 1 .. n-1: a^{n-1} \equiv 1 (n), но n не простое$

То есть в обратную сторону теорема Ферма не работает.

Если число не является числом Кармайкла, то с вероятностью $ \frac{1}{2} $ алгоритм корректно определит простоту. Но все числа Кармайкла состоят больше, чем из двух простых множителей. Значит, запустим проверку на это перед тестом Ферма. (пользуемся тем, что если число является числом Кармайкоа, то состоит хотя бы из трез множителей, значит, один из них точно меньше кубического корня $n$).

\begin{cppcode}
for (i = 2; i^3 <= n; ++i)
	if (n % i == 0)
		not prime
\end{cppcode}

Теперь ускорим этот алгоритм в $ \log n $ раз: будем делить только на простые числа, их предподсчитаем заранее.

\subsection{Тест Миллер-Рабина}

\[ Time = O(\log n) \]

Определяет простоту с вероятностью $\ge \frac{1}{4}$.

Если $p$ "--- простое, то у уравнения $x^2 \equiv a (p)$ не больше двух решений. (одно, если $a = 0$)

$$ Q(x) = x^2 - a = (x - x_0)(x + x_0); x \neq \pm x_0 Ra Q(x) \neq 0 $$

Т.о., если $ x^2 \equiv 1 (p)$ и $p$ "--- простое, то $x = \pm 1 \Ra$ если найдем другой корень, то число не простое:

\begin{cppcode}
if (abs(y) != 1 && y*y % p == 1)
	p не простое
\end{cppcode}

Рассмотрим $ a^{p-1}, p-1 = 2^st, t "--- нечетное$

$$ a^t -> a^{2t} -> a^{4t} -> ... -> a^{2^st} = a^{p-1} = 1 $$

Берем случайное $a$ и врзвожим в степень $p-1$

Берем первую позицию, где получилась единица, значит, предыдущая не единица, значит, если и не -1, то не простое.

Пояснение: если в конце не 1, то алгоритм и так бы сказал, что не простое, а мы рассматриваем ситуацию, когда алгоритм мог ошибиться.

Итак, узнали рандомизированный алгоритм за $\log n$, существует детерминированный алгоритм за $Poly(\log n)$, но он сложный.

\section{Решето Эратосфена}

\subsection{Классическое: $n \log \log n$}

Берем и вычеркиваем числа:

\begin{cppcode}
for (i = 2; i < n; ++i)
	if !mark[i]
		for (j = i+i; j <= n; j += i)
			mark[j] = 1
\end{cppcode}

Верим, что $k$-тое простое число ~$k \log k$

\subsection{Оптимизация}

\begin{cppcode}
for (i = 2; i^2 <= n; ++i)
	if !mark[i]
		for (j = i^2; j <= n; j += i)
			mark[j] = 1
\end{cppcode}

\subsection{Оптимизированная оптимизация}

\[ Time = O (n) \]

Сейчас проблема в том, что в числа входим несколько раз. Значит, будем хранить минимальный делитель: $d[x]$. Очевидно, что он простой.

Рассмотрим $ y = x * (prime_i <= d[x]) $. Тогда $d[y] = prime_i$; $x$ и $y$ однозначно определены друг через друга.

$p$ "--- массив, в который сохраняем простые числа.

\begin{cppcode}
for (x = 2; x <= n; ++x)
	if !d[x]
		d[x] = x, p[pn++] = x
	for (i = 0; i < pn && p[i] <= d[x] && x * p[i] <= n; ++i)
		d[x * p[i]] = p[i]
\end{cppcode}

\section{Диофантово уравнение}

$$ ax \equiv b (m) $$

Существует решение, если $b$ \vdots gcd(a, m) $Ra$ $ ax_0 + my_0 = (a, m) $

$ Класс решений: x_0 \frac{b}{(a, m)} + \frac{m}{(a, m)} k, где k \in \Z $

Если хотим узнать число, достаточно посчитать его остатки по каим-либо модулям, а потом воспользоваться китайской теоремой об остатках. Пусть $L$ "--- длина числа.

К.Т.О.:

$$ x \equiv a_1 (m_1) $$
$$ x \equiv a_2 (m_2) $$

$$ (m_1, m_2) = 1 $$

Тогда: $$ x = a_1m_2m^{-1} _2 (m_1) + a_2m_1m^{-1} _1 (m_2)  (m_1m_2)  $$

