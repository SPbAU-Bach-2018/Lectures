\chapter{Вероятности и изоморфизм графов}
\setauthor{Дима Кравченко}

\section{Окончание Гаусса}

% Заменить все -> на нормальные стрелочки
\begin{cppcode}
bitset<N> a[N];
int k = 0;
int pos[N];

void AddVector(bitset<N> v) {
    for (int i = 0; i < k; i++) {
        if (v[pos[i]])
            v ^= a[i];
    }

    int i = 0;
    while (i < n && !v[i]) // Эти 3 строки -- поиск любого ненулего бита
        i++;

    if (i < n)
        a[k] = v, pos[k++] = i; // добавили вектор в базис
}
\end{cppcode}

Массив \texttt{pos} отвечает за следующее, \texttt{pos[i]} -- первый ненулевой бит (т.е. координата) у \texttt{i}-го вектора в нашем базисе (\texttt{a[N]}).
\texttt{k} -- их количество на данный момент. Т.е. добавляя новый вектор \texttt{v} в базис, мы смотрим на наши текущие вектора в базисе
(т.е. на данный момент ещё может и не базисе, а просто системе линейно независимых векторов) и, если у нашего вектора есть координата, которая
является первой для какого-то вектора, то надо тот вектор из нашего \texttt{v} вычесть. Т.о. мы приводим нашу матрицу к диагональному виду.
Если после всех таких вычитаний у \texttt{v} осталась какая-то ненулевая координата, то после его добавления наша система попрежнему останется 
линейно независимой, так что добавляем этот вектор.

Восстановление ответа (т.е. решение системы уравнений -- разложение вектора $b$ в нашем базисе):

\begin{cppcode}
x = 0; // x -- bitset
for (int i = k - 1; i >= 0; i--) {
    int j = pos[i];
    x[j] = a[i][N - 1]; // Если записывать A * x = b, то x[j] = b[j]
    for (int t = i + 1; t < k; t++) {
        x[j] ^= x[pos[t]] & a[t][pos[t]];
    }
}
\end{cppcode}


\section{Вероятности}
\subsection{Марковский процесс}

Пусть есть какой-то ориентированный граф c выделенной стартовой вершиной. На каждом ребре написана вероятность перехода по нему, если мы 
стоим в вершине, которая является его началом. При этом, конечно, выполнено $\forall v \in V \; \sum p(v \rightarrow x) = 1$.\\
Наша задача состоит в том, чтобы определить, где мы с какой вероятностью окажемся через $k$ шагов.

\begin{enumerate}
%1
\item Динамическим программирование за $O(k \cdot E)$\\
$$f[k + 1, x] = \sum_{v \rightarrow x} f[k, v] \cdot p_e$$
где $p_e$ -- вероятность перехода по ребру $e$ из вершины $v$, а $f$ -- собственно сами вероятности. Изначально $f$ имеет вероятность 1 на
позиции $s$ ($s$ -- стартовая вершина) и 0 на остальных.
%2
\item $k$ большое $O(\log k \cdot V^3)$\\
Заметим, что
$$f_{k + 1} = P \cdot f_k$$
где $P$ -- полная матрица вероятностей переходов для всех ребер.\\
Тогда мы получаем, что 
$$f_k = P^k \cdot f_0$$
Теперь осталось только возвести $P$ в степень $k$ быстрым возведением в степень за $O(\log k \cdot V^3)$ ($V^3$, т.к. размер матрицы $P$,
как и размер просто матрицы смежности, -- это $V^2$).
%3
\item $k = \infty$\\
\begin{theorem}{}
Утверждение без доказательства --- у такого процесса существует предел.
\end{theorem}
\begin{proof}
Без доказательства
\end{proof}

Существует предел -- в том смысле, что на бесконечности он более-менее зацикливается
(более-менее, т.к. процесс все же случайный и некоторые флуктуации происходить все же могут).\\
Заметим, что мы уже умеем приближенно это решать способом "скажем, что $k = 2^{magic}$ и решим задачу вторым способом за $magic \cdot V^3$".
Это, конечно, хорошо, но можно решать быстре:\\
По сути, нам надо найти такой вектор $f$, что $P \cdot f = f$. Ну заметим, тогда, что $f$ -- собственный вектор
$P$ для $\lambda = 1$. Так же для $f$ должно выполняться, что $f_0 + f_1 + \dots f_{n - 1} = 1$. Задачу поиска собственного вектора для
определенного собсвенного числа можно решать Гауссом за $V^3$, решая систему $(A - \lambda E) \cdot x = 0$. При этом стоит заметить, что 
у метода решения Гауссом есть и свой минус -- потеря точности.
\end{enumerate}

\subsection{Решение СЛАУ -- метод итераций}

Пусть есть СЛАУ вида
$$A \cdot x = b$$
Тогда заметим, что мы можем перепиать это вот так:
$$(A - E + E) \cdot x = b$$
$$(A + E) \cdot x - b = x$$

Тогда будем делать так, возьмем $x_0 = random\_vector$, а дальше делаем
$$x \rightarrow (A + E) \cdot x - b$$
и так пока не сойдется.

Задача -- научиться быстро считать $x \rightarrow Ax + b$ и так $k$ раз\\
$$
\begin{pmatrix}
a_{11} & \dots  & a_{1n} & b_1\\
\vdots & \ddots & \vdots & \vdots\\
a_{n1} & \dots  & a_{nn}  & b_n\\
0 & \dots & 0 & 1\\
\end{pmatrix}
\cdot
\begin{pmatrix}
x_1\\
\vdots\\
x_n\\
1\\
\end{pmatrix}
=
Ax + b
$$

Т.е. просто возводим эту матрицу, дополненную столбцом $b$ и строкой $00\dots01$, в степень $k$ и умножаем на $x$.

\subsection{Алгоритм Видемана}
$$A \cdot x = b,\; b \neq 0$$
За $O(n \cdot k)$, где $k$ -- количество ненулевых чисел в $A$.\\
Если он вам когда-нибудь понадобится, он описан на 287 странице вот этой книжки:\\ 
\href{http://www.ict.edu.ru/ft/002416/book.pdf}{http://www.ict.edu.ru/ft/002416/book.pdf}\\
Кстати, стоит заметить, в этой книге так же описаны и некоторые другие темы из алгебры (например, БПФ).

\section{Проверка на изоморфность}
\subsection{Проверка двух DFA на равенство}
DFA -- конечный детерменированный автомат\\

Нужно проверить 2 автомата на равенство. Т.е. что они равны с точностью до нумерации вершин и ребер.\\

Алгоритм:\\
1. Встали в начальные вершины.\\
2. Запустили синхронный dfs.\\
Если мы нигде не сломались по пути и у каждой вершины в итоге есть пара, то автоматы равны.\\

\subsection{Проверка двух DFA на эквивалентность}
Задача:\\
Проверить эквивалентность двух автоматов. Т.е. что они принимают один и тот же набор строк.
($A_1$ принимает $s \Leftrightarrow A_2$ принимает $s$)\\

Эту задачу будем решать в 2 шага:\\
1. Построить минимальный автомат, эквивалентный $A_1$; минимальный, эквивалентный $A_2$\\
2. Сравним их на равентсво\\
\\

\begin{theorem}{}
$A_1 \sim A_2 \Rightarrow Min A_1 = Min A_2$
\end{theorem}

\begin{proof}
Без доказательства
\end{proof}

\subsection{Алгоритм Хопкрофта}
Построим минимальный автомат, эквивалентный данному:\\
Заметим, что если мы объединим две эквивалентные вершины в одну(эквивалентными называются те, вершины, начиная из которых мы принимаем одно и 
то же множество слов), то новый автомат будет эквивалентен изначальному, т.к. он будет
распознавать все то же множество слов. Будем разбивать множество на классы эквивалентности. Когда мы все разобьем на классы,
эти классы и будут состоянимями нашего нового, уже минимального, автомата. Алгоритм будет следующим:

\begin{enumerate}
\item Построим из матрицы переходов $\updelta(v, a), v \in A, a \in \sum$ обратную матрицу $\updelta^{-1}(v, a) = \{t|\updelta(t, a) = v\}$.
За $\updelta^{-1}(F, a)$ обозначим полный прообраз $F$ при переходе по ребрам с буквой $a$ (т.е. $\{t|\updelta(t, a) \in F\}$)
\item Начальное разбиение множества $B = \{T, V \setminus T\}$,
где $T$ -- множество терминальных вершин, а $V$ -- множество всех вершин автомата.
\item Будем поддерживать множество $L$. Изначально в него положим все пары
$\langle F, a \rangle$ и\\
$\langle V \setminus F, a \rangle, \forall a \in \sum$
\item Пока множество $L$ непусто, извлекаем очередной его элемент $\langle C, a \rangle$ и меняем множество $B$ следующим
образом: берем каждое множество $R$ из $B$ и разбиваем его на 2 -- первое будет множеством $R_1$, т.ч. $\updelta(R_1, a) \in C$, и
множество $R_2$, т.ч. $\updelta(R_2, a) \cap C = \varnothing$. Если они оба не пустые, то в множество $B$, вместо
$R$, войдут $R_1$ и $R_2$ ($R$ из $B$ мы удаляем), а в $L$ нужно будет добавить меньшее из множеств $R_1$ и $R_2$
(т.е. пару $\langle R_1, a \rangle$, если $R_1 < R_2$). Если же кто-то из множеств $R_1$ и $R_2$ оказался пустым, 
то просто оставляем $R$ в $B$, ничего не добавляя в $L$.
\item На выходе получаем множество $B$ -- множество классов эквивалентностей вершин.
\end{enumerate}

\begin{theorem}{}
Можно показать корректность алгоритма:
\end{theorem}

\begin{proof}
Пусть есть вершины $u$ и $v$, которые находятся в одном классе в $B$, но при этом они не эквивалентны. Пусть тогда для какой-то $a \in \sum$ 
их образы неэквивалентны и 
$\updelta(u, a)$ и $\updelta(v, a)$ лежат в разных классах (если они лежат в одном классе, то переидем к рассмотрению $\updelta(u, a)$ и
$\updelta(v, a)$, вместо $u$ и $v$). Рассмотрим тот первый момент времени, когда какой-то единый класс, содержащий $\updelta(u, a)$ и
$\updelta(v, a)$ был разделен на два и эти вершины, $\updelta(u, a)$ и $\updelta(v, a)$, оказались в разных классах. В этот момент одно из
множеств $R_1$ и $R_2$ (содержащие $\updelta(u, a)$ и $\updelta(v, a)$ соответсвенно) было добавленно в $L$. Но это означает, что потом
когда это множество будет извлекатся из $L$, то множество, которое якобы содержит $u$ и $v$ должно было разделится на 2, первое из которых
не содержит вершины $v$, а второе не содержит вершины $u$. Пришли к противоречию.
\end{proof}

Видно так же, что алгоритм остановится, т.к. когда мы разбиваем множество $R$ на $R_1$ и $R_2$, то $|R_1| < |R|$ и $|R_2| < |R|$. Понятно,
что уж как минимум, когда мы дойдем до того, что в $B$ лежат только множества мощности 1, мы уже ничего не будем делить в $B$ и ничего не
будем, соответственно, добавлять в $L$.\\

Этот алгоритм алгоритм работает за $O(n \log n)$. Доказательство, а заодно и сам алгоритм, вы можете прочитать в викикоспектах или же
в оригинальной статье:\\
\href{http://i.stanford.edu/pub/cstr/reports/cs/tr/71/190/CS-TR-71-190.pdf}{http://i.stanford.edu/pub/cstr/reports/cs/tr/71/190/CS-TR-71-190.pdf}
\\

Мы докажем только то, что он работает за $O(|\sum| \cdot n^2)$
\begin{proof}
Заметим, что в каждый момент времени, каждая вершина автомата находится только в одном множестве из $L$. Теперь посмотрим на очередное
множество $C$, которое мы достали из $L$. После того, как мы разделим какой-то $R$ на $R_1$ и $R_2$ (пусть $|R_1| \le |R_2|$) и $R_1$
в $L$. Понятно, что $|R_1| < |R|$. Значит, каждая вершина автомата окажется в каком-то множестве в $L$ не более $n$ раз. Значит, каждое
ребро будет рассмотрено $O(n)$ раз. Всего ребер $O(|\sum| \cdot n)$, а значит и время работы алгоритма составит $O(|\sum| \cdot n^2)$.
\end{proof}

Все, построив алгоритмом Хопкрофта минимальный автомат, эквивалентный первому, $Min A_1$ и так же для второго $Min A_2$, мы проверяем, что
$Min A_1 = Min A_2$

\subsection{Изоморфизм графов}
Проверить, что $G_1$ и $G_2$ совпадают с точностью до нумерации вершин.\\
Эта задача в общем случае имеет субэкспоненциальное решение за $O(2^{\sqrt{n \log n}})$, о чем можно прочитать прямо вот тут:\\
\href{http://en.wikipedia.org/wiki/Graph\_isomorphism\_problem}{http://en.wikipedia.org/wiki/Graph\_isomorphism\_problem}

Но почти всегда за $O(n^3 \log n)$ работает техника измельчения (это то, что мы только что наблюдали в алгоритме Хопкрофта).\\

1. $type_0[v] = 1,$ для каждого $v \in V$\\

2. $map<SortedType> \Rightarrow newType$\\

В конце для каждого типа проверяем, что\\
$count_1[type] \neq count_2[type] \Rightarrow G_1 \neq G_2$.
