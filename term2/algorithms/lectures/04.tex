\section{Персистентность}
\setauthor{Степанов Всеволод}

\subsection{Offline}         

Пусть есть какая-то структура данных, мы хотим ее сделать персистентной "--- научиться уметь отвечать на запросы к 
конкретной версии. 
Пусть мы умеем для каждой операции делать обратную к ней.
Тогда можно легко превратить эту структуру в персистентную, отвечая на запросы \t{Offline}.
Давайте заметим, что версии образуют, подвешенное дерево, корнем которого является исходная 
структура данных, а ребра "--- запросы, создающие новую версию. 
Давайте обойдем это дерево \t{dfs}-ом.
Тогда спуск в ребенка "--- применение какой-либо операции, а подъем из него "--- ее откат. 
Когда мы находимся в вершине, рассматриваем все запросы к версии, которой соответствует данная вершина, 
и отвечаем на них.

\subsection{Garbage Collector}

Задача: есть массив элементов, хотим на нем применять функцию \cpp'memmove(from, to, len)' 
"--- взять отрезок $[from; from + len)$, скопировать его в отрезок $[to, to + len)$.
Хотим научиться решать эту задачу за $O(\log N)$.
Казалось бы, это делается обычным декартовым деревом по неявному ключу "--- просто берем,
с помощью \t{split} выделяем отрезки $[begin; from), [from; from + len), [from + len, end]$ и 
$[begin; to], [to, to + len), [to + len; end)$, после чего склеиваем эти отрезки в порядке 4, 2, 6.

Но обычное декартово дерево с такими запросами справляется плохо, так как при попытке изменить вершину,
которая была уже скопирована, будут изменены две вершины сразу.
Поэтому наше дерево должно быть персистентным. А это значит, что каждый \t{split, merge} будет
выделять дополнительные $O(\log N)$ памяти. 
Но нам нужна каждый раз только одна версия дерева, так что ненужную память надо чистить.
Заметим, что отрезки 1, 3, 5 нам не нужны, они использовались только для того, чтобы выделить
нужные куски массива. 
Но заметим, что нельзя просто рекурсивно обойти деревья, соответствующие этим отрезкам, и их
полностью удалить, так как часть вершин в этих деревьях действительно новые и ненужные, а часть
"--- это те же вершины, что будут и в дереве, полученном \t{memmove}.
Значит, надо каким-то более умным способом понимать, когда какая-то вершина нам не нужна и ее
можно удалить.

Можно заменить указатели на \t{shared ptr}, тогда утверждается, что все будет корректно.
Действительно, если на вершину больше нет никаких ссылок, то это, по сути, означает, 
что она не является ничьим ребенком и нигде в самой программе мы с ней больше не работаем, а,
значит, ее можно спокойно удалить. Несложно понять, что и обратное тоже верно "--- если вершина
не нужна больше, то на нее не должно быть никаких ссылок.

Можно взять и написать то же самое своими руками, чтобы это работало быстрее. 
Для каждой вершины будем хранить переменную,
которая будет говорить нам сколько существует указателей, ссылающихся на данную вершину.
Если на вершину ссылок больше нет, то мы ее будем удалять. 
Удаление вершины будет заключаться в уменьшении количества ссылок у
ее детей на 1 и, собственно, в самом освобождении памяти, занимаемой этой вершиной.

\begin{cppcode}
void decreaseRefCount(Node *v) {
    if (v == Node::null)
        return;
    v->refCount--;
    if (v->refCount == 0) {
        decreaseRefCount(v->l);
        decreaseRefCount(v->r);
        delete v;
    }    
}

Node* memmove(Node *array, int from, int to, int len) {
    Node *a1, *a2, *a3, *a4, *a5, *a6, *result;
    a1, a2, a3 = split(array, from, len);
    a4, a5, a6 = split(array, from, len);
    result = merge(a4, a2, a6);
    decreaseRefCount(array);
    decreaseRefCount(a1);
    decreaseRefCount(a2);
    decreaseRefCount(a3);
    decreaseRefCount(a4);
    decreaseRefCount(a5);
    decreaseRefCount(a6);
    return result;       
}
\end{cppcode}

В приведенной реализации мы предполагаем, что \t{split, merge} возвращают вершины, 
у которых значение счетчика равно 1. Заметим, что надо уменьшить количество ссылок и на
\t{array}, так как нас интересует только результат операции, а то, что было до ее применения
уже не важно. 

\subsection{Persistent Queue}

Можно сразу же получить персистентную очередь, работающую за логарифм, сделав очередь на
персистентном массиве. 
Но можно сделать персистентную очередь, которая будет работать за $O(1)$. 

У нас есть персистентный стек, работающий за $O(1)$ (это, на самом деле, просто дерево).
Казалось бы, раз мы умеем делать очередь на двух стеках, то можно сделать персистентную очередь
на двух персистентных стеках, которая будет работать за $O(1)$. 
Но это, к сожалениию, не так.

Вспомним, как работала очередь на двух стеках. 
В первый стек мы клали элементы, из второго доставали. 
Когда второй стек опустошался, мы начинали доставать элементы из первого стека и добавлять их во 
второй стек, пока не переложим все элементы. Заметим, что это было не чистое $O(1)$, а амортизированное.
А персистентность амортизацию ломает, так как можно взять конкретную операцию, которая будет работать долго,
применить ее, после чего откатить структуру, снова повторить эту операцию, и так далее.

Попытаемся исправить эту проблему. 
Попробуем просто избавиться от амортизации. 
Как это делается? 
Будем брать и переворачивать стек не сразу, а постепенно, каждую операцию перекладывая 
какое-то константное число элементов. 
Назовем стек, из которого мы делаем \t{pop}, $L$, а стек, в который делаем \t{push}, $R$. 
Тогда если $|L| > |R|$, то мы ничего не делаем, а в тот момент, когда $|L| = |R|$, мы начнем переворачивать
стек $R$. 
Проблема в том, что его нельзя переворачивать, так как мы должны еще иногда обрабатывать операции
\t{push} в него. 
Тогда давайте создадим стек $R' = \emptyset$, сделаем \cpp"swap(R, R')".
Теперь $R$ -- пустой стек, в который мы будем делать \t{push}, а $R'$ -- его копия, которую мы будем переворачивать, 
кладя элементы в $R_{rev}$. 
Когда $R'$ опустошится, просто удалим его.

Теперь у нас есть $R_{rev}$ -- перевернутая версия $R'$, который теперь стал пустым и больше нам не нужен, есть стек
$R$, в котором уже, возможно, лежат какие-то элементы, но это нас совершенно не интересует, и есть стек $L$.
Если бы $L$ был бы пуст, то мы просто сказали бы, что теперь мы будем делать \t{pop} из $R_{rev}$, и все было бы хорошо.
Но мы могли не успеть этот стек опустошить, и в нем что-то может лежать.
Это значит, что надо взять и поместить содержимое стека $L$ поверх содержимого стека $R_{rev}$.

К сожалению, это так легко не делается. Но мы можем стек $L$ перевернуть в стек $L_{rev}$, после чего начать доставать из
$L_{rev}$ элементы и класть их в $R_{rev}$. 
Поскольку стек $L$ мы не можем менять, так как мы из него делаем операции \t{pop}, мы создаем стек $L' = L$, который будем
переворачивать. 

Сейчас алгоритм выглядит так: когда мы понимаем, что хотим перевернуть стек $R$, мы его меняем с пустым стеком $R'$,
создаем $L'$ -- копию $L$, достаем элементы из $R'$, кладя их в $R_{rev}$, а из $L'$ кладем в $L_{rev}$, после чего из стека
$L_{rev}$ будем доставать элементы и класть их в $R_{rev}$. 
Стоит заметить, что нам не важно, сколько побочных операций мы будем делать помимо операций \t{push, pop}, нам лишь хочется,
чтобы это число было какой-то константой, не от чего не зависящей, эту константу мы установим чуть позже.

Но и это, еще не конечная версия алгоритма. Пока мы делали все эти операции, из стека $L$ мы могли какие-то элементы достать,
таким образом, в финальной версии $R_{rev}$ у нас будут какие-то лишние элементы. 
Но заметим, что, элементы, которые мы с вершины стека $L$, в стеке $L_{rev}$ находятся в самом конце.
Тогда можно взять и просто завести переменную $popcount$, в которой будем хранить, сколько элементов из стека $L$ мы успели достать, пока делали
все эти операции, и последние $popcount$ элементов из $L_{rev}$ просто не будем доставать и класть в $R_{rev}$.

После того, как мы сконструировали корректный стек $R_{rev}$, мы его меняем местами со стеком $L$, который нам больше не нужен, и который можно будет
удалить, после чего считаем, что переворачивание закончено.

Теперь надо аккуратно сформулировать, какие инварианты мы хотим поддерживать, и понять, сколько же именно операций надо делать каждый раз кроме
\t{push, pop}.
                
Во-первых, надо понять, сколько дополнительных операций надо делать каждый раз, чтобы мы все успели перевернуть к моменту опустошения $L$.
Всего нам надо сделать $|L| + |R| + |L| - \#$\t{pop} операций, а, поскольку мы начинаем переворачивать стек в момент, когда $|L| = |R|$, то
надо сделать не более $3|L|$ операций, то есть, по 3 дополнительных операции на каждую операцию \t{push, pop}.

Во-вторых, после того, как мы стек перевернем, должно выполняться $|R_{rev}| \ge |R|$, иначе получится, что мы уже опять должны были начать переворачивать
стек, а мы этого еще не делали.
$|R_{rev}| = |R_{old}| + |L_{old}| - \#$\t{pop}$, |R| = \#$\t{push}. 
Заметим, что $L_{old} = R_{old}$, так как мы начали переворачивать в момент, когда наступило равенство.
Откуда $2|L_{old}| \ge \#$\t{push} $+ \#$\t{pop}.
Это значит, что количество операций, через которое мы полностью перевернем стек, не должно превышать $2L_{old}$. 
Но уже было показано, что если мы каждый раз будем делать 3 дополнительных операции, то мы сможем перевернуть
стек за $|L_{old}|$ запросов к очереди, так что этот инвариант тоже будет соблюден.

Итого, у нас есть стеки $L, R$, из первого мы достаем элементы, во второй кладем, есть флажок $isReversing$, который показывает, переворачиваем мы сейчас
стек $R$, или нет.
Если мы его переворачиваем, то возникают дополнительные стеки $L', R'$ -- копии $L, R$ на момент начала переворота, при этом стек $R$ мы делаем пустым,
стеки $L_{rev}, R_{rev}$ -- результат переворота $L', R'$, переменная $popCount$, которая будет показывать, сколько раз мы сделали операцию \t{pop} за время 
переворота стека, то есть, сколько элементов со дна $L_{rev}$ мы должны проигнорировать.

А вот так выглядит псевдокод работы с персистентной очередью.

\begin{cppcode}
void startReverse(){
    isReversing = 1;
    L' = new Stack();
    swap(L, L');
    R' = R; //такое присваивание в случае персистентного стека -- ОК
    R_rev = new Stack();
    L_rev = new Stack();    
    popCount = 0;
}

void doSth(){
    if (R'->size())
        R_rev->push(R'->pop());
    if (L'->size())
        L_rev->push(L'->pop());
    if (L'->size() == 0 && R'->size() == 0) 
        if (L_rev->size() > popCount())
            R_rev->push(L_rev->pop());
        else{
            isReversing = 0;
            swap(L, R_rev);
            delete R_rev;
            delete L_rev;
            delete R';
            delete L';
        }           
}

void push(int a){
    R = R->push(a);
    if (L->size() == R->size())
        startReverse();
    FOR(i, 3)
        if (isReversing)
            doSth();
}

int pop(int a){
    int res = L->pop();
    if (L->size() == R->size())
        startReverse();
    FOR(i, 3)
        if (isReversing)
        {
            popCount++;
            doSth();
        }
}
\end{cppcode}

\begin{Rem}
    Функция \cpp'doSth' делает каждый раз либо одну, либо две дополнительных операции, поэтому, чтобы
    все работало корректно, ее надо вызвать 3 раза. 
    Так же стоит заметить, что приведенная реализация, на самом деле, работает за амортизированное $O(1)$, так как
    \cpp'delete L_rev' будет работать за $O(popCount)$. 
    Этого можно избежать, добавив в \cpp'doSth()' еще и простое опустошение стека $L_{rev}$, от этого может лишь несколько
    увеличиться константа, но зато очередь гарантированно будет работать за $O(1)$.

\end{Rem}

\subsection{Persistent RBST}

Хотим сделать персистентный \t{Treap}. Казалось бы, можно просто брать и каждый раз не менять вершину, а 
создавать ее копию и работать с ней. Но тогда у нас в какой-то момент может взять и сломаться балансировка.
А именно, у нас могут появляться одинаковые $y$ у вершин. 
Более того, если мы будем делать запросы вида \cpp'r=merge(r, r)' кучу раз, то таких вершин будет реально много.
Пусть у нас была такая реализация \t{merge}:
\begin{cppcode}
Node *merge(Node *a, Node *b){
    if (a->y >= b->y) {
        a->r = merge(a->r, b);
        return a;
    } else {
        b->l = merge(a, b->l);
        return b;
    }
}   
\end{cppcode}
То после повторения в цикле такой операции: \cpp'r=merge(r, r)', мы получим бамбук, направленный вправо.
Пусть мы повторили эту операцию $m$ раз, тогда размер дерева стал $2^m$, и его глубина тоже стала $2^m$ 
вместо желаемой $m$.

Решение этой проблемы достаточно простое. Просто не будем хранить $y$ в вершине. 
Вспомним, зачем нам нужны были случайные $y$. 
Мы говорили, что если все $y$ будут случайными, то полученное дерево тоже будет случайным, то есть каждая вершина
будет корнем с одинаковой вероятностью. 
Ну давайте это возьмем и реализуем.

\begin{cppcode}
Node *merge(Node *a, Node *b){
    if (a->size / (a->size + b->size) >= rand() / RAND_MAX) {
        a->r = merge(a->r, b);
        return a;
    } else {
        b->l = merge(a, b->l);
        return b;
    }
}   
\end{cppcode}

Рассмотрим все вершины, входящие в $a$ и $b$. 
Мы хотим, чтобы корень был случайной вершиной. 
Тогда вероятность того, что корень будет лежать в $a$ это как раз и есть $a->size / (a->size + b->size)$, то есть данный
код нам как раз дает RBST.
         
         
