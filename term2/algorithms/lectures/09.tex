\chapter{Euler Tour Trees, Heavy-Light Decompostion}
\setauthor{Ольга Черникова}

\section{Euler Tour Trees}
\subsection{Определение.}
Euler Tour Trees "--- это структура данных, которая в лесу обрабатывает запросы
\begin{enumerate}
	\item \cpp'Link(a, b)' "--- провести ребро
	\item \cpp'Cut(a, b)' "--- удалить ребро
	\item \cpp'IsConnected(a, b)' "--- проверить, что две вершины лежат в одной компоненте
\end{enumerate}
Все операции за $O(\log n)$.

\subsection{Что нужно хранить.}

Для реализации этой структуры будем хранить Эйлеров обход по ребрам в декартовом дереве.

\begin{center}
\includegraphics[width=2in]{im09_1.jpg}
\end{center}

Так же необходимо хранить:
\begin{enumerate}
	\item Для каждой вершины множество ребер(\cpp'set<edge> edges[v]')
	\item Для всех ребер хранить обратное('\cpp'rev[e]', но можно и без них)
	\item Для ребра ссылку на узел в декартовом дереве.(\cpp'node[e]')
	\item В узле хранить указатель на правого и левого ребенка и на предка
\end{enumerate}

\subsection{Реализация.}

\subsubsection{\texttt{Get(v)} "--- узнать, в какой компоненте вершина}

Вершина $\to$ любое выходящее ребро $\to$ \cpp'node *' $\to$ корень дерева.
\begin{enumerate}
	\item Для вершины хранится \cpp'set<edge>', выбираем любое ребро
	\item По ребру переходим в узел в декартовом дерве
	\item Поднимаемся по предкам к корню дерева.
\end{enumerate}

\subsubsection{\texttt{MakeRoot(v)} "--- сделать корнем вершину}

\begin{center}
\includegraphics[width=2in]{im09_2.jpg}
\end{center}

Если корень вершина $A$, то ейлеров обход выглдяит так: 1 2 3 4 5 6.
Если корень вершина $B$: 4 5 6 1 2 3.
Для того, что бы сделать корнем другую вершину, нужно просто сделать циклический сдвиг.

Вершина $\to$ любое выходящее ребро $\to$ \cpp'node *' $\to$ позиция в декартовом дереве $\to$ циклический сдвиг.

\subsubsection{\texttt{Link(a, b)} "--- провести ребро}

\begin{enumerate}
	\item \cpp'MakeRoot(a)'
	\item \cpp'MakeRoot(b)'
	\item Выпишем компоненту вершины $a$
	\item Проведем ребро $ab$
	\item Выпишем компоненту вершины $b$
	\item Проведем ребро $ba$
\end{enumerate}

\subsubsection{\texttt{Cut(a, b)} "--- удалить ребро}

\begin{center}
\includegraphics[width=2in]{im09_3.jpg}
\end{center}

По $ab$ находим позиции ребер (прямого и обратного) в массиве.
Разделяем массив на три части и склеиваем первую и последнюю.

\section{Haevy-Light Decomposition}

\subsection{Определение.}

Хотим покрыть дерево вертикальными путями так, что бы каждая вершина лежала ровно в одном.

\begin{center}
\includegraphics[width=2in]{im09_4.jpg}
\end{center}

LCA разбивает путь на два вертикальных.

Что бы посчитать функцию, нужно посчитать функцию на двух вертикальных путях.

\begin{center}
\includegraphics[width=2in]{im09_5.jpg}
\end{center}

\begin{Def}
	Назовем прыжком переход от одного пути в разбиении к другому.
\end{Def}

В Haevy-Light Decomposition $k$ "--- количество прыжков на любом вертикальном пути
\[ k \le \log n \]

\subsection{Конструкция.}
\begin{Def}
	Ребро $ba$ назовем тяжелым($b$ "--- предок $а$), если
	\[ size[a] > \frac{1}{2}size[b] \]
\end{Def}
\begin{Def}
	Не тяжелые ребра называются легкими.
\end{Def}

У каждой вершины не более одного тяжелого ребра.
Пути состоят только из тяжелых ребер.
И все тяжелые ребра лежат в путях.

Прыжков не более $\log$, когда мы делаем прыжок, мы переходим по легкому ребру, значит, размер поддерева удваивается хотя бы в два раза.

\subsection{Реализация.}

\begin{cppcode}
// no[v] - номер пути, котором лежит вершина
// pos[v] - номер вершины в этом пути
// p[v] - отец вершины v
build(int v) {
	if (p[v] != -1 && 2 * size[v] > size[p[v]]) {
		no[v] = no[p[v], pos[v] = pos[p[v]] + 1;
	} else {
		top[cnt] = v;
		no[v] = cnt++;
		pos[v] = 0;
	}
	for (int x: childs[v])
		build(x);
}

get(a, LCA) {
	while(no[a] != no[LCA]) {
		Tree[no[a]].get(0, pos[a]);
		a = p[top[no[a]]];
	}
	Tree[no[a]].get(pos[LCA], pos[a]);
}
\end{cppcode}

Время работы: построение $O(n)$, запрос $O(\log^2 n)$, обновление в точке $O(\log n)$.

\begin{Rem}
	Когда мы решаем задачу, нужно сначала решить задачу на массиве, а потом обобщить.
\end{Rem}

Если нет запросов на обновление, то heavy-light, чаще всего, не нужен.

\section{Level Ancestor}

\begin{Def}
	\[ LA(v, k) = parent^{(k)}(v) \]
	Необходимо найти $k$-ого предка вершины $v$.
\end{Def}

Теперь как мы уже умеем решать эту задачу.
\begin{description}
\item[Offline:]
	$O(n)$
	Обходим дерево, когда мы находимся на вершине $v$, знаем для нее всех предков и все запросы.

\item[Online:]
	\begin{enumerate}
	\item
		$\left<n\log n, \log n\right>$ "--- двоичные подъемы.

	\item
		$\left<n^2, 1\right>$ "--- полный предподсчет.

	\item
		$\left<n, \log n\right>$ "--- heavy-light (нужно либо прыгнуть в следующий путь за $O(1)$,
		либо один раз взять соответствующий элемент в массиве на пути).
	\end{enumerate}
\end{description}

\subsection{Решение за \texorpdfstring{$\left<n\log n, 1\right>$}{<n log n, 1>}}

Различные способы разбить на пути:
\begin{description}
	\item[Heavy-Light]
	\item[Longest-Path] Будем продолжать путь в более глубокое поддерево.
	\item[Ladder] Из любой декомпозиции можно сделать лестницу. Есть путь длины $L$, продолжим этот путь на $L$ наверх. Теперь пути перекрываются.
\end{description}

\[ LA = \text{Двоичные подъемы} + \text{Ladder"---Longest-Path} \]

Прыгнем на самый большой возможный прыжок $s$. $2^s \le k < 2^{s + 1}$.

Теперь достаточно сделать один прыжок в Ladder"---Longest-Path.

Вниз можем спуститься хотя бы на $2^s$, значит, наверх он продлен хотя бы на эту величину.
Значит мы с предком на одном пути.

\subsection{Решение за \texorpdfstring{$\left<n, 1\right>$}{<n, 1>}}
Задача  соптимизировать двоичный подъем.

$\left<M\log n, 1\right>$
$M$ "--- количество листьев. Можем помнить любой лист в поддереве и теперь можем прыгать от этого листа.

$\left<M\log n\right>$ прыжков в Offline. $\left<leaf, 2^k\right>$. От каждого листа посчитать на $2^k$ прыжков.

$\left<M\log n + n, 1\right>$
Наша цель сделать $M \le O(\frac{n}{\log n})$
Сжатие деревьев.

\begin{center}
\includegraphics[width=2in]{im09_6.jpg}
\end{center}

Хотим разбить вершины на поддеревья размера не больше $k$.
Просто так это сделать сложно, поэтому разрешим корню поддерева не принадлежать данному куску.

$\frac{k}{2} < size \le k$. Верно для всех кусков кроме корня.
Тогда количество кусков $\frac{n}{k/2} + 1$.

\begin{center}
\includegraphics[width=2in]{im09_7.jpg}
\end{center}

\begin{cppcode}
Compress(v) {
    for (v -> x) Compress(x)
}
\end{cppcode}

\[ k \le \frac{\log n}{16} \]

Вершина лежит в куске.
Знаем тип куска и позицию в куске.
Различных типов мало.
Для вершины за $O(1)$ хотим прыгать на $k$ вверх.
Предподсчет.

\includegraphics[width=2in]{im09_8.jpg}

$\lra 0010011101$
