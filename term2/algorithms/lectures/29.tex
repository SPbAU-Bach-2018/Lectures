\section{RSA}
\setauthor{Егор Суворов}
Мотивация: всем известны системы, в которых для шифрования и дешифрования нужен один и тот же секретный ключ (например, XOR с ключом).
Однако бывает и асимметричное шифрование: есть отдельные ключи для шифрования и дешифрования, можно распространять только один.
Тогда, например, можно ключ для шифрования оставить у себя, а ключ для дешифрования отдать всем "--- тогда можно будет проверять, что автор сообщения действительно имеет при себе <<секретный ключ>>.
Система RSA "--- один из первых примеров такого шифрования и пример, зачем модульная арифметика нужна в <<реальной жизни>>.

У системы RSA есть один основной параметр: большое число $n$ (модуль).
Сообщениями являются вычеты по модулю $n$.
Для шифровки сообщения выбирается некоторое число $e$ (<<открытая экспонента>>), сообщение $m$ шифруется так:
\[ m_{enc} = m^e \mod n \]
Ключом для шифрования является пара $(n, e)$, а само шифрование можно выполнить при помощи быстрого возведения в степень.
Теперь попробуем расшифровать.
Попробуем найти такое $d$, что $(m^e)^d = m \mod n$.
\begin{gather*}
(m^e)^d = m \mod n\\
m^{ed} = m \mod n\\
ed = 1 \mod \phi(n)
\end{gather*}
Зная $e$ и $\phi(n)$ при помощи алгоритма Евклида несложно найти требуемое $d$.
Заметим, что это верно даже в случае $m=0$ (просто получаются везде нули).
Таким образом, ключом для дешифрования является пара $(n, d)$.

Вопрос в том, насколько эта система надёжна (в частности, по одной паре нельзя получить другую) и при каких значениях $n$.
Вообще говоря, пары симметричны (экспонента в одной является обратной к другой) и при наличии одной пары и $\phi(n)$ мы легко вычисляем вторую.
Значит, надо, в частности, затруднить вычисление $\phi(n)$.
Из-за этого выбирать $n$ простым плохо: $\phi(p)=p-1$.
Точно так же плохо выбирать $n$, которое хорошо факторизуется: факторизуем $\Ra$ узнаем $\phi(n)$.
Обычно выбирают $n=pq$, где $p$ и $q$ "--- большие простые числа примерно одинакового размера.
В таком случае получается $\phi(n) = (p-1)(q-1)$.
Утверждается, что в таком случае уже достаточно сложно получать сообщение по $m^e$, зная только $(n, e)$.

\begin{theorem}
	Задачи факторизации числа $n$ и представления $n$ в виде $n=pq$ (где $p,q > 1$) эквивалентны,
	то есть одну можно свести к другой за полиномиальное время.
\end{theorem}
\begin{proof}
\begin{itemize}
\item
	Если у нас есть факторизация $n$, то представить его в виде $n=pq$ можно очевидным образом: берём любой нетривиальный делитель $n$, называем его $p$, а $q=\frac np$.
	Всё это можно сделать за полиномиальное время.
\item
	Если у нас есть оракул, который умеет представлять $n$ в виде $n=pq$, то мы можем факторизовать $n$ рекурсивно: вызвали оракула, запустили факторизацию от $p$ и $q$.
	Можно построить бинарное дерево рекурсивных вызовов, в листах которого будут простые числа и заметить, что внутренних вершин не больше, чем листьев.
	То есть вызовов оракула будет не больше, чем простых делителей у $n$ (с учётом кратности), то есть не более $\log n$.
\end{itemize}
\end{proof}

\begin{theorem}
	Если $n=pq$, где $p$ и $q$ простые, то задачи вычисления $\phi(n)$ и факторизации $n$ эквивалентны.
\end{theorem}
\begin{proof}
	По факторизации очевидно можно построить $\phi(n)$.

	А если у нас есть $a=\phi(n)=(p-1)(q-1)$, то:
	\begin{gather*}
	a=(p-1)(q-1) \\
	a=pq-p-q+1 \\
	a=n-p-q+1 \\
	q=n-p-a+1 \\
	\begin{cases}
	q=n-p-a+1 \\
	n=pq
	\end{cases}
	\Ra
	n = p(n-p-a+1) \\
	n = p(n-a+1)-p^2 \\
	p^2 + p(a-n-1) + n = 0 \\
	\end{gather*}
	Получили квадратное уравнение на $p$, его можно честно решить по формуле.
	Получим два решения: $p$ и $q$.
\end{proof}

\section{Первообразные корни}

Рассмотрим систему вычетов по простому модулю $p$.
Мультипликативная группа по модулю $p$ состоит из ровно $p-1$ элемента "--- это просто все не-нули.
Однако с точки зрения умножения её так описывать не слишком удобно.

\begin{Def}
$g$ называется \textit{первообразным корнем} по модулю $p$, если любой ненулевой вычет $x$ можно представить в виде $x=g^k$ для некоторого $k$.
\end{Def}

\begin{theorem}\label{PrimitiveRootExists}
По простому модулю $p$ существует хотя бы один первообразный корень.
\end{theorem}
\begin{Rem}
На самом деле первообразные корни также существуют и по модулям 2, 4, $p^k$ и $2p^k$.
По модулю 2 его найти просто "--- это единица.
\end{Rem}

\begin{theorem}\label{PrimitiveRootIff}
$g$ "--- первообразный корень тогда и только тогда, когда среди чисел $g^1$, $g^2$, \dots, $g^{p-1}$ единица встречается в первый раз на месте $g^{p-1}$.
Заметим, что $g^{p-1}=1$ всегда по малой теореме Ферма (или теореме Эйлера).
\end{theorem}
\begin{proof}
\begin{description}
\item[$\Ra$]:
	Если для некоторого $k$ имеем $g^k=1$, то у нас $g^x$ принимает всего $k$ различных значений (так как после $k$ всё зацикливается).
	Значит, $k \ge p - 1$ по определению первообразного корня.
	С другой стороны, $k \le p - 1$, так как $g^{p-1}=1$.
\item[$\La$]:
	Пусть $g$ не является первообразным корнем, тогда какое-то число не встретилось в последовательности степеней, значит, какое-то встретилось дважды,
	то есть:
	\begin{gather*}
	\exists 1 \le k_1 < k_2 \le p - 1\colon g^{k_1} = g^{k_2} \\
	g^{k_1} = g^{k_2} \\
	g^{k_1-k_1}= g^{k_2-k_1} \\
	g^0 = g^{k_2-k_1} \\
	1 = g^{k_2-k_1} \\
	\end{gather*}
	То есть получаем, что единица должна была встретиться уже на месте $k_2-k_1$, что строго меньше $p-1$, противоречие.
\end{description}
\end{proof}

\begin{theorem}
В мультипликативной группе по модулю $p$ есть ровно $\phi(p-1)$ первообразных корней.
\end{theorem}
\begin{proof}
По теореме \ref{PrimitiveRootExists} хотя бы один корень точно есть, назовём его $\omega$.
Давайте возьмём какое-нибудь число из мультипликативной группы, скажем, $\omega^k$.
По теореме \ref{PrimitiveRootIff} оно будет являться первообразным корнем тогда и только тогда, когда в последовательности $(\omega^k)^1$, $(\omega^k)^2)$, $\dots$ единица в первый раз встречается на месте $p-1$:
\begin{gather*}
(\omega^k)^a = 1 \mod p \\
\omega^{ka} = 1 \mod p \\
\omega^{ka} = \omega^0 \mod p \\
ka = 0 \mod (p-1)
\end{gather*}
Минимальное ненулевое $a$, являющееся решением, равно $\frac{p-1}{\gcd(k, p-1)}$, что равно $p-1$ только в случае взаимной простоты $k$ и $p-1$.
Таким образом, существует всего $\phi(p-1)$ различных $k$, которые являются первообразными корнями.
Обращаю внимание, что тут нам совершенно неважно, какой именно первообразный корень взять в начале "--- мы пользуемся тем, что существует какой-нибудь и что остальные через него выражаются.
\end{proof}

Давайте научимся искать первообразный корень.
\subsection{Поиск <<в лоб>>}
	Например, можно искать его <<в лоб>>: перебираем вычеты от меньших к большим и для каждого проверяем условие теоремы \ref{PrimitiveRootIff}.
	Очевидно, что это будет работать за $O(pg)$, где $g$ "--- минимальный первообразный корень, но на самом деле это даже $O(p)$ (без доказательства).

\subsection{Быстрая проверка}
	Чтобы ускорить, давайте для начала научимся быстрее проверять первообразность.
	В каких вообще случаях может так случиться, что $g^a=1$ (и $a$ минимально), при условии, что $g^{p-1}=1$?
	Вспомним доказательство теоремы \ref{PrimitiveRootIff}: такое $a$ имеет вид $\frac{p-1}{d}$, где $d$ "--- некоторый делитель $p-1$.
	Но тогда $g^{ak}=1$ для любого $k$.
	То есть, вообще говоря, достаточно будет проверить, что $g^a \neq 1$ для всех $a$ вида $\frac{p - 1}{p_i}$, где $p_i$ "--- простые делители $p-1$.
	Если нам известна факторизация $p-1$ и в ней $m$ различных простых делителей, то быстрым возведением в степень для каждого мы можем проверить, что $g^a \neq 1$,
	получим асимптотику $O(m\log p)$.
	Очевидно, что $m = O(\log p)$ (так как каждый простой делитель хотя бы 2) и получается оценка $O(\log^2 p)$.
	Хотя на самом деле, конечно, различных простых сильно меньше логарифма (в среднем их $O(\log \log n)$, теорема Харди-Рамануджана).
\begin{cppcode}
int powmod(int a, int b, int mod);

int p;
vector<int> p1_divisors; // простые делители p-1

bool check(int g) {
    for (int x : p1_divisors) {
        if (powmod(g, (p - 1) / x, p) == 1) {
            return false;
        }
    }
    return true;
}
\end{cppcode}

	Теперь мы можем находить ответ за $O(g \log^2 p)$.
	Гипотеза: первообразный корень не больше, чем $O(\log p)$ (без доказательства).
	То есть уже умеем за $O(log^3 p)$:
\begin{cppcode}
int g = 2;
while (!check(g)) g++;
\end{cppcode}

\subsection{Рандомизированный алгоритм}
	Так как мы знаем, что корней всего $\phi(p-1)$, то тыкая в случайное число, мы попадаем с вероятностью $\frac{\phi(p-1)}{p-1}$.
	Значит, матожидание числа шагов "--- $\frac{p - 1}{\phi(p-1)}$.
	Если $p-1=p_1^{k_1}p_2^{k_2}\dots$, то $\frac{p-1}{\phi(p-1)} = \frac{p_1p_2}{(p_1-1)(p_2-1)\dots}$, что довольно немного.
	Непример, если у $p-1$ мало простых делителей (например, такое бывает при выборе модуля для Фурье вида $p=2^k \cdot l$), то это совсем быстро.
	А точнее, $\frac{p-1}{\phi(p-1)} = O(\log \log (p-1))$ (без доказательства).
	На каждом шаге проверка за $O(\log^2 p)$, вообще красота, получаем честный рандомизированный $O(\log^2 p \log \log p)$
\begin{cppcode}
for (;;) {
    g = randint(1, p - 1);
    if (check(g)) break;
}
\end{cppcode}

\section{Дискретное логарифмирование}
У нас появились первообразные корни.
Разумеется, хочется научиться по числу $a$ и первообразному корню $g$ быстро находить такое $k$, что $a=g^k$.
Можно немного обобщить и получим задачу дискретного логарифмирования по произвольному модулю $m$ и произвольному основанию $x$.

Решение <<в лоб>> "--- возвести число $x$ (основание) во все степени от $0$ до $\phi(m)-1$, посмотреть, получилось или нет.
На самом деле нам даже не надо знать $\phi(m)$ "--- просто по очереди перебираем степени, пока не зациклимся, а зациклиться мы можем, только встретив единицу.
Получаем время работы $O(\phi(m))$ (даже если не знаем $\phi(m)$).

Теперь применим сюда meet-in-the-middle (можно также рассматривать как корневую оптимизацию), получим алгоритм Шенкса (baby-step giant-step).
Идея такая: давайте искать ответ не в виде $a=x^k$ (где $0 \le k$), а в виде $a=x^{pt+q}$, где $t$ "--- некоторая константа, $0 \le q < t$.
Немного преобразуем: $a=(x^t)^px^q$
Теперь предподсчитаем $(x^t)^0$, $(x^t)^1$, \dots, всего $\approx \frac{\phi(m)}{t}$ штук (или $\frac{m}{t}$, если не знаем $\phi(m)$).
Цель "--- чтобы для последней степени $x^{\alpha t}$ выполнялось $\alpha t \ge \phi(m)$.
\begin{center}
\input{29_baby_giant}
\end{center}
Сложим все эти <<большие шаги>> в хэш-таблицу (по числу $a^{pt}$ умеем получать $p$).
Потом возьмём и в лоб найдём такое $q'=p-q$, что $ax^{q'} = x^{(p+1)t}$ (если $q=0$, то мы сразу остановимся в $q'=0$.
Так как $\alpha t \ge \phi(m)$, то такое $q'$ обязательно найдётся (так как за каждым числом когда-то последует элемент хэш-таблицы), причём $q'<t$.
Теперь легко найти соответствующие $p$ и $q$.

То есть при наличии хэш-таблицы мы умеем логарифмировать за $O(t)$ операций.
А хэш-таблицу можно построить за $O(\frac{m}{t} + \log t)$ операций (сначала нашли $x^t$ быстрым возведением в степень, а потом посчитали его $\frac mt$ степеней <<в лоб>>).
Положим $t=\sqrt m$ и получим алгоритм за $O(\sqrt m)$.
Заметим, что мы не пользовались про модуль вообще ничем: алгоритм работает для составных, умеет выдавать <<ответа не существует>>.

\section{Извлечение корня}
Хотим решить сравнение по модулю $m$ относительно $x$: $x^k=a$, $a$ и $k$ "--- константы.
Мы умеем это делать, если у нас существует первообразный корень $g$ и $a=g^{\alpha}$
(то есть $(a, m)=1$).
Для начала находим первообразный корень и дискретный логарифм $a$ по основанию $g$.
Это можно делать, например, за корень (но бывают алгоритмы и быстрее).

Теперь хотим решить уравнение.
Так как $(a, m)=1$, то $(x, m)=1$ (если, конечно, $x$ существует).
То есть существует некоторое $\beta$ такое, что $x=g^{\beta}$:
\begin{gather*}
(g^{\beta})^k = g^{\alpha} \mod m \\
g^{k\beta} = g^{\alpha} \mod m \\
k\beta = \alpha \mod \phi (m)
\end{gather*}
Теперь надо решить последнее сравнение по модулю $\phi(m)$ относительно $\beta$, мы уже знаем, как это делать.
Если решилось "--- нашли корень, если не решилось "--- корня не существует.
