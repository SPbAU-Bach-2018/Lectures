\chapter{Статистически оптимальное дерево поиска. Дерево отрезков}
\setauthor{Никита Подгузов}

\section{Статически оптимальное дерево}

$\sum \limits_i k_i dep_i \rightarrow min$

$Time = O(n^2)$

Динамика по подотрезкам.
Перебираем корень дерева, для префикса и суффикса динамика уже посчитана, получаем $O(n^3)$.

Обозначим оптимальный корень для отрезка $[L, R]$ за $p[L, R]$.
Тогда верно следующее утверждение: $p[L, R - 1] \le p[L, R] \le p[L + 1, R]$.
Доказывается примерно так же, как и аналогичное утверждение в конце прошлого семестра (см. задачу про выбор оптимальных точек на вещественной прямой).

$Time = \sum \limits_{L, R} p_{L,R} = \sum \limits_{L, R} (p_{L + 1, R} - p_{L, R - 1} + 1) = O(n^2) + \sum \limits_{\substack{\text{линейное}\\
\text{число}\\
\text{слагаемых}}}
O(n) = O(n^2)$

\section{Дерево отрезков}

\subsection{Описание и примеры применения}

\subsubsection{Описание структуры}

\cimg{Segment_tree.png}{}

В каждой вершине мы храним функцию от отрезка, за который эта вершина отвечает.
Корень отвечает за отрезок $[0, N)$.

Высота такого дерева $\log_2 N$

\begin{equation*}
	V: [L, R) \Rightarrow
	\begin{cases}
		2V: & [L, \frac{L+R}{2}) \\
		2V+1: & [\frac{L+R}{2}, R)
	\end{cases}
\end{equation*}

\begin{lemma}
	Заметим, что отрезок $[L, R]$ разбивается на $\le 2\log_2 N$ вершин дерева отрезков.
\end{lemma}

\begin{proof}
	На одном уровне (которых всего $\log_2 N$) отмечено не более двух вершин.
	Пусть отмечено хотя бы три, тогда посмотрим на среднюю.
	Тогда можно было брать не её, а её родителя.
	Противоречие.
\end{proof}

\subsubsection{Запросы Get и Update элемента}

\begin{itemize}
\item
	Как отвечать на запросы \t{Update} элемента с помощью дерева отрезков?

	Нам достаточно изменить значения во всех вершинах на пути от корня до нашей вершины. Их количество равно высоте, то есть $O(\log_2 N)$.

\item
	Как отвечать на запросы \t{Get} с помощью дерева отрезков?

	Пусть запрос \t{Get} на $[L, R]$.
	Разобьём отрезок $[L, R]$ на вершины дерева отрезков, в каждой из которых уже посчитан правильный ответ.
	Теперь осталось просто взять функцию по значениям в выбранных вершинах.

\item
	Какие функции мы можем посчитать с помощью дерева отрезков?
	
	Несложно понять, что функция должна обладать свойством ассоциативности.

\item
	Примеры функций:
	\begin{itemize}
		\item $\sum$
		\item $\min$
		\item $\gcd$
		\item Композиция перестановок
		\item Произведение матриц
	\end{itemize}
\end{itemize}

\subsubsection{Запросы \t{Get} и \t{Update} на отрезке}

Существует два вида запроса \t{Update} на отрезке: прибавление и присвоение.
Решаются они одинаково: теперь мы храним в вершине дополнительное значение: сколько нужно прибавить/присвоить на этом отрезке.
Когда заходим в вершину в процессе обработки запросов, проталкиваем значения в сыновей и обнуляем у себя.

\subsubsection{Применение дерева отрезков в задаче <<Художник>>}

Хотим уметь отвечать на два типа запросов:

\begin{enumerate}
	\item \t{Paint} $[L, R]$ $color$ "--- красим отрезок $[L, R]$ в цвет $color$.
	\item \t{Get} "--- хотим узнать количество белых отрезков.
\end{enumerate}

Будем хранить в вершине три дополнительных поля: $count$, $colorL$ и $colorR$ "--- количество белых отрезков, цвет левой клетки и цвет правой клетки соответственно.
$colorL$ и $colorR$ пересчитываются просто, с $count$ чуть сложнее:
\begin{cppcode}
count[v] = count[2 * v] + count[2 * v + 1]
	- (colorR[2 * v] == WHITE && colorL[2 * v + 1] == WHITE)
\end{cppcode}

\t{Get}: просто возвращаем $count[1]$.

\subsubsection{Динамическое дерево отрезков и сжатие координат}

Хотим научиться поддерживать следующие три запроса:
\begin{enumerate}
	\item \t{Insert(x)}
	\item \t{Delete(x)}
	\item \t{Count(L, R)} Количество таких $x$, что $L \le x \le R$.
\end{enumerate}

Построим дерево отрезков по сумме на массиве $count[x]$ "--- количество чисел $x$ в множестве.
Запросы превращаются в прибавление $\pm 1$ и сумму на отрезке.
Осталась проблема с большими $x$.

Два пути решения:
\begin{enumerate}
\item
	Offline: Используем метод сжатия координат.
	
	$x_i \rightarrow position[x_i]$, где $position[j]$ "--- позиция $j$ в отсортированном массиве $x$-ов.

	Таким образом, теперь все $x_i \le N$.

\item
	Динамическое дерево отрезков.
	Вместо массива теперь пользуемся структурой, как в Treap.
	Есть указатели на левого и правого сыновей, причём создаём их, только если запрос спускается в соответствующую ветку.
	\begin{gather*}
		Time = O(N \log M) \\
		Memory = O(N \log \frac{M}{N})
	\end{gather*}
	$\log \frac{M}{N}$ появляется из-за того, что во многих запросах будет одинаковое начало "--- первые $\log N$ уровней,
	поэтому на них выделять память каждый раз заново мы не будем.
\end{enumerate}
		
\subsubsection{Количество вершин в дереве отрезков}
			
Реализация массивом: $4N$

Реализация структурой: $(2N-1)\mathup{sizeof}(node)$

\subsection[k-ая порядковая статистика на отрезке]{$k$-ая порядковая статистика на отрезке}

\subsubsection{Нет запросов изменения}

Научимся отвечать на вопрос: сколько чисел на $[L, R] \le x$.

В дереве отрезков храним отсортированные кусочки массива. Умеем строить за $O(N\log N)$ "--- \cpp'merge()' сыновей.
Пусть нам пришел запрос, разбили отрезок на вершины дерево отрезков, в каждой вершине сделали бинпоиск.
\begin{gather*}
	Time = O(\log^2 N) \\
	Memory = O(N \log N)
\end{gather*}

\subsubsection{Есть запросы изменения}
					
Вместо кусочков массивов храним дерево отрезков
\begin{itemize}
\item
	BST.
	Добавление и удаление за $O(\log^2 N)$: на всём пути до корня вставляем/удаляем элемент из очередного BST.

	Запрос: сколько чисел на $[L, R] \le x$ за $O(\log^2 N)$: разбиваем отрезок на вершины дерева отрезков,
	в каждом BST за $O(\log N)$ отвечаем на запрос, храня количество вершин в поддереве и просто спускаясь по BST.

	Time = $O(\log^2 N)$

\item
	Динамическое дерево отрезков.
	Храним динамическое дерево отрезков $count[x]$ по сумме "--- сколько раз встречалось число $x$.
	
	Добавление и удаление за $O(\log N \log M)$: на всём пути до корня вставляем/удаляем элемент из очередного динамического дерева отрезков.

	Запрос: сколько чисел на $[L, R] \le x$ за $O(\log N \log M)$: разбиваем отрезок на вершины дерева отрезков,
	в каждом динамическом дереве отрезков за $O(\log M)$ делаем запрос суммы на $[0, x]$.

	Time = $O(\log N \log M)$
\end{itemize}
			
\subsubsection{Нет запросов изменения, $O(\log M \log N)$}

Хотим уметь отвечать на запросы вида $L \le i \le R$, $a_i \le x$ за $O(\log N)$.

Заметим, что когда мы спускаемся по дереву отрезков, нам не нужно делать в каждой вершине бинпоиск заново.
Для этого будем хранить величину $L[i]$ "--- сколько среди первых $i$ чисел в вершине попали в левого сына.
Тогда если бинпоиск вернул нам позицию $pos$, то нам достаточно перейти в левого сына с позицией $L[pos]$, а в правого "--- с позицией $pos - L[pos]$.

Строим сверху вниз: смотрим на индекс, кидаем в нужного сына.

Итого: сделали один бинпоиск в корне дерева, быстро спустились по дереву отрезков с помощью $L[i]$.
\[ Time = O(\log N) \]
Достаточно хранить отсортированный массив в корне и ссылки $\Rightarrow$ память увеличилась на $N$.

Вспомним, что мы хотим уметь считать $k$-ую порядковую статистику на отрезке.
			
Пусть $cnt(x)$ "--- количество таких $a_i$, что $L \le i \le R$, $a_i \le x$.
Заметим, что $cnt(x)$ возрастает.
Значит, можем сделать бинпоиск по ответу.
			
Ответ "--- $\min x: cnt(x) \ge k$.
\[ Time = O(\log M \log N) \]

\subsubsection{Оптимизация $\log M \Rightarrow \log N$}

Если запросов изменения нет, то всего $N$ элементов, можно делать бинпоиск по ним, а не по значениям.

Если запросы изменения есть, то мы можем хранить все элементы в отдельном Treap и спускаться <<бинпоиском>> по Treap-у,
используя опорным элементов в бинпоиске текущую вершину.
			
\subsubsection{Нет запросов изменения, $O(\log^2 N)$}

Пусть для первых $i$ ячеек мы знаем дерево отрезков по сумме $count_i[x]$ "--- сколько раз встречалось число $x$. Обозначим это дерево за $Tree_i$.
Заметим, что $count_i$ от $count_{i-1}$ отличается всего одним изменением (в ячейке $a_i$).
Значит, мы можем сделать наше дерево отрезков персистентным.

Хотим уметь отвечать на запросы вида $L \le i \le R$, $a_i \le x$ за $O(\log N)$.

Ответ "--- \cpp'Tree[R].get(0, x) - Tree[L-1].get(0, x)'.
				
Внешне всё еще бинпоиск.
\[ Time = O(\log^2 N) \]

\subsubsection{Нет запросов изменения, $O(\log N)$}

Заметим, что мы можем спускаться по деревьям параллельно.
Изначально мы стоим в корнях деревьев $Tree_R$ и $Tree_{L-1}$.

Пусть сумма в левом сыне $Tree_R$ равна $A$, а сумма в левом сыне $Tree_{L-1}$ равна $B$ (вспомним, что мы строили эти деревья именно по сумме).
Тогда если $A-B \ge k$, то мы идем в левых сыновей, иначе в правых, не забывая сделать \cpp'k -= A - B'.

Вершина, в которую придём в итоге, и есть ответ.
\[ Time = O(\log N) \]

\subsubsection{Есть запросы изменения, $O(\log N \log M)$}

Структура: деревья отрезков динамических деревьев отрезков.

Оптимизация аналогична предыдущей: вместо внешнего бинпоиска и спуска по дереву отрезков, мы разбиваем запрос на вершины дерева отрезков, а дальше аналогичный трюк.
Суммируем суммы по все левым сыновьям вершин, на которые разбился запрос.
Если эта сумма $S \le k$, во всех деревьях спускаемся в левого сына, иначе в правого, не забывая сделать \cpp'k -= S'.
\[ Time = O(\log N \log M) \]
