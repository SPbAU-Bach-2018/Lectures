\chapter{\texorpdfstring{Максимум на пути за $O^*(1)$}{Максимум на пути за $O^*(1)$}}
\setauthor{Саша Малышева}

Алгоритм работает offline за $O((n+m)A^{-1}(n, m))$, где $n$ "--- количество вершин, $m$ "--- количество запросов.
Хотим применить сжатие путей, но перед этим нужно понять, что все пути вертикальны.

\cimg{12_1.jpg}{0.5}

Делаем обход из нижней вершины к верхней, таким образом узнаем максимумы на всех путях от вершин до представителя, для этого потребовалось $O((m + n)log(n))$
(из-за эвристики сжатия путей).
То есть, когда поступает запрос максимума на пути, перевешиваем все вершины к представителю и записываем на вновь появившемся ребре максимум. 

Чтобы улучшить асимптотику, нужно улучшить ранговую эвристику (подвешивания меньшего к большему).

\cimg{12_2.jpg}{0.5}

\begin{cppcode}
for UP
	for queries[up]
		Get[down]
Join(parent[up], up)
\end{cppcode}

Тепрь рассмотрим как должен работать Join

\cpp'w[a]' "--- максимум, который достигается из вершины сейчас.

\cimg{12_3.jpg}{0.5}

Join(a, b)
\begin{enumerate}
\item
	$w[a] \ge w[b]$:
	Нужно переподвесить. При этом переподвешиваем с учетом ранговой эвристики. 
	В представителя записываем значения $w[a]$.

\item
	$w[a] < w[b]$:
	Ничего не надо делать. (\textit{Ну почти ничего...})
	Все вершины, которые проходили через $b$, поднимаются выше, max не изменится.
\end{enumerate}

Рассмотрим более подробно второй случай.
Пусть сейчас есть подмножество вершин $b$ и подмножество вершин $a$.
При рассмотрение <<нужно ли подвесть $b$ к $a$>> - ничего не меняем.

Но может появится вершина $d$ которая больше, чем $a$ и $b$. Тогда для обоих подмножеств нудно изменить ответ.

\cimg{12_5.jpg}{0.5}

Избежим пересчитывания, введя <<сына>>. Сын у вершины будет только 1. И для сына $b$ вершины $a$ верно, что $w[b] > w[a]$.

Вспомним возникающие случаи.

\begin{enumerate}
\item
	$w[a] \ge w[b]$:
	Переподвешиваем, теперь ответ для вершины $b$ увеличился, стал $w[a]$.
	Значит теперь могло стать неверным $w[b] < w[child]$.
	Если $w[child]$ стало больше, то объеденим с родителем.
	Повотрим, пока не дойдем до конца дерева, или пока условие на ребенка не станет верным.

\item
	$w[a] < w[b]$:
	Мы хотим сказать, что вершина $b$ теперь стала ребенком вершины $а$, но что делать если вершина $а$ уже имела сына?

\cimg{12_6.jpg}{0.5}

	Чтобы улучшить асимптотику "--- выбираем меньшего из $b$ и ребёнка $a$, и объединяем с родителем.
	Для этого храним $size$ - настоящий размер, с учетом отложеных $Join$.
\begin{cppcode}
Merge(a, b) { // допустим b меньше ребенка a.
    DSU.parent[b] = a; //сливаем a и b.
    Merge(a, child[b]); //сливаем a с ребенком b.
\end{cppcode}
	
	То есть раньше мы бы сделали три объединения: $а$ со своим ребенком, $b$ со своим, и потом подвесели бы $b$ к а.
	А сейчас это похоже на ранговую эвристику "--- берем меньшего.
\end{enumerate}

\begin{Rem}
	Все это для того, чтобы подниматься и искать максимум.
	$Child$ добавляется когда у нижней вершины вес меньше, чем у верхней.
	При объединении двух отцов с детьми, объединяем однонго из них с ребенкои, того у которого размер ребенка меньше. И делаем $Join$.

	\cimg{12_7.jpg}{0.75}

	Можно для большего улучшения времени объединения делать следующим образом:
\begin{cppcode}
while ((B != null) && (C != null))
	let B <= C
	Join(A, B)
	B = child B
\end{cppcode}
	где $С$ "--- ребенок $А$, то есть таким образом мы сможем объеденить мимнмальное число врешин.
\end{Rem}


Мы верим, что эвристика сжатия путей, работает. Теперь попробуем понять, почему работает ранговая эвристика. 

Заметим, что, когда мы разрешаем ребро child, размер дерева хотя бы в два раза больше размера поддерева. 

Когда мы проводим ребро просто так, мы это делаем в зависимости от ранга, значит, ранговая эвристика работает. 

