\chapter{\texorpdfstring{Максимум на пути за $O(1)$}{Максимум на пути за O(1)}}
\setauthor{Саша Малышева}

Алгоритм работает offline за $O(n+m)$, где $n$ "--- количество вершин, $m$ "--- количество запросов.
Хотим применить сжатие путей, но перед этим нужно понять, что все пути вертикальны.

\cimg{12_1.jpg}{0.5}

Делаем обход из нижней вершины к верхний, таким образом узнаем максимумы на всех префиксах, для этого потребовалось $O((m + n)log(n))$
Чтобы улучшить асимптотику, нужно улучшить эвристику подвешиванья меньшего к большему.
Заметим систему непересекающихся множеств. Воспользуемся ей.

\cimg{12_2.jpg}{0.5}

\begin{cppcode}
for UP
	for queries[up]
		Get[down]
Join(up, parent[up])
\end{cppcode}

Тепрь рассмотрим как должен работать Join

\cpp'w[a]' "--- максимум, который достигается из вершины сейчас.

\cimg{12_3.jpg}{0.5}

Join(a, b)
\begin{enumerate}
\item
	$w[a] \ge w[b]$:
	Нужно переподвесить.

\item
	$w[a] < w[b]$:
	Ничего не надо делать.
	Все вершины, которые проходили через $b$, поднимаются выше, max не изменится.
\end{enumerate}

Рассмотрим более подробно второй случай.
Пусть сейчас есть подмножество вершин $b$ и подмножество вершин $a$.
При рассмотрение <<нужно ли подвесть $b$ к $a$>> - ничего не меняем.

(4)

Но может появится вершина $d$ которая больше, чем $a$ и $b$. Тогда для обоих подмножеств нудно изменить ответ.

\cimg{12_5.jpg}{0.5}

Избежим пересчитывание введя <<сына>>. Сын у вершины будет только 1. И для сына $b$ вершины $a$ верно, что $w[b] > w[a]$.

Вспомним возникающие случаи.

\begin{enumerate}
\item
	$w[a] \ge w[b]$:
	Переподвешиваем, теперь ответ для вершины $b$ увеличился, стал $w[a]$.
	Значит теперь могло стать неверным $w[b] < w[child]$.
	Если $w[child]$ стало больше, то объеденим с родителем.
	Повотрим, пока не дойдем до конца дерева, или пока условие на ребенка не станет верным.

\item
	$w[a] < w[b]$:
	Мы хотим сказать, что вершина $b$ теперь стала ребенком вершины $а$, но что делать если вершина $а$ уже имела сына?

\cimg{12_6.jpg}{0.5}

	Чтобы улучшить асимптотику "--- выбираем меньшего из детей $a$ и $b$, и объединяем с родителем.
	Для этого храним $size$ - размер с учетом отложеных $Join$.
\begin{cppcode}
for UP
	DSU.parent[child[b]] = b // допустим если число детей у b меньше.
		Join(a, b) // у одной из них уже нет ребенка
\end{cppcode}
	То есть раньше мы бы сделали три объединения: $а$ со своим ребенком, $b$ со своим, и потом подвесели бы $b$ к а.
	А сейчас это похоже на ранговую эвристику "--- берем меньшего.
\end{enumerate}

\begin{Rem}
	Все это для того, чтобы подниматься и искать максимум.
	$Child$ добавляется когда у нижней вершины вес меньше, чем у верхней.
	При объединении двух отцов с детьми, объединяем однонго из них с ребенкои, того у которого размер ребенка меньше. И делаем $Join$.

	\cimg{12_7.jpg}{0.75}

	Можно для большего улучшения времени объединения делать следующим образом:
\begin{cppcode}
while ((B != null) && (C != null))
	let B <= C
	Join(A, B)
	B = child B
\end{cppcode}
	где $С$ "--- ребенок $А$, то есть таким образом мы сможем объеденить мимнмальное число врешин.
\end{Rem}

