\section{Строки. Базовые алгоритмы.}
\setauthor{Денис Галеев}

\subsection{Общие понятия}

Пусть дана строка $s$ длины $n$. 
Тогда подстрокой строки $s$ называется строка $s[i \dots j]$, где $0 \le i \le j < n$.
Префиксом называются подстроки, где $i = 0$, а суффиксом подстроки, где $j = n - 1$.

Период строки это целое положительное число $t$, такое что $\forall i \in [0 \dots n-t) \colon s[i] = s[i + t]$.
Целым периодом называется такой период, что он делит длину строки нацело. 
Существует так же минимальный период, это минимум из всех периодов.

\subsection{Префикс-функция}
Пусть дана строка $s$. 
Префикс-функция $p[i]$ для строки $s$, длина наибольшего префикса строки $s[0 \dots i)$(не совпадающий со всей строкой), который одновременно является её суффиксом.
Более формально $p[i] = \max n < i \colon s[0 \dots n) = s[i - n \dots i)$.

Научимся префикс-функцию для всей строки $s$.

\begin{cppcode}
strings s;
int n = (int) s.length();
vector<int> p (n);
int k = 0;

for (int i = 1; i < n; ++i) {
  k = pi[i];
  while (k > 0 && s[i] != s[k])
    k = pi[k];
  if (s[i] == s[k]) ++k;
  pi[i + 1] = k;
}
\end{cppcode}

Поймем как и почему это работает. 
%Для начала очевиден факт, что $p[i - 1] \ge p[i] - 1$, если бы это было не так, то для префикс функции $s[0 \dots i)$, выбрана не наибольший префикс совпадающий с суфиском, например подходит большее значение $p[i] - 1$. Допустим префикс функция вычислена до $i$. 
Надо дописать.

Почему работает за $O(n)$.
Заметим что увеличение префикс функции происходит всего лишь в одной строке \cpp"if (s[i] == s[k]) ++k;", всего таких увеличений не больше $n$, а количество уменьшений строка \cpp"k = pi[k];" не может первосходить количество увеличений, следовательно общее время работы это $O(n)$.

Как ускорить префикс-функцию.
Можно убрать строку $k = pi[i]$, так как $k$ уже равно $p[i]$, если не верите посмотрите на последнюю строку цикла.

\subsection{КМП}
Поиск подстроки в строке. Алгоритм Кнута-Морриса-Пратта.
Даны две строки $s$ и $t$. $s$ "--- образец, а $t$ "--- текст. 
Нужно найти все вхождения образца в текст. 

Будем решать с помощью префикс-функции. 
Создадим новую строку, являющейя конкатенацией трех строк \cpp"str = s + symb + t", где \cpp"symb" "--- строка состоящая из одного символа, не входящего ни в $s$, ни в $t$ (стоп-символ). 
На полученной строке посчитаем префикс-функию. 
В местах где префикс функция равна длине строки $s$, там заканчивается очередное вхождение образца в текст.

Для того чтобы обойтись без применения стоп-символа надо добавить в префикс функцию строку \cpp"if (k > len) k = p[k]", где \cpp"len" "--- длина образца.

\subsection{z-функция}
$z$-функция от строки $s$ "--- это массив $z$, такое что $z[i]$ равно наидлиннейшему префиксу подстроки, начинающейся с позиции $i$ в строке $s$, который одновременно является и префиксом всей строки $s$.

$$z[i] = LCP[0,i]$$
где $LCP$ "--- это наибольший общий префикс (longest common prefix).

Посчитаем $LCP$.

\begin{cppcode}
while (s[k] == t[k])
  ++k;
\end{cppcode}

Давайте сравнивать \cpp"int" так ведь быстрее.

\begin{cppcode}
si = (int*) s;
ti = (int*) t;
while (si[k] == ti[k])
  ++k;

k *= 4;
while (s[k] == t[k])
  ++k;
\end{cppcode} 

Отличный результат. 
Но почему бы не сравнивать еще большие куски памяти, реализуем.


\begin{cppcode}
const int CMP_LEN = 256;
sn = (int*) s;
tn = (int*) t;

while (memcmp (s, t, CMP_LEN))
  sn += CMP_LEN, 
  tn += CMP_LEN;

while (*sn == *tn)
  ++sn, 
  ++tn;
\end{cppcode} 

Наконец-то добрались до самой $z$-функциии.

\begin{cppcode}
int n = (int) s.length();
vector<int> z (n);

for (int i = 1, l = 0, r = 0; i < n; ++i) {
  if (z[i - l] < r - i) {
    z[i] = z[i - l];
  } else {
    z[i] = max (r - i, 0);
    while (s[z[i]] == s[i + z[i]])
      ++z[i];
    l = i; 
    r = i + z[i];
  }
}
\end{cppcode} 


\subsection{Боуер-Мур}
Алгоритм Боуера-Мура "--- алгоритм поиска образца в тексте. 

Опишем несколько идей:

Для начала допустим мы сравнивали образец и какую-то подстроку в тексте и получилось так что рассматриваемого символа из текста вообще нет в образце, тогда можно сдвинуть со следующего символа можно заново начинать сравнивать строки. 

Эвристика стоп символа.
Сделаем предподсчет $next[i, char]$.
Ждем продолжения....

\subsection{Полиномиальный хеш}
Пишем хеши как Серёжа:
\url{http://codeforces.com/blog/entry/17507}

\subsection{Анти-хеш тест}

\begin{enumerate}
\item $\forall <p, M> \exists Hash(s_1) = Hash(s_2)$ "--- анти-хеш тест.
\item $<p = rand, M = rand>$ "--- неизвестно как построить анти-хеш тест.
\item $<p, M = rand>$ "--- строка Туе-Морса явлется анти-хеш тестом.
\end{enumerate}

\subsection{Рабин-Карп}
В процессе...