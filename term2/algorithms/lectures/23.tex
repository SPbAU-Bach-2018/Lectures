\section{Битовое сжатие}
\setauthor{Миша Никонов}

\subsection{Оптимизируем рюкзак и алгоритм Флойда}
Вспомним практику:
\begin{itemize}
  \item Рюкзак:
\begin{cppcode}
bitset<S + 1> f;
f[0] = 1;
forn(i, n) 
  f |= f << a[i]; // O(S/word)
\end{cppcode}
  \item Флойд:
\begin{cppcode}
forn(k, n) {
  forn(i, n) {
    if (c[i][k])
      c[i] |= c[k];
  }
}
\end{cppcode}
\end{itemize}

Флойдом мы нашли транзитивное замыкание графа (т.е. матрицу достижимости). Однако эту задачу можно решить быстрее:
\begin{enumerate}
  \item Сожмем компоненты сильной связности за $O(n + m)$.
  \item Динамика на ацикличном графе: Пусть из вершины $v$ достижимы компоненты $x_1, \dots, x_k$, тогда $f[v] = OR(f[x_i])$. Ассимптотика: $O(\frac{nm}{word})$.
\end{enumerate}

\subsection{Умножение, деление и Гаусс}
Над $\mathbb{F}_2[x]$ мы умеем быстро умножать и делить.
\begin{itemize}
  \item Умножение (обычная реализация):
\begin{cppcode}
forn(i, n) {
  forn(j, n)
    c[i + j] = a[i] & b[j];
}
\end{cppcode}
    Быстрая реализация:
\begin{cppcode}
forn(i, n) {
  if (a[i])
    c |= b << i;
}
\end{cppcode}
  \item Быстрое деление:
\begin{cppcode}
for (i = deg(a); i >= deg(b); i--)
  if (a[i])
    a ^= (b << (i - deg(b)));
\end{cppcode}
  \item Быстрый Гаусс: сложения и вычитания строк - это ксор. Меняем местами строки тоже быстро. Получился быстрый Гаусс.
\end{itemize}


\section{Крестики-нолики}
Играем на поле 30 на 30. Нужо собрать отрезок из пяти крестикиов (или ноликов). 
Поэтапно придумываем стратегии:
\begin{enumerate}
  \item Жадно не будем давать собрать палку - рисовать крестик в конец.
  \item Разобъем поле на объекты. Каждый объект имеет ценность. Будем минимизировать сумму ценностей имеющихся объектов.
  \item Оставим $k$ самых удачных ходов и уйдем в рекурсию с отсечением по времени.
  \item Сделаем бинарный поиск по ''правда ли, что через какое-то количество ходов суммарная стоимость будет меньше $F$''. Получили $01$ дерево. 
    Используя технику рандома с предыдущей пары уйдем в рекурсию. В результате примерная глубина: $6.2$
\end{enumerate}
Бывает $\Alpha\Beta$ отсечение, это примерно последний пункт, только хуже.

\section{Метод 4-х русских}
\par Рассмотрим на примере умножения двух матриц над $\mathbb{F}_2$.
\par Разрежем первую матрицу ($A$) на $k$ вертикальных полосок, а вторую ($B$) на $k$ горизонтальных. Заметим, что $AB = \sum{a_ib_i}$. 
  Пока умножение все еще раотает за $O(\frac{n}{k}(nkn) = n^3)$. Рассмотрим поподробнее, что происходит, когда мы умножаем две матрицы $n*k$. 
  Каждая строка $l$ результата - это сумма каких-то строк из $b_i$, причем, очередная строка суммируется, если в матрице $a_i$ в строке $l$ в соответсвующей позиции стоит
  единичка и не учитывается, если там стоит ноль. Пусть $k = \log{n}$. Тогда за $O(n2^k) = O(n^2)$ мы можем предподсчитать все такие линейные комбинации строк из $b_i$. 
  Теперь, сразу зная ответ для очередной строки, умножение матриц $n*k$ работает за $O(N^2)$. Таким образом итоговая асимптотика - $O(\frac{n^3}{\log{n}})$. 
\par Если везде использовать битовое сжатие, то можно все сделать еще в $word$ раз быстрее.


