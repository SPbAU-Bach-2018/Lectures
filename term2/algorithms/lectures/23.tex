\section{Битовое сжатие}
\setauthor{Миша Никонов}

\subsection{Оптимизируем рюкзак и алгоритм Флойда}
Вспомним практику:
\begin{itemize}
  \item Рюкзак:
\begin{cppcode}
bitset<S + 1> f;
f[0] = 1;
forn(i, n) 
  f |= f << a[i]; // O(S/word)
\end{cppcode}
  \item Флойд:
\begin{cppcode}
forn(k, n) {
  forn(i, n) {
    if (c[i][k])
      c[i] |= c[k];
  }
}
\end{cppcode}
\end{itemize}

Флойдом мы нашли транзитивное замыкание графа (т.е. матрицу достижимости). Однако эту задачу можно решить быстрее:
\begin{enumerate}
  \item Сожмем компоненты сильной связности за $O(n + m)$.
  \item Динамика на ацикличном графе: Пусть из вершины $v$ достижимы компоненты $x_1, \dots, x_k$, тогда $f[v] = OR(f[x_i])$. Ассимптотика: $O(\frac{nm}{word})$.
\end{enumerate}

\subsection{Умножение, деление и Гаусс}
Над $\mathbb{F}_2[x]$ мы умеем быстро умножать и делить.
\begin{itemize}
  \item Умножение (обычная реализация):
\begin{cppcode}
forn(i, n) {
  forn(j, n)
    c[i + j] = a[i] & b[j];
}
\end{cppcode}
    Быстрая реализация:
\begin{cppcode}
forn(i, n) {
  if (a[i])
    c |= b << i;
}
\end{cppcode}
  \item Быстрое деление:
\begin{cppcode}
for (i = deg(a); i >= deg(b); i--)
  if (a[i])
    a ^= (b << (i - deg(b)));
\end{cppcode}
  \item Быстрый Гаусс: сложения и вычитания строк - это ксор. Меняем местами строки тоже быстро. Получился быстрый Гаусс.
\end{itemize}


\section{Крестики-нолики}
Играем на поле 30 на 30. Нужо собрать отрезок из пяти крестикиов (или ноликов). 
Поэтапно придумываем стратегии:
\begin{enumerate}
  \item Жадно не будем давать собрать палку - рисовать крестик в конец.
  \item Разобъем поле на объекты. Каждый объект имеет ценность. Будем минимизировать сумму ценностей имеющихся объектов.
  \item Оставим $k$ самых удачных ходов и уйдем в рекурсию с отсечением по времени.
  \item Сделаем бинарный поиск по ''правда ли, что через какое-то количество ходов суммарная стоимость будет меньше $F$''. Получили $01$ дерево. 
    Используя технику рандома с предыдущей пары уйдем в рекурсию. В результате примерная глубина: $6.2$
\end{enumerate}
Бывает $\Alpha\Beta$ отсечение, это примерно последний пункт, только хуже.

\section{Метод 4-х русских}
\subsection{Перемножение бинарных матриц}
\par Мы хотим умножить две матрицы над $\mathbb{F}_2$.
\par Разрежем первую матрицу ($A$) на $k$ вертикальных полосок, а вторую ($B$) на $k$ горизонтальных. Заметим, что $AB = \sum{a_ib_i}$. 
  Пока умножение все еще раотает за $O(\frac{n}{k}(nkn) = n^3)$. Рассмотрим поподробнее, что происходит, когда мы умножаем две матрицы $n*k$. 
  Каждая строка $l$ результата - это сумма каких-то строк из $b_i$, причем, очередная строка суммируется, если в матрице $a_i$ в строке $l$ в соответсвующей позиции стоит
  единичка и не учитывается, если там стоит ноль. Пусть $k = \log{n}$. Тогда за $O(n2^k) = O(n^2)$ мы можем предподсчитать все такие линейные комбинации строк из $b_i$. 
  Теперь, сразу зная ответ для очередной строки, умножение матриц $n*k$ работает за $O(N^2)$. Таким образом итоговая асимптотика - $O(\frac{n^3}{\log{n}})$. 
\par Если везде использовать битовое сжатие, то можно все сделать еще в $word$ раз быстрее.
\subsection{Построение булевой схемы}
\par У нас есть функция $f:\{0, 1\}^n \rightarrow \{0, 1\}$. Хотим для нее построить схему.
\begin{enumerate}
  \item Приведя выражение в КНФ или ДНФ легко построить схему, размером $n 2^n$.
  \item Будем разделять функцию на две, пока не кончатся аргументы: $f_0 = f |_{x_n = 0} \cup f |_{x_n = 1}$
\begin{cppcode}
if (x[n] == 0)
  f_0(x[1], x[2], ... , x[n - 1]);
else 
  f_1(x[1], x[2], ... , x[n - 1]);
\end{cppcode}
  \par Если такую схему строить по принципу: $(f_0 \; and \; !x_n) \; or \; (f_1 \; and \; x_n)$, что для каждого аргумента дает константу дополнительных блоков, то ее размер будет $O(2^n)$.
\item Давайте предыдущим алгоритмом избавимся от всех аргументов, кроме первых $k$: $n\rightarrow n-1 \rightarrow n - 2 \rightarrow \dots \rightarrow k$, где $k = \log{n} - 1$.
  Всего различных функций из $k$ аргументов $2^{2^{k}}$. Заранее предподсчитаем все такие функции. Это потребует $2^{2^{k}} + 2^{2^{k - 1}} + \dots = 2^{n/2} + 2^{n/4} + \dots
  = O(2^{\frac{n}{2}})$. Теперь будем просто использовать предподсчитаные функции. Размер итоговой схемы: $2^{n - k + 1} = 2^{n - \log{n} + 2} = \frac{4}{n}2^n$.
\end{enumerate}
\subsection{Наибольшая общая подстроку}
\par Найдем наибольшую общую подстроку за $\Theta(\frac{n^2}{\log{n}^2})$.
\begin{enumerate}
  \item Вспомнили старую динамику за квадрат.
  \item Заметим, что $dp[i][j + 1] - dp[i][j] \in \{0, 1\}$ и $dp[i + 1][j] - dp[i][j] \in \{0, 1\}$. 
  \item Представим матрицу динамики в виде кучи квадратиков, со сторонами длиной $k$. Для того, чтоб посчитать динамику в каждом квадратике, нужно только знать 
    значения динамики на его верхней и левой границе, причем, так как на этих границах значения неубывают и отличаются не больше, чем на единицу, их (границы) можно
    задать битовой маской. Теперь нам ничто не мешает позвать на помощь четырех русских, которые предподсчитают все такие квадратики.
  \item Пусть $k = \frac{\log{n}}{2 + \varepsilon}$. Тогда алгоритм работает за $O((n^{\frac{4}{2 + \varepsilon}} + (\frac{n}{k})^2 \dots $. Тут у меня в конспекте дыра, ребят, выручайте.
\end{enumerate}


