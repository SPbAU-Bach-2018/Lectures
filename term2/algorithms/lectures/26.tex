\chapter{Длинная арифметика. Быстрое преобразование Фурье}

\setauthor{Пётр Смирнов}
\section{Быстрое преобразование Фурье}

\subsection{Цель}

Цель: перемножить два многочлена.

$P(x)=\sum_{i=0}^{N-1}a_ix^i$, $\deg P=N$.

$Q(x)=\sum_{i=0}^{M-1}b_ix^i$, $\deg Q=M$.

Наивный алгоритм: $O(NM)$. Хотим быстрее.

Интерполяция: восстановление многочлена по $N$ различным по $x$ точкам.
Наивный алгоритм: интерполяция Лагранжа за $O(N^2)$.
Построим многочлен, который для всех $x_j$, кроме $x_i$ $P(x_j)=0$, $P(x_i)=1$.
$Omega_i(x)=\frac{\prod_{i\neq j}{x-x_j}}{\prod_{i\neq j}{x_i-x_j}}$.
$P(x)=\sum_{i=1}^{N}{Omega_i(x)}$.

Экстраполяция: посчитать значение многочлена в $N$ точках.
Наивный алгоритм: $O(N^2)$ --- схема Горнера: $P(x)=a_0+x(a_1+x(a_2+x(\dots+x(a_N)\dots)))$.

Итак, есть биекция между многочленами степени меньше $N$ и наборами из $N$ пар $(x_i,y_i)$.


\subsection{Описание алгоритма}

Будем считать произведение многочленов $P$ и $Q$ следующим образом:
\begin{enumerate}
\item Экстраполируем $P$, $Q$. Наивный алгоритм: $O((N+M)^2)$, хотим улучшить.
\item Перемножим поточечно. Наивный алгоритм: $O(N+M)$.
\item Интерполируем результат. Наивный алгоритм: $O((N+M)^2)$, хотим улучшить.
\end{enumerate}

Далее будем считать, что $N,M<n=2^k$ --- добьём старшие коэффициенты нулями до одной и той же степени двойки.

Мы вольны выбирать $x_i$. Выберем $x_i$ как все комплексные корни $n$-ой степени из $1$.
Заметим, что каждый второй корень степени $2^k$ является корнем степени $2^{k-1}$.
Воспользуемся этим и применим метод <<разделяй и властвуй>>.

Разделим индексы на чётные и нечётные. $A(x)=(a_0+a_2x^2+\dots)+x(a_1+a_3x^2+\dots)=B(x^2)+xC(x^2)$,
где $B$ и $C$ --- многочлены степени $2^{k-1}$.

Пусть $w_n$ --- первый из корней $n$-ой степени из $1$. Хотим посчитать $A(w_n^k)$ для всех $k=0\dots n-1$.
$w_n^k=e^{k\frac{2\pi i}{n}}$. $w_n^{2k}=e^{2k\frac{2\pi i}{n}}=e^{k\frac{2\pi i}{n/2}}=w^{k}_{n/2}$ ---
то есть при спуске осуществляется переход от $k$ к $k-1$ --- и в смысле степени ($2^k \to 2^{k-1}$), и в смысле корней
(от корней степени $n=2^k$ перешли к корням степени $n/2=2^{k-1}$).

$k<n/2$. Пусть $b_k=B(w_{n/2}^{k})$, $c_k=C(w_{n/2}^{k})$ --- они посчитаны рекурсивно. Тогда $A(w_n^{k})=b_k+w_n^{k}c_k$.

$n>k\ge n/2$. $b_k=B(w_{n/2}^{k})=B(w_{n/2}^{n/2}w_{n/2}^{k-n/2})=B(w_{n/2}^{k-n/2})$, $c_k=C(w_{n/2}^{k-n/2})$.

Такое преобразование называется преобразованием бабочки. Всё вместе --- это и есть прямое преобразование Фурье.

Теперь обратно.

$Y=M\times A$, $M_{ij}=x_k^j=e^{kj\frac{2\pi i}{n}}$. Выпишем матрицу, это матрица Вандермонда. Она невырождена, поэтому существует обратная $M^{-1}$.

Оказывается, $M^{-1}_{kj}=\frac{1}{n}e^{-kj\frac{2\pi i}{n}}$.
Проверяем: $MM^{-1}_{kk}=\sum{l=1}^{n}\frac{1}{n}e^{kj\frac{2\pi i}{n}-kj\frac{2\pi i}{n}}=\frac{n}{n}=1$.
$MM^{-1}_{kj}=0$ --- предлагается проверить самим.

Таким образом, чтобы сделать обратное преобразование Фурье,
нужно подставить комплексно сопряжённые корни в прямое преобразование Фурье, и умножить в конце на $\frac{1}{n}$.

Заметим, что $\bar x_i=x_{n-i}$. Поэтому можно просто перевенуть список корней (кроме $x_0=1$), и на нём запустить прямое преобразование.


\subsection{Реализация}

$O(n\log n)$ получили, но хотим ускорить.

Будем делать \texttt{FFT} на месте --- получаем массив коэффициентов \texttt{complex* A}, изменяем его так, что в ячейках будут значения многочлена.

Тип \texttt{complex} можно использовать из \texttt{std}, но он медленнее, чем рукописный.

Сейчас $O(n)$ дополнительной памяти --- один дополнительный массив, который используем, чтобы разделить на чётные и нечётные.

После этого вызываем рекурсию, затем нужно сделать преобразование бабочки.
Пусть $x=a_k$, $y=a_{k+n/2}\tilde w$, тогда $a_k=x+y$, $a_{k+n/2}=x-y$. $\tilde w$ каждый раз умножается на $w$.

Можно поддерживать указатели \texttt{*x, *y}, чтобы не заводить лишних переменных. Тогда на каждой итерации:
\begin{cppcode}
*y *= w, x += y, y = x - 2 * y;
\end{cppcode}

Корни $\tilde w$ можно предподсчитать.

Это была рекурсивная схема. Избавимся от рекурсии.

Проследим за тем, как распределяются числа по массиву: в каком порядке они будут на самом нижнем уровне рекурсии?
Это можно понять по битовой записи.
На $k$-ом шаге попадёт число в левую или правую половину в зависимости от $k$-ого с конца бита.
Таким образом, перестановка --- это отсортированные по \textit{перевёрнутой битовой записи} числа.
Заметим, что числа, получающиеся при переворачивании битов чисел $0\dots n-1$ --- это числа $0\dots n-1$ в некотором порядке.
Тогда сортировка --- это просто расстановка чисел в нужные ячейки: $A[rev[i]]$ (массив \texttt{rev} умеем считать за $O(n)$).

Избавились от рекурсии.

Дополнительная память тоже не нужна: заметим, что наша перестановка просто меняет местами $i$ и $rev[i]$.
Тогда за один проход мы сможем применить перестановку:
\begin{cppcode}
for(int i = 0; i < N; ++i)
	if(i < rev[i])
		swap(A[i], A[rev[i]]);
\end{cppcode}

Смешанное преобразование Фурье:
если размер блока на уровне небольшой (например, $<2^{11}$), то сначала перебираем степень $w$,
потом перебираем номер блока (так можно делать, потому что небольшие скачки по памяти);
если размер блока на уровне большой,
то для каждого блока перебираем степень $w$.


\subsection{Перемножение длинных чисел}

Перемножение длинных чисел --- это перемножение многочленов, где основание системы счисления --- $x=B$.
В конце --- после перемножения --- округляем до ближайшего целого, нужно ещё сделать нормализацию числа, то есть выполнить переносы через разряды.
Оценим максимальное число, которое получится в коэффициенте: сумма $n$ слагаемых, каждое из которых $<B^2$.

Пример: \texttt{long long}, $n=10^6$ $\Longrightarrow$ $B=10^6$ --- основание системы счисления.


\subsection{FFT в целых числах}

Хотим избавиться от погрешности и от вещественных чисел вообще. Будем работать не в $\C$, а в $\Z_p$, где $p\in\mathbb{P}$ и $p=2^k\cdot c+1$. $2^k\ge n$.
Например, $p=3\cdot 2^{18}+1$.

Существует первообразный корень $g$ по модулю $p$ такой, что $\{g^0,g^1,\dots,g^{p-2}\}=\{1,2,\dots,p-1\}$.
$g$ можно искать наивно: утверждается, что оно небольшое.

Положим теперь $w_{2^k}=g^c$. Оно удовлетворяет всем необходимым свойствам. При этом $\frac{1}{n}=n^{p-2}$.