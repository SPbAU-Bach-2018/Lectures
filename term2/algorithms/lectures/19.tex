\setauthor{Беляев Станислав}

\section{Построение суффиксного дерева за $ O(n) $}

Алгоритм Укконена умеет строить суффиксное дерево за $O(n)$

%\cimg{ukkonen1.png}{}
КАРТИНКА СУФФИКСНОЕ ДЕРЕВО ДЛЯ ABAC\#\\

\begin{Rem}
	Количество различных подстрок $ = \sum\limits_{e} len(e) $
\end{Rem}

Будем строить суффиксное дерево последовательно слева направо, каждый раз добавляя очередной символ, достраивая все суфффиксы в дереве \\
$$ S \to addLetter(c) \to Sc $$

\textbf{Алгоритм}
\begin{enumerate}
\item
	$ S \to S\# $, добавим фиктивный символ в конец, чтобы каждый суффикс стал в итоге листом
\item
	Суффиксы растут при $ S \to Sc $ \\ 
	%\cimg{ukkonen2.jpg}{}
	КАРТИНКА ПЕРЕХОД ИЗ ABA К ABAA
	\begin{itemize}
	\item
		Поддерживаем $ p[] $ "--- концы суффиксов в дереве
	\item
		Создаем новую вершину только на разветвлении, поэтому $ O(n) $ памяти
	\item
		Текущее время: $ O(n^2) $
	\end{itemize}
	Цикл жизни любого суффикса:
	\begin{enumerate}
	\item
		Спуск по дереву
	\item
		Развилка
	\item
		Лист
	\end{enumerate}
	\begin{lemma}
		$ S \to Sc $, Лист $ \to $ Лист
	\end{lemma}
\item
	Листья растут сами
	\begin{equation*}
		Edge
		\begin{cases}
			[i, i + len) \text{ "--- подотрезрок строки } \\
			char = s[i] \text{ "--- первый символ на ребре } \\
			to \text{ "--- номер вершины на конце ребра } 
		\end{cases}
	\end{equation*}
	Добавление символа к листам в дереве есть простое увеличение длинны подотрезка. Скажем, что $len = \infty$ (1-ый cпособ) или что $len = [n - i]$ (2-ой способ), тогда листья будут расти сами \\
	Рассмотрим три фазы жизни любого суффикса. Мы уже сказали, что не спускаемся по дереву (есть $p[]$), также мы не пробегаемся по листьям, осталось учесть суффиксы, которые будут разветвляться
	\begin{lemma}
		$i$-ый суффикс разветвился $\Ra \forall j < i$ разветвился
	\end{lemma}
	\begin{proof}
		Если суффикс не разветвился (и не лист) $\Leftrightarrow$ он встречался раньше как подстрока. Пусть какой-то $j$-ый суффикс не разветвился, значит он встречается ранее как подстрока, т.е $s[j:n] = s[x:x+(n-j)]$, знаем, что $j < i$, поэтому $s[i:n] = s[x + (i-j) : x + (n-j)]$, значит и $i$-ый суффикс не разветвился. Противоречие c начальным условием \\
		%\cimg{ukkonen3.jpg}{}
		КАРТИНКА ДОКАЗАТЕЛЬСТВА ЛЕММЫ
	\end{proof}
	Таким образом, надо поддерживать самый длинный неразретвившийся суффикс, будем хранить его в переменной $pos$, как комбинацию вершины дерева, символа по которому надо пойти и сдвига на ребре ($pos$ может быть на середине ребра), $i$ "--- позиция начала суффикса
\item
	$ S \ra Sc $, что происходит с $pos$? \\
	$\forall j < i$ "--- уже листья \\
	При добавлении нового символа может быть 2 случая:
	\begin{itemize}
	\item[a)]
		все $j \geqslant i$ спускаются
	\item[b)]
		$i$-ый разветвился
	\end{itemize}
	\begin{minted}{cpp}
		while(не могу спуститься вниз){
			Разветвись
			i++;
			pos = suf[pos]
		}
		Спустись из pos по символу c
	\end{minted}
	Итак, нужно уметь взять суффиксную ссылку от $pos$
\item
	Суффиксные ссылки \\
	$\forall$ вершины храним $suf[v]$
	В процессе построения дереве уже имеющиеся суффиксные ссылки никак не меняются, как построить суфф. ссылки для уже имеющихся вершин? Суффиксную ссылку для созданной вершины будем проставлять при продление следующего суффикса.
	\begin{lemma}
		$suf[v]$ "--- вершина, а не середина ребра \\
		%\cimg{ukkonen4.jpg}{}
		КАРТИНКА СУФФИКСНЫЕ ССЫЛКИ
	\end{lemma}
	Вот как мы берем суффиксную ссылку от $pos = < v, char, shift >$
	\begin{minted}{cpp}
	v = suf[v];
	while (shift > 0){
		e = edge[v][s[k - shift]];
		shift = e.len
		v = e.to
		//последний прыжок неправильный, но понятно, как переделать
	}
	\end{minted}
\end{enumerate}

\begin{theorem}
	Построение суфф. дерева работает за $O(n)$
\end{theorem}
\begin{proof}
	Введем потенциал $\phi =$ количество вершин на пути от корня к $v$ ($v$ это начало ребра, на котором находится $pos$). При спуске потенциал увеличивается на 1, при взятии суффиксной ссылки уменьшается на 1, также знаем, что $\phi \leqslant n$ (самый длинный суффикс), поэтому $cnt(++) \leqslant n + cnt(--)$, откуда получаем оценку $O(n)$
\end{proof}

\section{Суффиксный автомат (нет в билетах)}

\begin{Def}
	Детирминированный конечный автомат = орграф с выделенной стартовой вершиной и множеством терминальных вершин \\
	$S \in V$ "--- стартовая вершина \\
	$T \subseteq V$ "--- множество терминальных вершин \\
	ИЗОБРАЖЕНИЕ ДКА \\
	ДКА принимает строку и двигается по ребрам, соотвутствующим очередному символу
\end{Def}

\begin{Def}
	Суфф. автомат "--- автомат, который принимает только суффиксы
\end{Def}

\textbf{Алгоритмы построения}
\begin{enumerate}
	\item
		Посжимаем одинаковые вершины в одну \\
		ИЗОБРАЖЕНИЕ СЖАТИЯ (10 шакалов из 10)
	\item
		$S \to Sc$
		\begin{Def}
			$R_s(v) = \{ w \mid vw$ "--- суфф. $s \}$ (множество правых контекстов строки) 
		\end{Def}
		\begin{exmp}
			$s = ababa$ \\
			$R_s(a) = \{\epsilon, ba, baba \}$ \\
			$R_s(aba) = \{\epsilon, ba \}$
		\end{exmp}
		\begin{lemma}
			$v$ "--- cуфф. $u \Rightarrow R_s(u) \subseteq R_s(v)$
		\end{lemma}
		\begin{lemma}
			$R_s(u) = R_s(v), |u| \geqslant |v| \Rightarrow v$ "--- суфф. $u$
		\end{lemma}
		\begin{lemma}
			$R_s(v) \cap R_s(u) \Rightarrow (R_s(v) \subset R_s(u), \text{$u$ "--- суфф. $v$}) \text{ ИЛИ } (R_s(u) \subset R_s(v), \text{$v$ "--- суфф. $u$})$
		\end{lemma}
		\begin{equation*}
		\text{Суфф. автомат}
		\begin{cases}
			next[v,c] \\
			suf[v] \\
			len[v] \\
			last \to T
			 
		\end{cases}
	\end{equation*}
	Пусть $last$ "--- вершина, которой соответствует $s$, тогда множество терминальных вершин это $T = \{last, suf[last], suf[suf[last]], \dots \}$
	\begin{lemma}
		В суффиксном автомате $\leqslant 2n$ вершин (без доказательства) 
	\end{lemma}
\end{enumerate}