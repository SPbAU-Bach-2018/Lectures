\chapter{Ахо-Корасик}
\setauthor{Розплохас Дима}

\section{Бор, Ахо-Корасик}

\subsection{Бор}

Бор - структура для хранения множества строк. Дерево, на каждом ребре которого написана буква. Каждой вершине дерева соответствует строчка - последовательность символов на пути до нее от корня. Вершины, соответствующие строкам из множества помечаются терминальными. 

Добавление строки:

\begin{cppcode}
struct Node {
    static const int ALPHABET = 26;
    int go[ALPHABET];
    bool is_terminal;
    
    Node() : is_terminal(false) {
        memset(go, -1, sizeof(go));
    }
};

Node nodes[MAX_SIZE];
int size = 1;

void add(const string &s) {
    int v = 0;
    for (int i = 0; i < s.size(); ++i) {
        int &ref = nodes[v].go[s[i] - 'a'];
        if (ref == -1)
            ref = size++;
        v = ref; 	
    }
    nodes[v].is_terminal = true;
}
\end{cppcode}

Аналогично выглядит проверка строки на принадлежность множеству - смотрим пришили бы мы в терминальную вершину, если бы добавляли эту строку.

Есть несколько вариантов хранения ребер ($V$ - число вершин, $\Sigma$ - размер алфавита, $LEN$ - длина обрабатываемой строки):

\begin{tabular}[c]{llll}
& Mem & Time & Примечания \\
\texttt{Array} & $\Sigma \cdot V$ & $LEN$ &  \\
\texttt{map<int, int>} & $V$ & $LEN \log \Sigma$ & \\
\texttt{unordered\_map<int, int>} & $V \cdot O(1)$ & $LEN \cdot O(1)$ & констаты могут быть заметными \\
\texttt{list< pair<int, int> >} & $V$ & $LEN \cdot \Sigma$ & ничем не лучше map \\
\texttt{SplayTree} & $V$ & $LEN + \log \Sigma$ & что это?\\
\end{tabular}

Сжатый бор это когда на ребрах написано не по одному символу, а какие-то подстроки данных строк.  
В реализации можно например хранить все добавленные строки и задавать надпись на ребре тремя числами - номер строки из которой взята подстрока, позиция первого символа подстроки и ее длина.

Добавление новой строки создает в сжатом боре максимум две новые вершины - терминальную и еще одну в том месте, где произошло первое несовпадение (если там не было вершины).

Бором можно сортировать строчки - добавим их все в бор и обойдем его в глубину (идем сначала по ребрам с меньшим символом). Тот порядок в котором мы встретим терминальные вершины - лексикографический порядок строк, им соответствующих.

Бор также можно использовать вместо \texttt{unordered\_map<string, T>}, если в терминальных вершинах хранить значения типа T. Вроде получится даже быстрее.

\subsection{Суффиксное дерево}

Суффиксное дерево некоторой строки - это бор построенный на всех ее суффиксах. Для строки длины $n$ размер несжатого суффиксного дерева $O(n^2)$, сжатого $O(n)$. Мы уже умеем строить его за $O(n^2)$ просто добавив все суффиксы.

Любая подстрока - это префикс некоторого суффикса строки, значит в суффиксном дереве ей соответсвует какая-то вершина. Поэтому построив суффиксное дерево, можем понять количество различных подстрок (число вершин в дереве) и для каждой подстроки получить
\texttt{count[v]} - число вхождений подстроки - это число терминальных вершин в поддереве $v$, L[v], R[v] - самое левое и правое вхождения.

LCP двух суффиксов - это LCA их вершин в суффиксном дереве, умеем считать в offline  за $O(1)$, значит LCP всех соседних суффиксов можем получить за $O(n)$. Обойдя суффиксное дерево мы получим и отсортированный массив суффиксов за $O(n)$.

Можно сделать и обратное преобразование - зная суффиксный массив $p_i$ и LCP соседних суффиксов $lcp(p_i, p_{i + 1})$ построить сжатое суффиксное дерево за $O(n)$.

Алгоритм: откладываем терминальные вершины суффиксов в лексикографическом порядке. Сначала откадываем от корня ребро в первую терминальную вершину и пишем на нем суффикс $p_1$. В процессе алгоритма храним стек вершин на пути от корня до очередной терминальной вершины. Чтобы добавить очередной суффикс $p_i$ (когда все меньшие уже добавлены) мы должны поднятся на пути от корня до $p_{i - 1}$ до глубины $lcp(p_{i - 1}, p_i)$, вынимая из стека все более глубокие вершины, и, если это середина ребра, создать там новую вершину, от котрой отложить терминальную, соответствующую $p_i$.

\subsection{Поиск словарных слов в тексте}

Задача: дан текст $T$ и набор словарных слов $S_1, S_2, \dots, S_n$ ($W$ - максимальная длина, $L$ - суммарная длина). Нужно найти в $T$ хоть одно слово из $S$.

Замечание: подразумевается, что текст - это непрерывный набор символов в котором мы ищем подстроку совпадающую со словарной. Если под текстом понимается набор слов, то уже умеем решать задачу хеш-таблицей за $O(|T| + L)$.

Алгоритм 1. Решение хешами.

Можно проверять вхождениее каждого слова отдельно алгоритмом Рабина-Карпа за $O(n |T|)$.

Можно за один проход проверить на вхождение все слова одной длины. Для этого создаем хеш-таблицу с хешами всех таких слов и так же как в Рабине-Карпе идем по тексту "окном" проверяя соотвестсвует ли текущий хеш какому-нибудь из таблицы. Запускаем цикл по всем длинам за $O(W |T|)$. Если быть точнее, это работает за $O(D |T|)$, где $D$ - число различных длин среди словарных слов. $D < \sqrt{2 L}$, так как даже если все длины различны и минимальны $L = \sum_i |S_i| = 1 + 2 + \dots + D = \frac{D (D + 1)}{2} > \frac{D^2}{2}$.

Алгоритм 2. Решение бором.

Строим бор на всех словах словаря.

FOR $i = 0 \dots |T| - 1$\\
Встаем в корень бора. Идем по тексту начиная с $i$-й позиции и одновременно спускаемся в боре по соответствующему символу. Пришли в терминальную вешину - нашли вхождение. Если соответсвующего ребра нет, переходим к следующему $i$.

Time =  $O(W |T|)$

Алгоритм 3. Ахо-Корасик

Сделаем из нашего бора детерменированный автомат. У нас уже есть вершины-состояния и переходы по некоторым символам. Мы будем идти по тексту и переходить по соответствующему символу в автомате. Мы хотим, чтобы автомат был устроен так, что текущее состояние автомата (после того как ему передали некоторый префикс) соответствовало строке - максимальному суффиксу этого префикса, который встречается в боре (то есть максимальному суффиксу этого префикса, который является префиксом некоторого слова словаря). Иначе говоря для словаря, состоящего из одного слова, мы хотим чтобы соcтояние в автомате, после того как мы передадим $[T_0, T_i)$ соответствовало префикс-функции строки $S_0\#[T_0, T_i)$, а если в словаре больше слов, то это должен быть аналог этой префикс-функции для случая, когда слева от символа '\#' стоит многообразие всех слов словаря.

Итак, те переходы, которые уже есть в боре вполне законны (в некоторой строке после максимального совпадающего префикса идет нужный символ), осталось добавить переходы по всем оставшимся символам из каждого состояния. Чтобы сделать это, введем понятие суффиксной ссылки. 

Суффиксная ссылка от вершины бора $v$ будет указывать на такую вершину бора $u$, которая соответствует собственному суффиксу $v$-строки, а среди таких выбирается суффикс максимальной длины (то есть самая глубокая вершина $u$ удовлетворяющая условию). Такая ссылка определена для всех некорневых вершин (потому что есть пустой суффикс - корень), для корня ее можно пустить в сам корень.

Теперь если из данноого состояния нет перехода по соответствующему символу, мы должны перейти по суффиксной ссылке и попытаться совершить переход из нее. Проходя по суффиксным ссылкам вверх, мы либо найдем нужное ребро, либо рано или поздно попадем в корень. Для корня разумно добавить ребра по недостающим символам, ведущие в себя (в этом случае больше чем пустой суффикс получить не удастся). Итак, если мы сможем посчитать суффиксные ссылки $suff[v]$ для всех вершин бора, то мы сможем делать переходы по любым символам:

\begin{cppcode}
while (nodes[v].go[c] == -1)
	v = suff[v];
v = nodes[v].go[c];
\end{cppcode}

Исходя из структуры автомата, мы можем вычислить суффиксную ссылку для вершины, если знаем суффиксные ссылки для всех вершин меньшей глубины. А именно возьмем у нашего родителя суффиксную ссылку и перейдем от этой вершины по символу на ребре из нашего родителя в нас.

\begin{cppcode}
x = suff[parent[v]]
while (nodes[x].go[c[v]] == -1)
	x = suff[x];
suff[v] = nodes[x].go[c[v]];
\end{cppcode}
 
Таким образом, чтобы построить автомат Ахо-Корасик на данном словаре сначала построим на нем бор за $O(L)$, установим \texttt{suff[root] = root}, а затем обойдем бор bfs-ом и для каждой вершины вычислим ее суффиксную ссылку кодом выше. Заметим, что подсчет суффиксных ссылок всех вершин на любом пути от корня до какой-то вершины $v$ работает за $O(depth(v))$ - после того как поднимемся на какую-то глубину $d$ для подсчета ссылки очередной вершины, подсчет ссылки следующей на пути начнем с этой глубины $d$, то есть мы не теряем прогресс и подъемов делаем не больше, чем спусков, и всего $O(depth(v))$ действий. Если возьмем пути до всех терминальных вершин, то покроем весь бор, а значит таким образом мы посчитаем ссылки также за $O(L)$. 

Теперь можем решить исходную задачу. Конечными состояниями автомата логично принять те, которые являются терминальными вершинами, или те, из которых до какой-то терминальной вершины можно добраться по суффиксным ссылкам (то есть это слово из словаря - один из суффиксов текущего префикса). Конечность вершинам можно так же расставить во время \texttt{bfs} вместе с вычислением суффиксных ссылок. Теперь будем последовательно переходить в автомате по символам из текста и, придя в конечное состояние получим вхождение словарного слова. Не смотря на то, что некоторые переходы могут занять у нас не $O(1)$ можно так же заметить, что подъемов мы сделаем не больше чем спусков и весь алгоритм работает за $O(L + |T|)$.

С помощью этого автомата можно решать некоторые модификации данной задачи. Например, для каждого словарного слова узнать сколько раз оно встречается в тексте. Снова пройдемся в автомате по  всем символам текста и, заходя в очередное состояние $v$, будем делать \texttt{count[v]++}. Теперь поймем, что мы встречали вхождение некоторого слова, соответсвующего терминальной вершине $t$, тогда и только тогда, когда из текущего состояния $v$ можно было попасть в $t$ по суффиксным ссылкам: в эти моменты слово является суффиксом строки, соответствующей $v$. Поэтому чтобы получить ответ на задачу мы должны протолкнуть count вверх - идя снизу для каждой вершины сделать \texttt{count[suff[v]] += count[v]} и вернуть значения count в терминальных вершинах. Если вместо \texttt{count[v]} поддерживать первый/последний момент времени, когда мы побывали в этом состоянии, а в конце так же проталкивать эти значения по суффиксным ссылкам выбирая минимум/максимум, то получим для всех слов первое/последнее вхождение в текст соответственно.

Можно также не вычислять все суффиксные ссылки заранее, а воспользоваться принципом ленивой динамики и изначально считать все ссылки (кроме корневой) неопределенными и вычислять ссылку рекурсивно в первый раз, когда она понадобилась.
