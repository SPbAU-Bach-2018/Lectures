\setauthor{Юрий Кравченко} 
\begin{Rem}
Наибольшая общая подстрока = бинпоиск + хэши + хэш-таблица. Рещение за $O(n \log n)$. Для $k$ строк за  $O(kn \log n)$
\end{Rem}
\chapter{Палиндромы}
Задачи про палиндромы чаще всего решаются для палиндромов чётной и нечётной длинны независимо, и, чтобы не копировать код, можно писать:
\begin{cppcode}
for (int t = 0; t < 2; ++t) {
	...
}
\end{cppcode}

Задачу про наибольший общий подпалиндром решите сами =)

Максимальны чётный палиндром за $O(n)$
\begin{cppcode}
for (i, n) {
	while [i - (m + 1), i) == [i, i + (m + 1)) {
		m++; \\ не больше n / 2 раз
	}
}
\end{cppcode}
Алгоритм Манакера для поиска количесва палиндромов в центре с заданной точкой за $O(n)$ (в данном примере только для чётных)\\
Пусть мы хотим посчитать ответ для позиции $i$ (R[i]), а текущий самый правый палиндром - $a, a + 1, ..., b$. Если $i$ между $a$ и $b$, то рассмотрим позицию $j = (a + b - i)$. Она очень похожа на $i$, потому что они самметричны относительно центра палиндрома и $R[i] >= \min(R[j], b - i)$. Если $R[j] >= b - i$ нужно попробовать увеличить ответ для $R[i]$  за границы палиндрома $a, a + 1, ...,  b$ и обновить палиндром $a, a + 1, ...,  b$, т.к. у нас мог получиться палиндром длиннее.
\\
\cimg{17.1.png}{}
\begin{cppcode}
a = b = 0;
for (i, n) {
	R[i] = i > b ? 0 : min(b - i, R[j]);
	while можем увеличить палиндром {
		R[i]++;
	}
	if (i + R[i] > b) {
		a = i - R[i];
		b = i + r[i];
	}
}
\end{cppcode}
работает за $O(n)$ потому что каждый R[i]++ по сути увеличивает $b$ на $1$, а $b <= n$

\begin{theorem}
Различных палиндромов не больше $n$
\end{theorem}
\begin{proof}
В позиции $i$ заканчивается только один новый палиндром. Пусть не так, тогда меньший из двух уже встречался в начале большего. 
\end{proof}
\cimg{17.2.png}{}

Хотим посчитать число различных палиндромов, используя R.

\begin{cppcode}
a = b = 0;
for (i, n) {
	for (k = R[i], 0) {
		if ((i - k, ..., i + k) - новый) {
			добавим
		}
		else {
			break; //меньшие уже добавили
		}
	}
}
\end{cppcode}

работает за $O(n)$ т.к. различных палиндромов $O(n)$

Хотим построить дерево палиндромов. Вершины - палиндромы.       Из палиндрома $A$ есть ребро $b$ в палиндром $C$, если $bAb = C$. Из палиндрома $A$ есть суффиксная ссылка в палиндром $C$, если $A = BC$ и $C$ максимально. Есть вершины $.$ и $-1$. 

\cimg{17.3.png}{}

\begin{cppcode}
Vertex{
suf, len, next[26];
count;
};
Vertex t[n + 2];

add(s, i, c) {
	while (v $\neq$ 0 && s[i - t[v]].len - 1] $\neq$ c) {
		v = t[v].suf;        //t[v].len--;	
	}
	int  &x = t[v].next[c];
	if (x == -1) {
		x = vn++;
		t[x].len = t[v].len + 2;
		if (v == 0) {
			t[x].suf = 1;
		}
		else {
			v = t[v].suf;
			while (--||--) {
				--||--; 	\\такой же самый whilie
			}
			t[x].suf = t[v].next[c]; //+2
		}
	}
	v = x; //+2
	// строчки ниже для подсчёта числа различных палиндромов
	t[v].count++;
	for (v, t[v].len) {
		t[t[v].suf].count += t[v].count		
	}
}	
\end{cppcode}

Время работы $O(n)$, т.к. t[v].len уменьшается не больше, чем увиличивается, а увеличивается по $+2$ $O(n)$ раз.

\begin{cppcode}
getNext(v, c) {
	int & r = next[v, c];
	if (r == -1) {
		r = getNext(getSuf(v), c);
	}
	return r;
}

getSuf(v, c) {
	int &r = suf[v];
	if (r == -1) {
		r = getNext(getSuf(p[v]), c[v]);
	}
	return r;
}
\end{cppcode}

