\section{Mincost Flow, Circulation, Hungrian Method}
\setauthor{Анастасия Старкова}

\subsection{Mincost Flow}
\begin{lemma}
	\[ 
		\forall |f_1|=|f_2|\colon f = f_2 - f_1 \text{-- циркуляция в } G_{f_1}
	\]
\end{lemma}
\begin{proof}
	Проверяем 3 утверждения:
	\begin{enumerate}
		\item $f \le c$  (В $G_{f_1}$ пропускная способность $c(e) - f_1(e) \Rightarrow f_2(e) - f_1(e) \le c(e) - f_1(e)$)
		\item $\overline{f} = -f$
		\item $\sum$ равна нулю
	\end{enumerate}
\end{proof}

Отсюда получаем следствие: $\forall$ Max поток $f = f^* + circ$, где $f^*$ -- это какой-то max-поток.


\subsection{Mincost k-flow, Mincost max-flow, Mincost Flow, Mincost Circulation и их сведение друг к другу}
	\begin{enumerate}
		\item Mincost k-flow -- поток минимальной стоимости, где $|f| = k$.
		\item Mincost max-flow -- из всех потоков, где $|f| = max$ выбираем поток с минимальной стоимостью.
		\item Mincost Flow -- мы стремимся минимизировать стоимость потока $cost(f) \to min$.
		\item Mincost Circulation -- $|f| = 0$ -- частный случай k-flow. 
	\end{enumerate}	

Уточнение: пусть по ребру течет поток $f$, а его стоимость равна $c$. Добавим в граф обратное ребро с потоком $-f$ и стоимостью $-c$, чтобы иметь возможность "отменять" поток когда мы проходим по такому обратному ребру.

Тогда $cost(f) = \frac{1}{2}\sum_{\text {по всем ребрам}} f_e\cdot c_e$ ($\frac{1}{2}$ -- если считаем с учетом обратных ребер: $fc + (-f)(-c)$)

\begin{lemma}
	Сведение.Если мы хотим из потока определенного размера получить поток такого же размера, но минимальной стоимости, нам нужно прибавить к нему циркуляцию минимального веса.
\end{lemma}
\begin{proof}
	Напрямую следует из первой леммы.
\end{proof}

Комментарии к слудующей лемме:
	
В следующей лемме фигурирует понятие остаточной сети. Концепция остаточной сети $G_f$ следующая: пусть по нашему ребру $e$ течет поток $f_e$, а его пропускная способность $u_e$. Тогда теоретически мы можем по этому ребру пустить еще $u_e - f_e$ потока. Назовем эту величину 
пропускной способностью остаточной сети. Стоимость же таких дополнительных единиц потока оставим такой же.

Также применим в остаточной сети идею разделения одного ребра на 2 ориентированных, чтобы иметь возможность "отменять" поток. Ее мы обсудили раньше, заметим только, что величина пропускной способности остаточной 
сети у прямого и обратного ребра будет одинаковой. Теперь мы готовы сформулировать лемму.

\begin{lemma}
	\[ 
		|f| = k \colon cost(f) = min \Leftrightarrow \nexists \text{ отрицательных циклов в остаточной сети } G_f.	
	\]
\end{lemma}
\begin{proof}
	\begin{enumerate}
		\item Необходимость. 
		
		Предположим, что остаточная сеть содержит цикл отрицательного веса. Тогда посмотрим на пропускные спобобности остаточной сети для всех ребер этого цикла и выберем среди них минимум. 
		Заметим, что мы можем увеличить на эту величину поток вдоль всех ребров нашего цикла и уменьшить тем самым стоимость потока (она уменьшится на стоимость цикла, умноженную на величину этого самого минимума).
		А это противоречит оптимальности $f$.

		\item Достаточность. 
		
		Мы уже умеем делать декомпозицию потока, т.е. раскладывать его на пути и циркуляцию. Также мы можем показать, что для двух потоков $f$ и $g$ одинакового размера верно, что $g$ можно 
		представить как $f +$ несколько циклов в остаточной сети $G_f$. Рассмотрим разность $g - f$ -- это почленное вычитание (вычитание потоков вдоль каждого ребра). Исходя из условия, у нас получится некоторый
		поток нулевой величины (это циркуляция по определению). Произведем декомпозицию этой циркуляции на пути и циклы. Но! Заметим, что если бы в разложении присутствовали пути из истока в сток с положительным 
		потоком, это означало бы, что величина потока в сети тоже положительна. А мы имеем дело с циркуляцией. Значит в результате декомпозиции она разложится на несколько циклов. Значит разность $g - f$ можно
		представить как сумму циклов в сети $G$. Но в остаточной сети это также будут циклы, т.к. $g_e - f_e \le u_e - f_e$, а это и есть пропускная способность остаточной сети.

		Теперь мы готовы доказать достаточность: рассмотрим поток $f$, в остаточной сети которого нет циклов отрицательной стоимости. Пусть $f^*$ -- поток того же размера, но минимальной стоимости. Т.к.
		размеры потоков совпадают, то $f^*$ можно представить как $f +$ несколько циклов. Т.к. стоимости всех циклов неотрицательны, то стоимость $f^*$ явно не меньше, чем $f$. Но в силу оптимальности выбора $f^*$
		его стоимость не больше стоимости $f$, а значит они совпадают. А это значит, что наш поток $f$ минимален по стоимости. 
	\end{enumerate}
\end{proof}

{\bfseries Алгоритм}\\

\begin{cppcode}
	while (exists cost(cycle) < 0) // Пока есть отрицательный цикл, добавляем его к ответу и проталкиваем по максимуму столько, сколько сможем 
		f += cycle * min(u_e - f_e) // cycle -- длина цикла, min по пропускной способности
\end{cppcode}

{\bfseries Время работы}\\
$O(mUC)\cdot$ поиск цикла (например, мы можем искать цикл алгоритмом Гольдберга за $m\sqrt n \log C$).\\

{\bfseries Алгоритм 2. Mincost Circulation $\to$ Mincost k-flow}
\begin{cppcode}
	for k
		f += ShortestPath in G_f	
\end{cppcode}

{\bfseries Доказательство корректности по индукции:}\\
\begin{proof}
{\bfseries База:} $f_0$ -- mincost\\
{\bfseries Индукционный переход:} $f_i$ -- mincost $\Rightarrow$ $f_{i+1}$ -- mincost\\
Рассмотрим $f^*_{i+1} - f_i$ в остаточной сети $G_{f_i}$. По лемме 1 это циркуляция. $f^*_{i + 1}$ -- поток минимальной стоимости размера $i + 1$. Разложим его на путь и циркуляцию ($\ge 0$ по предположению о
том, что поток минимальной стоимости). $f^*_{i+1}$ получаем из $f_{i+1}$ добавлением минимального по стоимости пути $Rightarrow$ получаем объект не худшей стоимости.\\
\end{proof}
{\bfseries Улучшаем алгоритм:}\\
Shortest Path $\to$ FB \\
Shortest Path $\to$ Dijkstra \\

Но проблемой являются отрицательные веса. Чтобы от них избавиться, перед запуском Дейкстры, запустим Форда-Беллмана:
\begin{enumerate}
	\item FB\\
		 $p[v] = distance[v]$\\
		 $w_e' = p[a] + w_e - p[b] \ge 0$
	\item Dijkstra
\end{enumerate}
{\bfseries Проблема:} тут мы подразумеваем, что веса не меняются, а по факту могли "открыться" обратные отрицательные ребра.\\
{\bfseries Решение проблемы:} $\forall v: p[v] += distance[v]$ -- хотим сказать, что если теперь ребро в кратчайшем пути, то оно будет веса 0 $\Rightarrow$ и обратное будет веса 0.\\
{\bfseries Функция пересчета весов:}
\begin{cppcode}
	Apply(w, p) {
		for w_e = ...    // Пересчитываем вес ребра с учетом потенциалов
	Apply(w, distance)   // Наш потенциал - расстояние
\end{cppcode}

\begin{lemma}
	Расстояния увеличиваются.
\end{lemma}
\begin{proof}
	Без доказательства, аналогичная уже доказана.
\end{proof}

\begin{cppcode}
	while |f| < k
		f += ShortestPath * min(u_e - f_e), k - |f| 
\end{cppcode}
Хотим найти поток размера k, ограничиваем этим размер\\
Сильно уменьшили $k$ -- улучшили асимптотику (но не знаем, во сколько)\\

{\bfseries Диниц:}\\
Все пути, длина которых совпадает с кратчайшим - сеть кратчайших путей.\\
{\bfseries Алгоритм:}
Мы или идем по слоям (если можем), а если не можем -- ищем максимальный поток.
\begin{cppcode}
	f = 0;
	while FB
		df = Maxflow в сети кратчайших путей
	f += df;
\end{cppcode}

Хотим добавить поток (мы знаем, что поток представим в виде нескольких путей и циркуляции).\\
Добавили кратчайший путь, по лемме нового кратчайшего возникнуть не могло, значит след. будет кратчайшим ($w2$).\\
{\bfseries NB!}\\
FB с очередью в mincost потоках работает не за $O(VE)$, а за $E + Maxflow$, поэтому мы не паримся с улучшением поиска кратчайших путей.\\

\subsection{Назначения, Транспортная задача}
{\bfseries Назначения} \\
Имеется некоторое число работ и некоторое число исполнителей. Любой исполнитель может быть назначен на выполнение любой (но только одной) работы, но с неодинаковыми затратами. 
Нужно распределить работы так, чтобы выполнить работы с минимальными затратами, то есть $\sum_i C_ip_i \to \min$.\\
{\bfseries Решение:}\\
$O(E) + n\cdot Dijkstra$ // $O(E)$ -- динамическое программирование, на практике это все получается за $O(n^3)$\\

{\bfseries Транспортная задача} \\
Задача об оптимальном плане перевозок некоторого однотипного продукта из пунктов производства в пункты потребления по некоторой дорожной сети на однотипных транспортных средствах.\\
{\bfseries Решение задачи}\\
Объединим всех производителей в исток, а потребителей в сток и рассмотрим получившийся двудольный граф. Соединим попарно производителей и потребителейя рёбрами бесконечной пропускной способности 
и цены за единицу потока. К производителям присоединим фиктивный исток. Пропускная способность рёбер из истока в каждого производителя равна количеству продукта в этом пункте. Цена за единицу потока 
у этих рёбер равна 0. Аналогично к потребителям присоединяем сток. Пропускная способность рёбер из каждого потребителя в сток равна потребности в продукте у данного потребителя. Цена за единицу потока 
у этих рёбер тоже равна 0. Дальше решается задача нахождения максимального потока минимальной стоимости (mincost maxflow).

\subsection{Mincost Flow to Mincost Circulation}
\begin{cppcode}
	f_0 = min_circ
	while ShortestPath < 0
		f += ShortestPath*...
\end{cppcode}

\subsection{Быстрый Mincost Flow}
Мы уже умеем сводить к Mincost Circulation.\\
\begin{enumerate}
	\item Mean Cycle Canceling -- вычеркиваем цикл минимального среднего веса.\\
	$\log (nC) \cdot mn$ 
	
	$mn$ -- находим цикл алгоритмом Карпа, $\log n$ -- крутые структуры данных
	\item Capacity Scaling \\
	$for k = 30..0\\
	u' \gets \frac{u}{2^k}\\
	Algo(u')$ 
	\item Удалим ребро, добавим ребро\\
	Возьмем любое ребро, удалим его, найдем Mincost Circulation, добавим обратно.\\
	Mincost Circulation = $m\cdot Mincost Flow$ // Когда добавляем ребро -- ищем min поток из $s$ в $t$ на графе, где точно нет отриц. циклов.
	\item Cost Scaling\\
	$(-c; +\inf) \to (-c/2; +\inf)$\\
	Описание одной фазы: пустили поток, применили потенциалы:
	\begin{cppcode}
	f += df
	Apply(w, p)
	\end{cppcode}
	\begin{lemma}
	Таких фаз не больше, чем $\log(nC)$
	\end{lemma} 
\end{enumerate}

\subsection{Hungrian Method}
\paragraph{Постановка задачи}
Задача, которую решает данный алгоритм - задача о назначениях в ее классической постановке.\\
Переформулируем ее в матричном виде. Дана неотрицательная матрица размера $n × n$, где элемент в $i$-й строке и $j$-ом столбце соответствует стоимости выполнения $j$-ого вида работ $i$-м работником. Нужно 
найти такое соответствие работ работникам, чтобы расходы на оплату труда были наименьшими. Если цель состоит в нахождении назначения с наибольшей стоимостью, то стоимости $C$ заменяются соответственно на разность 
между максимальной стоимостью и $C$, а суть решения не меняется.\\
\paragraph{Решение задачи}
У нас есть матрица, клеточки которой показывают соответствие работы и исполнителя.
\begin{enumerate}
	\item Уменьшаем элементы построчно. Находим наименьший из элементов первой строки и вычитаем его из всех элементов первой строки. При этом хотя бы один из элементов первой строки обнулится. 
	То же самое выполняем и для всех остальных строк. Теперь в каждой строке матрицы есть хотя бы один ноль. Иногда нулей уже достаточно, чтобы найти назначение.
    \item Если нулей много, мы можем воспользоваться алгоритмом Куна нахождения наибольшего паросочетания в двудольном графе (если $ij = 0$, значит в нашем графе есть ребро $i \to j$). А также мы проверяем,
    возможно ли решение в принципе. Так, если в каком-то из столбцов не будет нулей, то задача не имеет решения.
    \item Если мы не нашли назначения, мы повторяем те же действия, но теперь со столбцами (ищем минимум и вычитаем) и проверяем на возможность.
    \item Если после этого шага не возникло противоречий с разрешимостью задачи, но ответ тем не менее не найдем, то мы будем делать следующее. Сначала используем алгоритм Куна для поиска максимального
    паросочетания, чтобы отдать как можно больше подходящих работ людям, которые их выгоднее всего сделают. Это как раз те ячейки, значение в которых сейчас 0. Дальше мы помечаем все строки без назначений,
    столбцы, в которых на пересечении с такими строками стоят нули и строки, в которых на пересечении с такими столбцами стоят работы, которые уже назначены. И выделяем все помеченные столбцы и непомеченные 
    строки. Это все мы сделали для того, чтобы провести наименьшее количество линий, которые покроют все нули.
    \item Из непокрытых линиями элементов матрицы находим наименьший, вычитаем его из всех неотмеченных строк и прибавляем к пересечениям выделенных строк и столбцов.
    \item Итак, теперь у нас все непокрытые жлементы не меньше нуля, плюс существует новый ноль (мы выбрали какой-то элемент из неотмеченных, при вычитании соответствующая ему клеточка занулилась).
    \item Повторяем, пока не нашлось решение.
\end{enumerate}
 

 
