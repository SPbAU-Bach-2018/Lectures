\chapter{Функции на путях}

Примеры функций: сумма, минимум.

Путь: ребра от $a$ до $b$, где $a$ и $b$ "--- вершины дерева.

Варианты: сумма весов вершин или сумма весов ребер.
Достаточно научиться считать для ребер и построить биекцию между ребрами и вершинами.
Биекция: каждой вершине сопоставляем ребро в отца.
Для корня можем сделать фиктивное ребро.

\section{Сумма на пути, дерево не меняется. $T = O\left(1\right)$}

\begin{enumerate}
	\item Ищем LCA за $O\left(1\right)$.
	\item Используем массив \verb's' "--- массив префиксных сумм.
	\item Ответ будет таким: \cpp's[a] + s[b] - 2*s[LCA]'
\end{enumerate}

\cimg{Lect8_1.jpg}{0.5}

\begin{Rem}
	Когда мы пытаемся что-то сделать на дереве, сначала надо попытаться провести аналогию с массивом (частным случаем дерева),
	разбив путь на два вертикальных отрезка.
\end{Rem}

\cimg{Lect8_2.jpg}{0.5}

\section{Сумма на пути, дерево меняется}

Запросы:
\begin{enumerate}
	\item \cpp'get(a, b)' "--- найти функцию на пути из $a$ в $b$.
	\item \cpp'w[e] = x' "--- изменить вес ребра $e$ на $x$.
\end{enumerate}

Решение:
Используем Эйлеров обход с ориентированными ребрами (каждое в двух экземплярах: $+w$, если спускаемся, $-w$, если поднимаемся).

Тогда суммой на пути будет значение от любого вхождения LCA до любого вхождения $a$.
Все ненужные ребра сократятся, так как если сворачивали с кратчайшего пути, то обязательно возвращались обратно.
Однако, обычно берут первые вхождения, тогда и сумма получается с нужным знаком.

Чтобы изменить ребро, необходимо изменить его вес в Эйлеровом обходе.

Таким образом, обе операции работают за $O(\log n)$.

Код построения Эйлерова обхода:

\begin{cppcode}
go(v) {
	pos[v] = n; // сохраняем позицию вершины в обходе (первое вхождение)
	for (auto e: edges[v]) { // по всем ребрам из v, идущим в x
		first[e] = n;
		a[n++] = w(e); // в a храним обход
		go(x);
		second[e] = n;
		a[n++] = -w(e);
	}
}
\end{cppcode}

\section{LCA-Offline. \texorpdfstring{$T = O\left(A^{-1}(m, n)\right) = O^*\left(1\right)$}{T = O(A^-1(m, n)) = O*(1)}}

Будем использовать СНМ вершин, которые уже обошли, и множество вершин от корня до текущей.
Таким образом, из любой вершины, из которой уже вышли, легко посчитать LCA с вершиной $v$ (стоим в ней сейчас).

\cimg{Lect8_3.jpg}{}

\begin{cppcode}
void go(v) {
	color[v] = 1; // для СНМ
	for (int a: List[v]) // список вопросов, связанных с v
		if (color[a] == 1)
			LCA = get(a); // возвращает представителя
	for (int x: edges[v]) { // для всех соседей $v$
		go(x)
		join(x, v)
	}
}
\end{cppcode}

\section{RMQ-Offline (минимум на отрезке)}

\begin{description}
\item[Способ 1:]
	Сводим RMQ к LCA, решаем LCA Offline

\item[Способ 2:]
	\begin{enumerate}
	\item
		Перебираем правую границу в порядке возрастания (левая "--- произвольная)

	\item
		На всем отрезке есть минимальный элемент (с индексом $m_i$)

	\item
		Ответом будет $m_i\colon: i = min: L < m_i$
		Пояснение:   $a[m_1] \le a[m_2] \le ...; m_1 = 	{min}[1; R], m_{i+1} = 	{min}[m_i + 1; R]$
		Если храним отрезки в СНМ, то ответ "--- get к СНМ. Представитель: самый правый элемент в отрезке.
	\end{enumerate}
\end{description}

\begin{cppcode}
for (i = 0; i < q; ++i) // запросы
	List[R[i]].push_back(L[i]);
for (i = 0; i < n; ++i) // запросы
	p[i] = i; // Init DSU
stack<int> m;
for (int r(0); r < n; ++r)
	while (m.size() > 0 && a[get(m.top())] >= a[R])
		p[get(m.top())] = R;
		m.pop();
	m.push(R);
	for (int i: List[R])
		min[i] = get(L[i]);
//...
int get(v) {
	return (v == p[v]) ? v : (p[v] = get(p[v]));
}
\end{cppcode}

\section{Рандомизированный алгоритм построения MST за линейное время}

Вспомним алгоритм Борувки (он умеет за линию в два раза уменьшать число вершин) и применим три раза.
Тогда, из имевшихся $(n, m)$ получим $\left(\frac{n}{8}, m\right)$.
После этого возьмем случайную половину ребер и запустимся от этого рекурсивно.

Скажем, что ребро $(a, b)$ потенциально хорошее, если вес этого ребра меньше,
чем максимальное ребро на пути из $a$ в $b$ в полученном остовном дереве (то есть при замене мы можем что-то улучшить),
или если эти вершины лежат в разных компонентах связности.

Теперь, для ребра надо быстро определять является ли оно хорошим.
Другими словами, найти $\max\{a, b\}$. Для этого используем RMQ за $O(1)$.

Докажем линейность времени работы.
Когда переходим в рекурсию, у нас остается $\frac{n}{8}$ вершин, $\frac{n}{8}$ из остовного дерева
и $\frac{n}{8}$ хороших (об этом будет сказано позже) ребер.
\[ T(n, m) = O(m) + T\left(\frac{n}{8}, \frac{m}{2}\right) + T\left(\frac{n}{8}, \frac{n}{4}\right) \]
По индукции докажем, что $T = O(m)$. Для этого заменяем $O(m)$ на $cm$ и выносим $c$ за скобку:
\[ T(n, m) = m + 2\left(\frac{n}{8} + \frac{m}{2}\right) + 2\left(\frac{n}{8} + \frac{n}{4}\right) = n + 2m \le 2(n + m) \]

Чтобы оценить количество хороших ребер, докажем следующую лемму (в нашей задаче параметр $p$ будет равен  $\frac{1}{2}$):

\begin{lemma}
	Если $H$ "--- подграф $G$ такой, что любое ребро взято с вероятностью $p$, то в $G$
	$E$[хороших ребер относительно 	{MST} $H$] $\le (n - 1)(\frac{1}{p} - 1)$
\end{lemma}
\begin{proof}
	Хорошее ребро "--- такое ребро, которое добавил бы алгоритм Краскала от $G$, следовательно таких событий (добавлений ребра) $n - 1$.
	С вероятностью $p$ мы добавим его в $H$, значит с вероятностью $1 - p$ оно станет хорошим, значит, нужно оценить количество таких событий.
\end{proof}

\begin{cppcode}
sort(edges.begin(), sort.end())
for (edge e: edges) {
	if get(a[e]) == get(b[e]) //это условие выполнится $\frac{n - 1}{p}$ раз
		if (p) // с вероятностью $p$
			Join(a[e], b[e]) // $n - 1$
		else
			GoodEdges.add(e) // $\frac{n - 1}{p} - (n - 1)$
}
\end{cppcode}

\begin{Rem}
	Если алгоритм Краскала не включил $e$ в подостов, то в остове этого ребра тоже не будет.
\end{Rem}
\begin{Rem}
	Рекурсия обрывается, когда остается одна вершина (сама себе остов).
\end{Rem}

Итоговое время работы:
\begin{description}
\item[Среднее:]
	$O(n + m)$

\item[Худшее:]
	$\min\left\{O\left(n^2\right), O(m \log n)\right\}$
	(если осталось $\frac{m}{2}$ хороших ребер, но от кратных ребер избавляемся, значит, на каждом шаге не больше $n^2$ ребер)
\end{description}

\section{Min-offline \texorpdfstring{$T =  O^*(1)$}{T = O*(1)}}

\rimg{Lect8_4.jpg}{}

Пути вертикальны, значит перебираем в порядке возрастания верхних границ, новый вес вершины "--- минимальный на соответствующем пути.
Применяем эвристику сжатия путей, получаем $O(\log n)$.
Преобразования корректны, так как $u$ возрастает.

\begin{cppcode}
for u in ascending // верхняя граница запроса
	for x: p[x] = u
		Join(x, u)
	for d in ascending // нижняя граница запроса
		ans = get(d)
\end{cppcode}

Теперь о подвешивании (\t{Join}): если $w[u] \le w[x]$ может и так, и так подвесить.
Чтобы минимумы остались теми же, надо будет \cpp'w[x] = w[u]'.

\begin{enumerate}
	\item $p[x] = u$ "--- подвешивание оригинальное, не меняет дерева.
	\item $p[u] = x$ "--- альтернативное подвешивание, меняет дерево.
\end{enumerate}

Если же $w[u] > w[x]$, то для поддерева $x$ ответ должен быть меньше и подвешивать надо по-особенному, подробно расскать об этом не успели.

\cimg{Lect8_5.jpg}{0.5}
