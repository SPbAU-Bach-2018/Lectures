\chapter{Функции на путях}
	Примеры функций: сумма, минимум.

	Путь: ребра от $a$ до $b$, где $a$ и $b$ -- вершины дерева. 

	Варианты: сумма весов вершин или сумма весов ребер. Замечание: достаточно научиться считать для ребер и построить биекцию между ребрами и вершинами.

	Биекция: каждой вершине сопоставляем ребро в отца. Для корня можем сделать фиктивное ребро. 


  \section{Сумма на пути, дерево не меняется. $T = \O\left(1\right)$}
	1. Ищем \texttt{LCA} за $\O\left(1\right)$. 

	2. Используем массив s -- массив префиксных сумм. 

	3. Ответ будет таким: $s[a] + s[b] - 2s[\texttt{LCA}]$ 


\includegraphics[width=3in]{Lect8_1.jpg}

	Замечание: когда мы пытаемся что-то сделать на дереве, сначала надо попытаться провести аналогию с массивом (частным случаем дерева), разбив путь на два вертикальных отрезка. 

  
\includegraphics[width=4in]{Lect8_2.jpg}

  \section{Сумма на пути, дерево меняется}
	Запросы: 

	1. \texttt{get}($a$, $b$) -- найти функцию на пути из $a$ в $b$.

	2. $w[e] \leftarrow x$ -- изменить вес ребра $e$ на $x$. 

	Решение: 

	Используем Эйлеров обход с ориентированными ребрами (каждое в двух экземплярах: $+w$, если спускаемся, $-w$, если поднимаемся). 

	Тогда суммой на пути будет значение от любого вхождения \texttt{LCA} до любого вхождения $a$. Все ненужные ребра сократятся, т.к. если сворачивали с кратчайшего пути, то обязательно возвращались обратно. Однако, обычно берут первые вхождения, тогда и сумма получается с нужным знаком.

	Чтобы изменить ребро, необходимо изменить его вес в Эйлеровом обходе. 

	Таким образом, обе операции работают за $\O\left(\log{n}\right)$. 

	Код построения Эйлерова обхода: 

\begin{cppcode}
          \item \hspace{0em} go(v)
          \item \hspace{2em}   pos[v] = n // сохраняем позицию вершины в обходе (первое вхождение)
          \item \hspace{2em}   for e: // по всем ребрам из $v$, идущим в $x$
          \item \hspace{4em}   first[e] = n
          \item \hspace{4em}   a[n++] = w(e) // в $a$ храним обход
          \item \hspace{4em}   go(x)
          \item \hspace{4em}   second[e] = n 
          \item \hspace{4em}   a[n++] = -w(e)
\end{cppcode}

  \section{LCA-Offline. $T = \O\left(A^{-1}(m, n)\right) = \O^*\left(1\right)$}
       Будем использовать СНМ вершин, которые уже обошли, и множество вершин от корня до текущей. Таким образом, из любой вершины, из которой уже вышли, легко посчитать \texttt{LCA} с вершиной $v$ (стоим в ней сейчас).


\includegraphics[width=4in]{Lect8_3.jpg}

\begin{cppcode}
go(v)
	color[v] = 1 // для СНМ
	for a in List[v] // список вопросов, связанных с v
		if (color[a] == 1)
			LCA = get(a) // возвращает представителя
	for x: // для всех соседей $v$
		go(x)
		join(x, v)
\end{cppcode}

  \section{RMQ-Offline (минимум на отрезке)}

	Способ 1: Сводим \texttt{RMQ} к \texttt{LCA}, решаем \texttt{LCA} Offline 

	Способ 2: 

		1. перебираем правую границу в порядке возрастания (левая – произвольная) 

		2. на всем отрезке есть минимальный элемент (с индексом $m_i$) 

		3. ответом будет $m_i$: $i$ – \texttt{min}: $L$ < $m_i$ 

	Пояснение:   $a[m_1] \le a[m_2] \le ...; m_1 = \texttt{min}[1; R], m_{i+1} = \texttt{min}[m_i + 1; R]$ 

	Если храним отрезки в СНМ, то ответ – get к СНМ. Представитель: самый правый элемент в отрезке.


\begin{cppcode}
for i = 1..q // запросы 
	List [R[i]].push\_back(L[i])
for i = 1..n // запросы
	p[i] = i // Init DSU
Stack m
for R = 1..n
	while (m.size() > 0 \&\&  a[get(m.top())] >= a[R])
		p[get(m.top())] = R
		m.pop()
	m.push(R)
	for i in List[R]
		min[i] = get(L[i])

get(v)
	return (v == p[v] ? v : (p[v] = get(p[v])))
\end{cppcode}

  \section{Рандомизированный алгоритм построения MST за линейное время}

	Вспомним алгоритм Борувки (он умеет за линию в два раза уменьшать число вершин) и применим три раза. Тогда, из имевшихся $(n, m)$, получим $(\frac{n}{8}, m)$. После этого возьмем случайную половину ребер и запустимся от этого рекурсивно. 

	Скажем, что ребро $(a, b)$ потенциально хорошее, если вес этого ребра меньше, чем максимальное ребро на пути из $a$ в $b$ в полученном остовном дереве (т.е. при замене мы можем что-то улучшить), или если эти вершины лежат в разных компонентах связности. 

	Теперь, для ребра надо быстро определять является ли оно хорошим. Другими словами, найти $\texttt{max}(a, b)$. Для этого используем \texttt{RMQ} за $\O(1)$. 

	Докажем линейность времени работы. Когда переходим в рекурсию, у нас остается $\frac{n}{8}$ вершин и $\frac{n}{8}$ (из остовного дерева) + $\frac{n}{8}$ (хороших, об этом будет сказано позже) ребер. 

	$T(n, m) = \O(m) + T(\frac{n}{8}, \frac{m}{2}) + T(\frac{n}{8}, \frac{n}{4})$ 

	По индукции докажем,  что $T = \O(m)$. Для этого заменяем $\O(m)$ на $c * m$ и выносим $c$ за скобку:
 
	$T(n, m) = m + 2(\frac{n}{8} + \frac{m}{2}) + 2(\frac{n}{8} + \frac{n}{4}) $ (индукционное предположение) $ = n + 2m \le 2(n + m)$ 

	Чтобы оценить количество хороших ребер, докажем следующую лемму (в нашей задаче параметр $p$ будет равен  $\frac{1}{2}$): 

	Если $H$ — подграф $G$ такой, что любое ребро взято с вероятностью $p$, то в $G$ $E$[хороших ребер относительно \texttt{MST} $H$] $\le (n - 1)(\frac{1}{p} - 1)$ 

	Доказательство: Хорошее ребро — такое ребро, которое добавил бы алгоритм Краскала от $G \Rightarrow $ таких событий (добавлений ребра) $n - 1$. С вероятностью $p$ мы добавим его в $H \Ra$ с вероятностью $1 - p$ оно станет хорошим, значит, нужно оценить количество таких событий. 

\begin{cppcode}
Sort edges in ascending by weight
for e:
	 if get(a[e]) == get(b[e]) // это условие выполнится $\frac{n - 1}{p}$ раз
		 if p // с вероятностью $p$ \texttt{Join}
			Join(a[e], b[e]) // $n - 1$
		else
			GoodEdges.add(e) // $\frac{n - 1}{p} - (n - 1)$
\end{cppcode}

	Замечание: Если алгоритм Краскала не включил $e$ в подостов, то в остове этого ребра тоже не будет. 

	Замечание: Рекурсия обрывается, когда остается одна вершина (сама себе остов). 

	Итоговое время работы: 

	Среднее: $\O(n + m)$ 

	Худшее: $\texttt{min}\{\O(n^2), \O(m\texttt{log}n)\}$ (если осталось $\frac{m}{2}$ хороших ребер, но от кратных ребер избавляемся, значит, на каждом шаге не больше $n^2$ ребер)

\section{Min-offline $T =  \O^*\left(1\right)$}
	Пути вертикальны, значит, перебираем в порядке возрастания верхних границ, новый вес вершины — минимальный на соответствующем пути. Применяем эвристику сжатия путей $\Ra \O(\texttt{log}n)$. Преобразования корректны, т.к. $u$ возрастает. 

\includegraphics[width=2in]{Lect8_4.jpg}

\begin{cppcode}
for u in ascending // верхняя граница запроса
	for x: p[x] = u
		Join(x, u)
	for d in ascending // нижняя граница запроса
		ans = get(d)
\end{cppcode}

Теперь о подвешивании (\texttt{Join}): если $w[u] \le w[x]$ может и так, и так подвесить, чтобы минимумы остались теми же, надо будет $w[x] := w[u]$.

1. $p[x] = u$ — подвешивание оригинальное, не меняет дерева

2. $p[u] = x$ — альтернативное подвешивание, меняет дерево 


Если же $w[u] > w[x]$, то для поддерева $x$ ответ должен быть меньше и подвешивать надо по-особенному, подробно расскать об этом не успели. 


\includegraphics[width=3in]{Lect8_5.jpg}\\

