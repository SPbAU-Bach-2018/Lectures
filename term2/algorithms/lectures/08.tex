\section{Функции на путях}
	Примеры функций: сумма, минимум.\\
	Путь: ребра от $a$ до $b$, где $a$ и $b$ -- вершины дерева. \\
	Варианты: сумма весов вершин или сумма весов ребер. Замечание: достаточно научиться считать для ребер и построить биекцию между ребрами и вершинами.\\
	Биекция: каждой вершине сопоставляем ребро в отца. Для корня можем сделать фиктивное ребро. \\

  \subsection{Сумма на пути, дерево не меняется. $T = \O\left(1\right)$}
	1. Ищем \texttt{LCA} за $\O\left(1\right)$. \\
	2. Используем массив s -- массив префиксных сумм. \\
	3. Ответ будет таким: $s[a] + s[b] - 2s[\texttt{LCA}]$ \\

\includegraphics[width=3in]{01.jpg}\\

	Замечание: когда мы пытаемся что-то сделать на дереве, сначала надо попытаться провести аналогию с массивом (частным случаем дерева), разбив путь на два вертикальных отрезка. \\
  
\includegraphics[width=4in]{02.jpg}\\

  \subsection{Сумма на пути, дерево меняется}
	Запросы: \\
	1. \texttt{get}($a$, $b$) -- найти функцию на пути из $a$ в $b$.\\
	2. $w[e] \leftarrow x$ -- изменить вес ребра $e$ на $x$. \\
	Решение: \\
	Используем Эйлеров обход с ориентированными ребрами (каждое в двух экземплярах: $+w$, если спускаемся, $-w$, если поднимаемся). \\
	Тогда суммой на пути будет значение от любого вхождения \texttt{LCA} до любого вхождения $a$. Все ненужные ребра сократятся, т.к. если сворачивали с кратчайшего пути, то обязательно возвращались обратно. Однако, обычно берут первые вхождения, тогда и сумма получается с нужным знаком.\\
	Чтобы изменить ребро, необходимо изменить его вес в Эйлеровом обходе. \\
	Таким образом, обе операции работают за $\O\left(\log{n}\right)$. \\
	Код построения Эйлерова обхода: \\
        \t{\begin{MyList}
          \item \hspace{0em} go(v)
          \item \hspace{2em}   pos[v] = n // сохраняем позицию вершины в обходе (первое вхождение)
          \item \hspace{2em}   for e: // по всем ребрам из $v$, идущим в $x$
          \item \hspace{4em}   first[e] = n
          \item \hspace{4em}   a[n++] = w(e) // в $a$ храним обход
          \item \hspace{4em}   go(x)
          \item \hspace{4em}   second[e] = n 
          \item \hspace{4em}   a[n++] = -w(e)
        \end{MyList}}

  \subsection{LCA-Offline. $T = \O\left(A^{-1}(m, n)\right) = \O^*\left(1\right)$}
       Будем использовать СНМ вершин, которые уже обошли, и множество вершин от корня до текущей. Таким образом, из любой вершины, из которой уже вышли, легко посчитать \texttt{LCA} с вершиной $v$ (стоим в ней сейчас).
\\ \\
\includegraphics[width=4in]{03.jpg}\\

         \t{\begin{MyList}
          \item \hspace{0em} go(v)
          \item \hspace{2em}  color[v] = 1 // для СНМ
          \item \hspace{2em}  for a in List[v] // список вопросов, связанных с v
          \item \hspace{4em}  if (color[a] == 1)
          \item \hspace{6em}   LCA = get(a) // возвращает представителя
          \item \hspace{2em}  for x: // для всех соседей $v$
          \item \hspace{4em}  go(x)
          \item \hspace{4em}  join(x, v)
        \end{MyList}}

  \subsection{RMQ-Offline (минимум на отрезке)}
	Способ 1: Сводим \texttt{RMQ} к \texttt{LCA}, решаем \texttt{LCA} Offline \\ 
	Способ 2: \\ 
		1. перебираем правую границу в порядке возрастания (левая – произвольная) \\
		2. на всем отрезке есть минимальный элемент (с индексом $m_i$) \\
		3. ответом будет $m_i$: $i$ – \texttt{min}: $L$ < $m_i$ \\ 
	Пояснение:   $a[m_1] \le a[m_2] \le ...; m_1 = \texttt{min}[1; R], m_{i+1} = \texttt{min}[m_i + 1; R]$ \\
	Если храним отрезки в СНМ, то ответ – get к СНМ. Представитель: самый правый элемент в отрезке.
	 \t{\begin{MyList}
         \item \hspace{0em} for i = 1..q // запросы 
          \item \hspace{2em} List [R[i]].push\_back(L[i])
          \item \hspace{0em} for i = 1..n // запросы
          \item \hspace{2em} p[i] = i // Init DSU
          \item \hspace{0em} Stack m
          \item \hspace{0em} for R = 1..n
          \item \hspace{2em} while (m.size() > 0 \&\&  a[get(m.top())] >= a[R])
          \item \hspace{4em} p[get(m.top())] = R
          \item \hspace{4em} m.pop()
          \item \hspace{2em} m.push(R)
          \item \hspace{2em} for i in List[R]
          \item \hspace{4em} min[i] = get(L[i])
	\item \hspace{0em} 
          \item \hspace{0em} get(v)
          \item \hspace{2em} return (v == p[v] ? v : (p[v] = get(p[v])))
        \end{MyList}}

  \section{Рандомизированный алгоритм построения MST за линейное время}
	Вспомним алгоритм Борувки (он умеет за линию в два раза уменьшать число вершин) и применим три раза. Тогда, из имевшихся $(n, m)$, получим $(\frac{n}{8}, m)$. После этого возьмем случайную половину ребер и запустимся от этого рекурсивно. \\
	Скажем, что ребро $(a, b)$ потенциально хорошее, если вес этого ребра меньше, чем максимальное ребро на пути из $a$ в $b$ в полученном остовном дереве (т.е. при замене мы можем что-то улучшить), или если эти вершины лежат в разных компонентах связности. \\
	Теперь, для ребра надо быстро определять является ли оно хорошим. Другими словами, найти $\texttt{max}(a, b)$. Для этого используем \texttt{RMQ} за $\O(1)$. \\
	Докажем линейность времени работы. Когда переходим в рекурсию, у нас остается $\frac{n}{8}$ вершин и $\frac{n}{8}$ (из остовного дерева) + $\frac{n}{8}$ (хороших, об этом будет сказано позже) ребер. \\
	$T(n, m) = \O(m) + T(\frac{n}{8}, \frac{m}{2}) + T(\frac{n}{8}, \frac{n}{4})$ \\
	По индукции докажем,  что $T = \O(m)$. Для этого заменяем $\O(m)$ на $c * m$ и выносим $c$ за скобку: \\
	$T(n, m) = m + 2(\frac{n}{8} + \frac{m}{2}) + 2(\frac{n}{8} + \frac{n}{4}) $ (индукционное предположение) $ = n + 2m \le 2(n + m)$ \\
	Чтобы оценить количество хороших ребер, докажем следующую лемму (в нашей задаче параметр $p$ будет равен  $\frac{1}{2}$): \\ 
	Если $H$ — подграф $G$ такой, что любое ребро взято с вероятностью $p$, то в $G$ $E$[хороших ребер относительно \texttt{MST} $H$] $\le (n - 1)(\frac{1}{p} - 1)$ \\
	Доказательство: Хорошее ребро — такое ребро, которое добавил бы алгоритм Краскала от $G \Rightarrow $ таких событий (добавлений ребра) $n - 1$. С вероятностью $p$ мы добавим его в $H \SO$ с вероятностью $1 - p$ оно станет хорошим, значит, нужно оценить количество таких событий. \\
	\t{\begin{MyList}
         \item \hspace{0em} Sort edges in ascending by weight
          \item \hspace{0em} for e:
          \item \hspace{2em} if get(a[e]) == get(b[e]) // это условие выполнится $\frac{n - 1}{p}$ раз
          \item \hspace{4em} if p // с вероятностью $p$ \texttt{Join}
          \item \hspace{6em} Join(a[e], b[e]) // $n - 1$
          \item \hspace{4em} else
          \item \hspace{6em} GoodEdges.add(e) // $\frac{n - 1}{p} - (n - 1)$
        \end{MyList}}
	Замечание: Если алгоритм Краскала не включил $e$ в подостов, то в остове этого ребра тоже не будет. \\
\\
	Замечание: Рекурсия обрывается, когда остается одна вершина (сама себе остов). \\
\\
	Итоговое время работы: \\
	Среднее: $\O(n + m)$ \\
	Худшее: $\texttt{min}\{\O(n^2), \O(m\texttt{log}n)\}$ (если осталось $\frac{m}{2}$ хороших ребер, но от кратных ребер избавляемся, значит, на каждом шаге не больше $n^2$ ребер)\\

\section{Min-offline $T =  \O^*\left(1\right)$}
	Пути вертикальны, значит, перебираем в порядке возрастания верхних границ, новый вес вершины — минимальный на соответствующем пути. Применяем эвристику сжатия путей $\SO \O(\texttt{log}n)$. Преобразования корректны, т.к. $u$ возрастает. \\

\includegraphics[width=2in]{04.jpg}

	\t{\begin{MyList}
         \item \hspace{0em} for u in ascending // верхняя граница запроса
          \item \hspace{2em} for x: p[x] = u
          \item \hspace{4em} Join(x, u)
          \item \hspace{2em} for d in ascending // нижняя граница запроса
          \item \hspace{4em} ans = get(d)
        \end{MyList}}

Теперь о подвешивании (\texttt{Join}): если $w[u] \le w[x]$ может и так, и так подвесить, чтобы минимумы остались теми же, надо будет $w[x] := w[u]$. \\
1. $p[x] = u$ — подвешивание оригинальное, не меняет дерева \\
2. $p[u] = x$ — альтернативное подвешивание, меняет дерево \\

Если же $w[u] > w[x]$, то для поддерева $x$ ответ должен быть меньше и подвешивать надо по-особенному, подробно расскать об этом не успели. \\

\includegraphics[width=3in]{05.jpg}\\

