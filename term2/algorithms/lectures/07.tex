\section{Задачки про ScanLine}

\begin{enumerate}
\item
	Условие: Найти площадь объединения прямоугольников.

	Решение: Заведем события двух типов: прямоугольник начался, прямоугольник закончился.
	Отсортируем события по $x$ координате. Также у нас будет дерево отрезков по $y$, где в вершинах
	мы будем хранить минимум в поддереве и количество раз, которое он встречается.
	Будем обрабатывать события слева на право. Если начался новый прямоугольник, то прибавим к
	соответствующему отрезку в дереве отрезков $1$. Если прямоугольник закончился, то посмотрим чему равен минимум в дереве.
	Если он равен $0$, то прибавим к ответу $count \cdot (x_i - x_{i-1})$, где $count$ --- это количество нулей в дереве,
	а $x_i - x_{i - 1}$ --- это расстояние между двумя последними обработанными событиями.

\item
	Условие: Вам даны взвешенные точки, нужно находить сумму/минимум/gcd в стакане.

	Напоминание: стакан задается тремя числами: $L$, $R$, $M$. Точка $(x, y)$ лежит в стакане, если $L \le y \le R$ и $x \le M$.

	Решение: Сжимаем координаты по $y$. Соритруем запросы по $x$ координате. Заводим дерево отрезков по $y$.
	Обрабатываем запросы слева на право. Задачка решена!
\end{enumerate}

\chapter{Sparse table, Disjoint sparse table, Фарах-Колтон-Бендер}
\setauthor{Юрий Ребрик}

\section{Sparse table}
\subsection{Основное}

Sparse table --- структура данных, которая умеет считать идемпотентные функции на отрезке.

Для каждой позиции $i$ в массиве будем считать функцию на отрезках вида $\left[i, 2^k\right)$.

\subsection{Реализация}
\begin{cppcode}
// построение за O(n log n)
// запрос за O(1)
	
void build(int* data, size_t size) {
	for (int i = 0; i < size; ++i)
		table[i][0] = data[i];
	for (int k = 1; k <= LOG_MAX_SIZE; ++k)
		for (int i = 0; i < size; ++i)
			table[i][k] = min(table[i][k - 1], table[i + (1 << (k - 1))][k - 1]);
}	
	
int getMin(int l, int r) {
	int k = Log[r - l + 1]; // Log[x] - максимальная степень 2, которая не превосходит x
	return min(table[l][k], table[r - (1 << k) + 1][k]);
}
\end{cppcode}

\section{Disjoint sparse table}
Добьем массив нулям так, что бы его размер стал степенью двойки.
Разобьем его на отрезки вида $[i, \frac{n}{2}] (i \le \frac{n}{2})$ и $[\frac{n}{2} + 1, i] (i \ge \frac{n}{2} + 1)$.
Построим туже структуру для левой и правой частей массива.
Посчитаем нужную функцию на этих отрезках.

Очевидно, что построение работает за $O(n \log n)$. Также понятно, что мы можем за $O(1)$ отвечать на запрос на отрезке, если мы знаем позицию
самого высоко разреза (позиции, относительно которой массив был когда-то разделен на две части), которая попадает на наш отрезок.
Чтобы научиться быстро находить такую позицию для соответствующего отрезка $[L, R]$, надо понять, что её можно задать
максимально совпадающим префиксом чисел $L$ и $R$ в двоичной записи.
Чтобы его получить, нужно будет предподсчетать старший бит для чисел.

\section{Модификации Sparse table}
\begin{enumerate}
	\item Построение за $O(n)$, запрос за $O(\log n)$.
	
	Разобьем массив на отрезки размера $\log n$, посчитаем на них функцию и построим sparse table.
	
	\item Построение за $O(n \log \log n)$, запрос за $O(1)$.
	
	Разобьем массив на отрезки размера $\log n$, посчитаем на них функцию и построим sparse table.
	Также построим sparse table на каждом из отрезков.
	 
	\item Построение за $O(n)$, запрос за $O(\log \log n)$.
	
	Разобьем массив на отрезки размера $\log n$ и построим на них sparse table.
	Также на каждом отрезке построим дерево отрезков.
	
\end{enumerate}

\section{RMQ \texorpdfstring{$\pm1$}{+-1}}
Построим новый массив $d$, где $d[i] = 0$, если $a[i] + 1 = a[i - 1]$, и $d[i] = 1$, если $a[i] - 1 = a[i - 1]$ ($a$ --- исходный массив).
Разобьем этот массив на отрезки размера $k = \frac{\log n}{2}$ и построим на них sparse table.
Каждый отрезок начинается либо с $0$ либо с $1$, а остальных возможных суффиксов всего $2^{k-1}$. Поэтому предподсчетаем 
позицию минимума в каждом суффиксе суммарно за $2^k k^2 = \theta(\sqrt{n} \log^2 n)$.

Теперь мы умеем получать минимум на отрезке за $O(1)$ и построением за $O(n)$.

\section{Фарах-Колтон-Бендер}
Хотим уметь получать минимум на отрезке за $O(1)$ с построением за $O(n)$.

\subsection{Сведение RMQ к LCA}
\begin{cppcode}
int getMin(int l, int r) {
	int vL = getVertex(l); // vL - вершина в дереве
	int vR = getVertex(r); // vR - вершина в дереве
	int lca = getLca(vL, vR); // получаем LCA двух вершин
	return index[lca]; // позиция элемента в массиве, который соответствует вершине lca
}
\end{cppcode}

Заметим, что $l \le index[lca] \le r$, ведь иначе вершины $vL$ и $vR$ лежали бы в одном сыне $lca$,
а также $a[index[lca]]$ --- минимальный элемент на отрезке $[l, r]$ (по построению декартового дерева).

\subsection{Ребята, давайте построим дерево}
Построим за $O(n)$ декартово дерево, в котором ключами будут индексы элементов, а ключом --- значения.

\begin{cppcode}
for (int i = 0; i < n; ++i) {
	Node* last = NULL;
	Node* node = new Node(i, a[i], NULL, NULL);
	while (!path.empty() && path.top()->y > node->y)
		last = path.pop();
	node->left = last;
	path.push(node);
}
\end{cppcode}

\subsection[Сведение LCA к RMQ +- 1]{Сведение LCA к RMQ $\pm$ 1}
Построим эйлеров обход для нашего дерева, каждый раз выписывая номер вершины кода в нее входим.
Теперь, что бы найти наименьшего общего предка для вершин $a$ и $b$, нужно найти вершину с минимальной глубиной, 
которая находиться в обходе между любыми вхождениями вершин $a$ и $b$.

Легко заметить, что глубины подряд идущих вершин в обходе отличаются на $1$. Поэтому мы можем свести задачу к RMQ $\pm$ 1.

\begin{cppcode}
int getLca(int a, int b) {
	int i = RMQ(h, pos[a], pos[b]); // pos[x] - позиция вершины x в обходе дерева
	return v[i]; // вершина с индексом i  в обходе
}
\end{cppcode}
