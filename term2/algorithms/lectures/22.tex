\section{Длинная арифметика и использование Фурье}
\setauthor{Надежда Бугакова}

\underline{3 способа хранения многочленов:}
\begin{enumerate}
	\item vector<Complex> Степень $\leftrightarrow$ размер вектора
	\item 
		\begin{cppcode}
struct{
	Complex[N];
};
		\end{cppcode}
		<<->>: долго выполняются операции с маленькими многочленами(считается, что степени всех многочленов N).
	\item 
		\begin{cppcode}
struct{
	int n;
	Complex[N];
};
		\end{cppcode}
		Быстрее, чем первый, т.к. не динамический. В $n$ храним степень многочлена, поэтому операции с маленькими 
		многочленами выполняются за нормальное время. 
\end{enumerate}

\underline{Целые числа:}
	Добавляется знак. Добавляется операция сравнения(для определения знака). Храним от младшего разряда к старшим.
	\begin{cppcode}
struct{
	int n;
	int[N];
	sign;
};
	\end{cppcode}

\underline{Вещественные числа:}
	Храним, как целые + степень. Поэтому добавляется ещё одно поле int pow. 
	$123.765 \rightarrow 123765 \cdot B^{-3}$, где $B$ - база системы счисления.
	Добавляем операцию выравнивания(по точке). \\


\textbf{Операции:}
\begin{itemize}
	\item \underline{Перемножение.}
	\begin{enumerate}
		\item \text{\itshape Целые}

			Наивная реализация перемножения двух многочленов:
			\begin{cppcode}
for (int i = 0..n-1)
	for (int j = 0..n - 1)
		r[i + j] += a[i]*b[i];
			\end{cppcode}
			 Для целых чисел нужно ещё обрабатывать переносы в следующий разряд. Нормализация:
			 \begin{picture}(58, 40)
			 	\put(0, 25){\line(1, 0){58}} \put(0, 40){\line(1, 0){58}} 
			 	\put(14, 25){\line(0, 1){15}} \put(29, 25){\line(0, 1){15}} \put(44, 25){\line(0, 1){15}}
%			 	\put(0, 20){...} \put(47, 20){...}
			 	\put(18, 29){\large{x}}
			 	\put(12, 15){\small{$\ge$}} \put(20, 15){\small{$B$}}
			 	\put(4, 3){\footnotesize{\%}} \put(13, 3){\footnotesize{=}} \put(20, 3){\footnotesize{$B,$}}
			 	\put(33, 3){\small{+=}} \put(50, 3){\large{$\frac{x}{B}$}}
			 	\put(37, 12){\vector(0, 1){19}}
			 \end{picture} Обыкновенный перенос в следующий разряд: в текущей ячейке число берём по иодулю, а целую часть от деления прибавляем
			 к следующему разряду.
			 Если $nB^2$ не влезает в long long, то нормальзацию надо делать на каждой итерации:
			 \begin{cppcode}
for (int i = 0..n - 1)
	for (int j = 0..n - 1)
		if ((r[i + j] += a[i]*b[j]) >= B) { Normalization }
			 \end{cppcode} 
			 Иначе, делаем нормальзацию один раз в конце.
			 Можно делать что-то среднее:
			 \begin{cppcode}
if (r[i + j] >= B*B)
	r[i+j] -= B^2;
	r[i + j + 1]++;
			 \end{cppcode}
			 Инвариант: в каждой ячейке число не больше $B^2$. Так как каждый раз прибавляем не больше чем $B^2$, то чтобы сохранить инвариант
			 один раз вычесть будет достаточно. Такой метод нормализации ускорит программу, поскольку, во-первых, мы её реже делаем, 
			 а во-вторых, не тратим лишнюю операцию взятия по модулю.

			 Для Фурье обязательно $nB^2$ должно влезать в long long.
	\end{enumerate}
	\item \underline{gcd}
		\begin{enumerate}
			\item \text{\itshape Целые}

				Что мы знаем? Мы знаем только алгоритм Евклида. gcd($F_n, F_{n - 1}$) = gcd($F_{n - 1}, F_{n - 2}$) = \dots = 1 - худший случай.
				$F_n \approx \phi^n \Rightarrow$ он работает за $\mathcal{O}(\log n)$. Если взятие по модулю работает за $\mathcal{O}(1)$.
				Эту операцию с длинными числами мы пока делать не умеем. И даже когда научимся, то это будет долго. Поэтому используем 
				\underline{бинарный алгоритм Евклида:}

				A, B. Если оба делятся на 2 $\Rightarrow$ делим, gcd *= 2. Если ровно один делится на 2 - делим. Если ни один не делится на 2,
				то вычитаем из одного другой и затем выполняем вторую операцию(то есть у нас будет 1 чётное и 1 нечётное, чётное делим пополам).

				Таким образом, каждая итерация работает за $\mathcal{O}(1)$ и уменьшает одно из чисел хотя бы вдвое. 
				Значит, работает за $\mathcal{O}(\log n)$.

				Чтобы реализовать этот алгоритм надо научится умножать на константу и делить на константу. Мы будем делать это за 
				$\mathcal{O}(\log N)$. Таким образом, алгоритм Евклида будет работать за $\mathcal{O}(n^2)$, где $n$ - количество цифр
				в числе.
			\item \text{\itshape Многочлены}

				Обычный(небинарный) алгоритм Евклида. Нет никаких переносов. Надо научится брать многочлен по модулю 
				$\leftrightarrow$ деление многочленов. Будет дальше.
		\end{enumerate}
	\item \underline{Умножение, деление на константу}
		\begin{enumerate}
			\item \text{\itshape Многочлены}

				Очевидно.
			\item \text{\itshape Целые}

				Умножение: обычное умножение + нормализация.

				Деление($с < B$):
				\begin{picture}(70, 50)
					\put(0, 50){\line(1, 0){50}} \put(0, 40){\line(1, 0){50}}
					\put(0, 50){\line(0, -1){10}} \put(50, 50){\line(0, -1){10}}
					\put(10, 50){\line(0, -1){10}} \put(20, 50){\line(0, -1){10}}
					\put(55, 50){\line(0, -1){20}} \put(55, 40){\line(1, 0){15}}
					\put(60, 42){c} \put(3, 42){$a$} \put(12, 42){$b$}
					\put(0, 29){$\underbrace{a - \lfloor\frac{a}{c}\rfloor c}$} \put(57, 29){$\lfloor\frac{a}{c}\rfloor \dots$}
					\put(0, 10){$B(\dots) + b$} \put(20, 0){...}
				\end{picture} - обычное деление в столбик. 
				
				Если $c > B$, то надо будет просто группировать друг с другом больше блоков. Таким образом, работает за $\mathcal{O}(\log N)$.
		\end{enumerate}
	\item \underline{Деление}
		\begin{enumerate}
			\item \text{\itshape Многочлены}

			$n - m$ раз подбираем коэффициент для старшего разряда, вычитаем за $\mathcal{O}(m)$. Итого: $\mathcal{O}((n - m)m)$.
			\item \text{\itshape Целые числа}

				\begin{picture}(140, 50)
					\put(0, 40){\line(1, 0){65}} \put(0, 30){\line(1, 0){65}}
					\put(0, 40){\line(0, -1){10}} \put(65, 40){\line(0, -1){10}}
					\put(30, 40){\line(0, -1){10}}
					\put(70, 40){\line(0, -1){30}} \put(70, 27){\line(1, 0){65}}
					\put(75, 40){\line(1, 0){65}} \put(75, 30){\line(1, 0){65}}
					\put(75, 40){\line(0, -1){10}} \put(140, 40){\line(0, -1){10}}
					\put(30, 43){$x$} \put(105, 43){$p$}
					\put(80, 15){$c$}
					\put(15, 20){\vector(0, 1){15}}
					\put(10, 10){$yc$}
				\end{picture}
				$c$ - подбираем бинпоиском. 
				
				$(n - m)\log Bm$

				\begin{picture}(100, 20)
					\put(20, 11){\vector(0, 1){12}} \put(5, 0){\#раз}
					\put(50, 11){\vector(0, 1){12}} \put(45, 0){BS}
					\put(75, 11){\vector(0, 1){12}} \put(75, 0){вычитание}
				\end{picture}

				Попробуем очередное $c$ вычислить за $\mathcal{O}(1)$. Рассмотрим, $C = \lfloor\frac{P}{Y}\rfloor$ - по первых несколько
				цифр чисел $Y$ и $P$. Утверждается, что достаточно 2-х первых цифр, чтобы приближение $C$ к $с$ было достаточно точным. Оценим
				$\frac{P}{Y}$

			   \begin{gather*}
					p = \overline{a_1a_2\dots}, y = \overline{b_1b_2\dots} \\  
					\overline{a_1a_20000\dots00} \le P \le \overline{a_1a_29999\dots99} \\
					\overline{b_1b_20000\dots00} \le Y \le \overline{b_1b_29999\dots99} \\
					\frac{a_1B + a_2 + 1}{b_1B + b_2} < \frac{P}{Y} < \frac{a_1B + a_2}{b_1B + b_2 + 1} \\
					\left|\frac{a_1B + a_2}{b_1B + b_2 + 1} - \frac{a_1B + a_2 + 1}{b_1B + b_2} \right| = 
					\frac{1 + b_1B + b_2 + a_1B + a_2}{(b_1B + b_2)(b_1B + b_2 + 1} \le 5 \\
					\text{так как } 1 + b_1B + b_2 + a_1B + a_2 \le 5B^2, (b_1B + b_2)(b_1B + b_2 + 1) \ge B^2
				\end{gather*}
				$\Rightarrow$ $c = C \pm 5$ Таким образом, чтобы подобрать $c$ берём $\widetilde{c} = \frac{a_1B + a_2}{b_1B + b_2 + 1}$и 
				перебираем 2-3 числа вперёд, пока не найдём нужное.

				Всё это описано в Кнуте.

				\underline{Проблема:}

				Неизвестно, что делать, если при прибавлении 1 появится новый разряд.
		\end{enumerate}

На текущий момент мы умеем делать следующее:
$$
\begin{tabular}{|l|c|c|c|c|c|}
	\hline
	& $+, -, <$ & $*$ & gcd & $*c, /c$ & $\%, /$ \\
	\hline
	Многочлены & $\mathcal{O}(n)$ & $n\log n$ & $n^3$ & $\mathcal{O}(n)$ & $n^2$ \\
	\hline
	Целые(вещественные) & $\mathcal{O}(n)$ & $n\log n$ & $n^2$ & $\mathcal{O}(n)$ & $n^2\log B$, $n^2$ \\
	\hline
\end{tabular}                          
$$
	\item \underline{Корень(для целых, вещественных)}

	Первый вариант сделать втупую: деление и корень не сильно отличаются. Бинпоиском подбираем корень(за $\mathcal{O}(\log N)$), 
	а при проверке перемножаем Фурье. Таким образом, асимтотика $\mathcal{O}(nn\log n)$

	Но мы хотим быстрее: метод Ньютона. Он находит 0 функции $f(x)$.

	Пусть $\bar{x}$ - приближённое решение. (для коря стоит брать число $1000\dots00$, где $n/2$ нулей)

	$\bar{\bar{x}} = \bar{x} - \frac{f(\bar{x})}{f'(\bar{x})}$ - уточнение решения.

	$f(x) = A - x^2$

	$\bar{\bar{x}} = \bar{x} - \frac{A - \bar{x}^2}{-2\bar{x}} = \bar{x} + \frac{A - \bar{x}^2}{2\bar{x}} = \frac{\bar{x}^2 + A}{2\bar{x}} = 
	\frac{1}{2}(\bar{x} + \frac{A}{\bar{x}})$ Складываем и делим на константу мы быстро. Значит время работы зависит от времени деления.

	Для хроших функций метод Ньютона удваивает точность(количество правильных цифр). Наша функция хорошая $\Rightarrow$ нужно $\mathcal{O}(\log n)$ итераций.
	Значит корень найдём за $\mathcal{O}(DIV\cdot\log n)$.

	Точность:
	\[\text{Пусть } \sqrt{A} = z \Rightarrow \frac{A}{z} = z\]
	\[ z + \epsilon \rightarrow 1/2(z + \epsilon + \frac{A}{z + \epsilon})\]
	\[\frac{A}{z + \epsilon} = \frac{A}{z} - \epsilon\frac{A}{z(z + \epsilon)}\]
	\[\epsilon\frac{A}{z(z + \epsilon)} = \epsilon\frac{1}{1 + \epsilon/z} \approx \epsilon(1 - \epsilon/z)\]
	\[\text{Итого: } 1/2(z + \epsilon + \frac{A}{z + \epsilon}) = z - 1/2\frac{\epsilon^2}{z}\]
	\[\epsilon \rightarrow \epsilon^2\]

	Хотим убыстрить деление!

	$\frac{A}{B} = AB^{-1}$ Но в $B^{-1}$ бесконечное количество знаков. Нам достаточно $\ge n$ где $n$ - количество знаков $A$.
	Тогда погрешность будет $\le 10^{-n}10^{n}  = \pm 1$
	\begin{picture}(85, 30)
		\put(0, 25){\line(1, 0){40}} \put(0, 15){\line(1, 0){40}}
		\put(0, 25){\line(0, -1){10}} \put(40, 25){\line(0, -1){10}}
		\put(43, 0){\line(1, 0){40}} \put(43, 10){\line(1, 0){40}}
		\put(43, 0){\line(0, 1){10}} \put(83, 0){\line(0, 1){10}}
		\put(55, 15){$\cdots$} \put(20, 1){$\cdots$}
		\put(17, 17){$n$} \put(61, 2){$n$}
		\put(47, 4){\line(-2, 3){11}} \put(78, 5){\line(-6, 1){75}}
	\end{picture}
	\item \underline{Нахождение обратного.}
	\begin{enumerate}
		\item \text{\itshape Целые.} И снова метод Ньютона!

			\[f(x) = \frac{1}{x} - B \]
			\[\bar{\bar{x}} = \bar{x} - \frac{\frac{1}{x} - B}{-\frac{1}{x^2}} = \bar{x} + \bar{x} - B\bar{x}^2 \]

			Точность:
			\[\text{Пусть } z = B^{-1} \Rightarrow B = 1/z\]
			\[z + \epsilon \rightarrow 2z + 2\epsilon - B(z + \epsilon)^2\]
			\[2z + 2\epsilon - z - 2\epsilon + \frac{\epsilon^2}{z} = z + \frac{\epsilon^2}{z}\]
			\[\epsilon \rightarrow \epsilon^2\]

			Теперь уточнение делаем через умножение, что мы умеем достаточно быстро. Итераций хватает $\log n$, так как за каждую итерацию
			точность увеличивается в два раза. $\Rightarrow$ получаем асимптотику $\log n \cdot n\log n = n\log^2 n$. Это приблизительная оценка.
			На самом деле алгоритм работает быстрее:

			Давайте перемножать не весь многочлен, а только важные нам знаки, в зависимости от текущей точности. В изначальном приближении - 1 знак.
			Его мы как-нибудь сможем найти. Далее 2 знака, 4 знака, $\dots$, n знаков.

			Логарифм каждого числа округлим грубо до $\log n$. Тогда:

			$\mathcal{O}(\log n(1 + 2 + \dots + 2^k)) = \mathcal{O}((2^{k + 1} - 1)\log n) = \mathcal{O}(n\log n)$, где $2^k = n$.

			Кстати, точно так же можно улучшить время извлечения корня. То есть сначала с точностью до 1 знака, потом до 2 и так далее.

			Тогда $\log n$ внешних итераций. Для каждой нужно посчитать в соответствующей точности $\bar{x}^{-1}$.
			То есть $\log n(n \log n)$ = $n\log^2 n$.

Табличка теперь выглядит так:
$$
\begin{tabular}{|l|c|c|c|c|c|c|}
	\hline
	& $+, -, <$ & $*$ & gcd & $*c, /c$ & $\%, /$ & $\sqrt{}$ \\
	\hline
	Многочлены & $\mathcal{O}(n)$ & $n\log n$ & $n^3$ & $\mathcal{O}(n)$ & $n^2$ & $\times$\\
	\hline
	Целые(вещественные) & $\mathcal{O}(n)$ & $n\log n$ & $n^2$ & $\mathcal{O}(n)$ & $n^2\log B$, $n^2$, $n\log n$ & $n\log^2 n$ \\
	\hline
\end{tabular}                          
$$


		\item \text{\itshape Многочлены}

		\[\frac{1}{Q(x)} = 1\]
		Например $(1 + x + \dots + x^n)(1 - x) = 1 - x^{n + 1} \xrightarrow[n \rightarrow \inf]{} 1$
		\[\frac{1}{1 - x} = 1 + x + \dots\]

		\begin{theorem}
			Обратный к многочлену существует тогда и только тогда, когда его младший член не 0.
		\end{theorem}

		Обратный к многочлену, разумеется, бесконечен, но наша цель - вычислить несколько первых членов.

		\[(a_0 + a_1x + \dots + a_nx^n)(b_0 + b_1x + \dots) = 1\]
		\[
		\begin{cases}
			a_0b_0 = 1&\\
			a_0b_1 + a_1b_0 = 0&\\
			\cdots&
		\end{cases} \text{- это решается за $\mathcal{O}(n^2)$ динамикой.}
		\] 

		Назовём calc($a$, $k/2$) - многочлен, составленный из первых $k$ коэффициентов $1/a$. Тогда мы снова можем применить метод Ньютона!

		$\bar{x}$ = calc($a$, $k/2$). Тогда $\bar{\bar{x}} = 2\bar{x} - B\bar{x}^2$. $B = a$, из него можно взять первые $k$ коэффициентов,
		так как остальные не влияют.

		Остальное аналогично числам. И, соответственно, асимптотика тоже такая же.
	\end{enumerate}
	\item \underline{Теперь можно ускорить деление многочленов}

		Если младший член $Q$ не ноль, то $\frac{P}{Q} = P \cdot \frac{1}{Q}$, что мы можем вычислить за $\mathcal{O}(n\log n)$.

	    Но что делать если $Q$ необратимо? Индексы означают степень.

	    \[P_n = Q_m\cdot R_{n - m} + С_{m - 1}\]
	    \[P(1/x) = Q(1/x)R(1/x) + C(1/x) | \cdot x^n\]
	    \[x^nP(1/x) = x^nQ(1/x) R(1/x) + x^nC(1/x)\]
	    \[x^nP(1/x) \Leftrightarrow \text{Разворачивание коэффициентов}\]
	    \[P^{rev}(x) = Q^{rev}(x)R^{rev}(x) + C^{rev}x^{n - (m - 1)}\]
	    $Q^{rev}(x)$ - с ненулевым младшим коэффициентом. Почти победа! Обратим.
	    \[\frac{1}{Q^{rev}}(x)P^{rev}(x) = R^{rev}(x) + C^{rev}(x)x^{n - m + 1}\cdot\frac{1}{Q^{rev}}\]
	    $R^{rev}$ - степени $n - m$ и его мы хотим найти, то есть найти первые $n - m + 1$ его коэффициент. 
	    Заметим, что у последнего слагаемого за счёт домножения на $x^{n - m + 1}$ первын $n - m$ коэффициент равен 0. 
	    Значит, его можно вычеркнуть. Далее алгоритм прост. Считаем произведение слева, берём первые $n - m + 1$ коэффициент и разворачиваем R
	    обратно. 

	    В табличку добавится деление многочленов за $n\log n$. 
\end{itemize}