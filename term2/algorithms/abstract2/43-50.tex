\section{} % 43
Равенство автоматов "--- это изоморфизм графов, но у нас уникально помечены рёбра из вершин и немного помечены сами вершины (терминал/нетерминал), поэтому один dfs.
Эквивалентность: принимают одно и то же множество строк.
Теорема: если $A \sim B$, то минимальные эквивалентные равны (а не просто эквивалентны), без доказательства.
Алгоритм Хопкрофта: разбиваем состояния автомата на классы эквивалентности, потом скажем, что класс "--- вершина минимального.
Изначально классов два: терминалы/нетерминалы, добавили их в очередь в парах со всеми символами (всего $2\Sigma$ элементов).
На шаге берём пару из класса $C$ и символа $a$ из очереди, разбиваем каждый из текущих классов $R$ на два: вершины, из которых по символу $a$ попали в $C$ ($R_1)$ и остальные ($R_2$).
То есть смотрим на рёбра $a$, входящие в $C$ и входящие куда-то еще (а не выходящие из $C$).
Какие-то классы действительно разбились на два непустых, в очередь надо добавить меньший из получившихся, с символом $a$.

Корректно, так как если какие-то две вершины не разделились по символу $a$, то посмотрим на момент, когда классы прообразов этих вершин разделились.
Получим противоречие, что эти две вершины мы должны были попробовать разделить по $a$.
Вообще алгоритм за $\O(n \log n)$, но мы умеем только $\O(n^2\Sigma)$: каждая вершина не более $n$ раз меняет множество, т.е. каждое ребро будет рассмотрено не более $n$ раз.

\section{} % 44
Можно хранить в векторах, можно добавлять знак (нормализовывать ноль), вещественные можно хранить с плавающей/фиксированной точкой (еще появится операция выравнивания по точке).
Умножение: квадрат длины, можно нормализовать либо в конце ($nB^2$ в ячейке), либо по ходу ($B$ в ячейке), либо по ходу на $B^2$.
Деление: в столбик, для чисел очередную цифру подбираем либо бинпоиском (будет $(n-m+1)m\log B$), либо аккуратно смотрим на первые две цифры текущего остатка и делителя и их отношение "--- погрешность константная
(одной цифры мало).
Бинарное умножение: если одно чётное, то поделили его на два, рекурсивно, результат умножили на два; нечётное "--- тоже поделили на два, потом сделали \t{+=}.
Бинарное деление: поделили делимое пополам, рекурсивно, умножили ответы на два, сделали перенос, потом иногда добавили единицу.
Это просто пишется, квадрат, но может дольше работать, потому что мы тут зависим от длины числа в двоичной системе, а не с основанием $B$.
Евклид: на итерации у нас деление не квадрат, а $\O((n-m+1)m)$, если $n=m$, то линия (а итераций логарифм от числа, т.е. линия), для остальных нарисуем лесенку из убывающих длин, попробуем максимизировать время, получим квадрат.
\TODO КТО

\section{} % 45
Считаем значения многочлена степени $2^k$ в корнях из единицы в комплексных.
Разделяй-и-властвуй на чётные/нечётные коэффициенты, если посмотреть на стадию, то внутри мы берём пары чисел и как-то их меняем (преобразование бабочки по картинке).
Нерекурсивно: сгенерировали перестановку (как коэффициенты окажутся в конце, это reverse битов), переставили (без доп.памяти), пошли делать итерации, <<сливая>> соседние результаты.
Для умножения надо выбрать базу, чтобы $nB^2$ поместилось в точность, потом перемножаем как многочлены, делаем переносы.

\section{} % 46
\TODO

\section{} % 47
Эратосфен за $\O(n \log \log n$) "--- вычёркиваем только с простых чисел (верим, что $k$-е порядка $k \log k$).
Оптимизация "--- считаем для каждого числа еще и минимальный делитель.
Расширенный алгоритм выражает НОД в виде $ax+by$ (можно писать рекурсивно, тогда совсем понятно).
Диофантово уравнение имеет вид $ax+by=c$ ($a$, $b$ "--- константы), надо сократить на $\gcd(a, b)$, а потом применить расширенного Евклида.
Точно так же можно делить по модулю и решать $ax\equiv c \mod m \iff ax+my = c$.
Класс решений последнего сравнения, если $ax_0 + my = (a, m)$: $x_0 \frac{c}{\gcd(a, m)} + \frac{m}{\gcd(a, m)}k$, где $k \in \Z$.

\section{} % 48
Проверили до корня все числа, можно проверять только простые (тогда в лог раз быстрее).
Тест Ферма: проверим условие теоремы Ферма для случайного вычета.
Есть числа Кармайкла, для которых для всех условие верно, а для остальных с вероятностью $\frac 12$ корректно определит простоту (без доказательства).
Числа Кармайкла всегда состоят из $\ge 3$ множителей, поэтому можно для них проверить в лоб до $\sqrt[3]n$.

Миллер-Рабина: время $\O(\log n)$, вероятность $\ge \frac 14$, если $n$ простое, то решений $x^2 \equiv a \mod n$ не больше двух (т.к. область целостности).
Положим $a=1$, а также $n-1 = 2^st$ ($s>0$, $t$ нечётно).
Будем проверять условие сразу для нескольких иксов: взяли случайный $x$, взяли последовательность $x^t$, $x^{2t}$, $x^{4t}$, $x^{8t}$, \dots, $x^{2^st}=x^{n-1}\stackrel{?}{=}1$.
Если в конце не единица, то не простое.
Иначе взяли последнюю неединицу, если она не равна $-1$, то тоже не простое (так как нашли третье решение $x^2\equiv 1$).

\section{} % 49
Быстрее всего умеют сейчас за $\O(const ^{\sqrt[3]{k}})$, где $k$ "--- длина числа $n$.
Наивно "--- пытаемся делить до корня.
Поллард: пусть $n=pq$, причём $1 < p \le q$ (с простыми, разумеется, не закончит работу).
Взяли случайную функцию $f(x)$ ($f(x)=x^2+3\mod n$ подходит), посмотрели на её периоды по модулю $n$ (он порядка корня по парадоксу дней рождения),
а по модулю $p$ он порядка $\sqrt p$.
Взяли случайную точку, пошли двумя указателями, пока $\gcd(x_i - x_j, n) = 1$, так за $\sqrt p$ закончим.
Если не повезёт "--- то разность будет делиться на $n$, тогда еще раз пробуем с другого места.
Всё вместе работает за $\O(e^{\frac14k})$.

Если $n=pq$, оба простые, то зная $\phi(n)=(p-1)(q-1)$ можно найти $p$ и $q$, раскрыв скобки и решив уравнение.
RSA: берём $n=pq$, какое-нибудь $e$ (вроде 65537, чтобы быстро возводить в степень), шифруем: $m_{enc}=m^e \mod n$,
дешифруем: $m=m_{enc}^d \mod n$, где $e$ и $d$ взаимно обратны по модулю $\phi(n)$.
Если верим, что факторизовать число $n=pq$ сложно и что для расшифровки надо знать $\phi(n)$, то RSA сложно взломать.

\section{} % 50
Первообразный, если степени порождают все $x \colon (x,m)=1$, т.е. у него индекс $\phi(m)$.
Обычно интересен по простому модулю.
Можно проверять на первообразность, проверив $x^{\frac{m}{p_i}} \neq 1$, где $p_i$ "--- простые делители $m$.
Гипотеза: минимальный не превосходит $\log p$, можно просто в лоб перебрать и проверить.
Можно рандомно тыкать, $\frac{x}{\phi(x)} = \O(\log \log p)$ (без доказательства), тогда асимптотика лучше и честная.
Дискретный логарифм: взяли $p=\sqrt m$, записали в хэш-таблицу $x^{tp}$, потом берём наше $a$, домножаем на $x^0$, $x^1$, $x^2$, \dots,
через корень операций попали в хэш-таблицу, успех.
Корень: взяли логарифм по первообразному корню, решили сравнение по модулю $\phi(m)$.
