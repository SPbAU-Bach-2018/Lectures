\section{} % 14
Про запросы: построили динамическое дерево по значениям, теперь работаем за $(O\log V)$.

\section{} % 15
Сжали координаты.
Прошлись scanline с персистетным деревом отрезков слева направо по массиву.
Теперь для ответа на запрос делаем бинпоиск по ответу и отвечаем на запрос <<сколько элементов меньше данного с $L$ по $R$>>.
Так как деревья в каждой точке одинаковой структуры, можно делать бинпоиск по ответу одновременно со спуском по дереву.
Будет $\O(\log n)$ на запрос.

\section{} % 16
Делаем снаружи бинпоиск по ответу, а внутри запрос
Online: внутри вершины наружнего дерева делаем неявное размера $M$.
Теперь можно делать бинарный поиск по ответу на внутренних деревьях, потому что у них у всех одинаковая структура.
Для $\log N$ и offline можно делать то же самое, просто заранее сжать координаты.

\section{} % 17
Построили дерево merge sort'а, в каждой вершине "--- еще одно дерево отрезков.
Можно предподсчитать для обратимых функций на префиксах и спускать ссылки бинпоисков сверху.

\section{} % 18
Взяли точки на плоскости $(i, a_i)$.
Обратно: сжали координаты.
$d$-мерный запрос: построили дерево отрезков по первой координате, в каждой вершине "--- дерево отрезков размерности $d-1$ (рекурсивно).

\section{} % 19
Всё понятно.

\section{} % 20
Запрос в offline: сканирующая прямая, каждый запрос разбивается на разность значений в двух <<стаканах>>.
Максимальная последовательность: в дереве на сканирующей прямой храним лучший ответ, который закончился на соответствующей координате.
Появилась точка "--- запрос на префиксе, обновили в координате новой точки.

\section{} % 21
На прямой держим дерево отрезков с групповой операцией прибавления и запросом на всём дереве <<минимум и количество минимумов>>,
чтобы так считать количество нулей (и, соответственно, не-нулей).

\section{} % 22
Sparse Table умеет считать минимум на отрезке за $\O(1)$.
Из каждой ячейки посчитали миниму на отрезке длиной $2^k$ вправо из этой точки.
Также для всех чисел до $n$ посчитали максимальную степень двойки, не большую $x$.
Работает с функциями, которые зависят только от множества чисел (не от порядка и не от количества вхождений).
Disjoint Sparse Table: взяли дерево merge sort, в каждой вершине посчитали частичные суммы
на префиксах/суффиксах. Теперь работает с произвольными ассоциативными функциями.
Частичные суммы: работает с обратимыми функциями.
Полный предподсчёт: любые функции.

\section{} % 23
$\langle  \O(n), \O(\log n) \rangle$: разбили массив на отрезки размера $\log n$,
построили на них sparse table (он будет занимать $\frac{n}{\log n} \log n = \O(n)$ места и времени),
этакая корневая получилась.
$\langle \O(n \log \log n), \O(1) \rangle$: на каждом куске дополнительно построили обычный sparse table.
$\langle \O(n), \O(\log \log n) \rangle$: на каждом куске построим не sparse table, а дерево отрезков.
$\langle \O(n \log* n), \O(\log * n) \rangle$: на каждом куске будем строить рекурсивно ту же фигню.

\section{} % 24
Выпишем Эйлеров обход (корень плюс поддеревья, разделённые корнем), высоты соседей отличаются ровно на единицу.
Надо теперь в online решать RMQ (массив не меняется).
Разобъем на блоки длиной $k=\frac{\log n}{2}$.
На этих блоках построим sparse table.
Осталось только понять, что внутри блока.
Различных блоков у нас $2^{k-1}$ (если считать первый элемент блока нулём), предподсчитаем за $\O(2^{k-1}k^2)$ все типы запросов <<внутри блока>>.

\section{} % 25
Берём и строим со стэком правой ветки дерева.

\section{} % 26
Вершина, поддеревья (после каждого "--- еще раз вершина), для сведения LCA к RMQ.
Вершина, поддеревья (без разделителей), так можно считать функцию на поддереве вершин.
Каждое ребро встречается дважды (при входе и выходе) "--- можно считать обратимые функции на вертикальных путях.
