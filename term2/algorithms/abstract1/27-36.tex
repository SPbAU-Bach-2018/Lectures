\section{} % 27
Тарьян "--- dfs по дереву, поддерживаем СНМ.
Для каждой вершины (в которую вошли) представитель "--- текущий LCA.
При подъёме из вершины надо её множество объединить с множеством родителя.
Offline RMQ (можно еще свести к LCA) "--- перебираем запросы по увеличению правой границе,
храним стэк минимумов и СНМ для быстрого получения нужного минимума. 

\section{} % 28
От каждой вершины посчитали путь длины $2^k$ наверх (можно еще функцию по дороге считать).
Поиск LCA: сначала выровняли высоты, потом как бы бинпоиск.
Разреженная версия: как skip-list.
Будет работать быстро, потому что мы за каждый шаг либо двигаемся по skip list к пункту назначения оптимальным образом,
либо обнаруживаем, что двигаться не надо, попытавшись пройти по ребру, которое перепрыгивает через LCA "--- а таких $\O(\log)$.

\section{} % 29
Прошлись dfs'ом по дереву, в дереве отрезков поддерживаем путь от корня до текущей вершины,
так умеем считать функцию на вертикальных путях.
Обычный путь "--- это один или два вертикальных.
Можно поставить биекцию, если считать только на вертикальных путях:
Если мы хотим считать на рёбрах, а умеем только в вершинах, можно считать,
что в каждой вершине написано значение на ребре в родителя.
И наоборот "--- можно хранить на ребре значение из нижнего конца, над корнем добавить еще одну вершину.

\section{} % 30
Сначала как-нибудь посчитаем LCA для запросов.
Теперь у нас вертикальные пути.
Посчитаем сумму от вершины до корня.
Сумма на вертикальном пути "--- это разность сумм в концах.
Чтобы дерево можно было менять, давайте посмотрим на Эйлеров обход и
заметим, что сумма на вертикальном пути "--- это разность сумм на префиксах обхода
(если идём по ребру вниз "--- один знак, вверх "--- другой знак).

\section{} % 31
\TODO


\section{} % 32
Запустили итерацию алгоритма Борувки три раза (которая выбирает из каждой вершины самое дешёвое ребро и склеивает по ним).
Количество вершин уменьшилось хотя бы в восемь раз, получили из $(n, m)$ $(\frac n 8, m)$.
Возьмём случайную половину рёбер (точнее, каждое берём с вероятностью $p$) и запустимся рекурсивно.
Теперь, возможно, надо какие-то рёбра заменить.
Назовём ребро хорошим, если его концы лежат в разных компонентах или если максимум на пути (который мы ищем быстро) больше веса ребра.
Возьмём все хорошие рёбра (оценим, что их $\frac n 8$ "--- столько же, сколько вершин) плюс рёбра из ответа, запустимся рекурсивно еще один раз.
Лемма: если у нас спускается $k$ вершин, то матожидание хороших рёбер равно $(k-1)(\frac 1 p - 1)$ "--- написали Краскала, он на каждом
шаге либо с вероятностью $\frac{n-1}{p}$ вообще рассмотрит ребро, а еще с вероятностью $1-p$ оно не спустится вниз, с вероятностью $p$ спустит и объединит компоненты.

\section{} % 33
Храним Эйлеров обход по рёбрам в декартовом дереве по неявному ключу (со ссылками на родителей), каждое ребро хранится два раза.
\t{makeRoot} "--- циклический сдвиг, \t{link}/\t{cut} "--- несколько \t{makeRoot} и склейка/разрез в нужном месте.

\section{} % 34
При построении каждый раз идём в дерево с наибольшим размером.
Получаем, что при прыжке между разными путями у нас размер поддерева увеличивается хотя бы в два раза.

\section{} % 35
Задача: найти $k$-го предка вершины $v$.
В \t{offline} обошли dfs'ом, в массиве-стеке храним предков, отвечаем на запросы.
Двоичные подъёмы: обычные ($\left<\O(n\log n), \O(\log n)\right>$) и разреженные (которые как skip list, $\left<\O(n), \O(\log n)\right>$).
При помощи HLD: в путях храним просто массивы ($\left<\O(n), \O(\log n)\right>$).
А еще можно насчитать двоичные подъёмы (или что-то похожее) только в листах, а для каждой вершины хранить какой-нибудь лист из поддерева.

\section{} % 36
Longest-Path: как HLD, только идём в самое глубокое поддерево.
Ladder: каждый путь в разбиении продлили еще на его длину вверх.
Теперь посчитаем двоичные подъёмы из листов за $\O(m \log n)$ (где $m$ "--- число листов, простым dfs'ом).
Прыгнули из листа на $2^l$, попали в какой-то путь, он уходит вглубь хотя бы на $2^l$ (потому что longest-path) и вверх на столько же (потому что ladder),
то есть можно за $\O(1)$ прыгнуть на любое число до $2^l$, что нам подходит.
Эвристика: хотим, чтобы листов стало мало: $m \le \O(\frac{n}{\log n})$.
Идея, как в Фарах-Колтоне-Бендере.
Давайте разобьём дерево на макро-кусок (содержащий корень) и микро-куски, которые растут из
макро-куска, каждый размером не более $\frac{\log n}{4}$.
У макро-куска поддерево каждого листа имеет размер хотя бы $\frac{\log n}{4}$, поэтому листьев у него $\O(\frac{n}{\log n})$, что хорошо.
А микро-кусков различных мало (потому что он задаётся Эйлеровым обходом и бинарной последовательностью <<вверх-вниз>>).
Для каждого типа всё предподсчитаем.
