\subsection{Кодирование}
Кодируем многочлен $a(x)$.
Сначала опишем два способа получить кодовое слово из многочлена.

\begin{Def}
	\textit{Несистематическое кодирование}:
	многочлен $a(x)$ превращается в $c(x) = a(x) \cdot g(x)$ (по модулю).
\end{Def}

\begin{Def}
	\textit{Cистематическое кодирование}: у нас всего $n$ <<бит>>,
	сначала запишем $r$ проверочных (формула чуть позже), а потом исходное слово:
	\[
		c(x) = v(x) + x^r \cdot a(x)
	\]
\end{Def}
\begin{Rem}
Тут важно договориться, в каком порядке биты идут (с технической точки зрения).
\end{Rem}
\begin{Rem}
Философский вопрос, что является результатом декордирования:
кодовое слово или информационные символы.
\end{Rem}
При этом у нас и в систематическом, и в несистематическом кодировании
одинаково сложное восстановление кодовых слов.

Давайте закодируем систематически (несистематически уже умеем, формула есть).
\begin{lemma}
	При систематическом кодировании проверочные биты однозначно определяются.
\end{lemma}
\begin{proof}
	Нам надо взять $x^r \cdot a(x)$ и дописать ему что-то, чтобы получить кодовое слово
	(т.е. делящееся на $g(x))$.
	Попробуем, скажем, поделить с остатком на $g(x)$:
	\begin{align*}
		x^r \cdot a(x) &= g(x) \cdot b(x) + s(x) \quad \deg g = n, \deg b \le k - 1, \deg s \le r - 1 \\
		x^r \cdot a(x) - s(x) &= g(x) \cdot b(x)
	\end{align*}
	Вот и проверочные символы: $v(x)=-s(x)$.
	Они однозначны: \TODO
\end{proof}

\subsection{Декодирование}
Синдромы из линейных кодов мы уже знаем, тут тот же принцип.
Пусть $b(x)=c(x)+e(x)$ (принятый равен кодовому плюс ошибке).
Дальше поделили $c(x)$ и $e(x)$ на $g(x)$ с остатком, в первом случае остаток ноль,
во втором как раз синдром.

\begin{Def}
	\textit{Синдромный многочлен} $s(b)$ для многочлена $b(x)$ "---
	это остаток от деления $b(x)$ на $g(x)$.
\end{Def}
\begin{lemma}
	Синдром принятого вектора равен синдрому ошибки.
\end{lemma}
\begin{proof}
	Очевидно.
\end{proof}

\begin{theorem}
	Если есть две ошибки $w(e_1)\le t$ и $w(e_2) \le t$,
	то у них разные синдромы.
\end{theorem}
\begin{proof}
	Поделили, получили $g(x)(b_1(x)-b_2(x))=e_1(x)-e_2(x)$, т.е.
	разность векторов ошибки "--- кодовый вектор.
	Но мы знаем, что $w(e_1-e_2)\le 2t$ (потому что ошибки небольшие),
	но $2t < d$, следовательно противоречие (т.к. кодовый вектор веса
	меньше $d$, т.е. нулевой).
\end{proof}

\begin{Rem}
Теперь нам, конечно, всё ещё нужна табличка, но уже в $n$ раз меньше.
Потому что у нас коды циклические.

У нас все ошибки группируются: ошибка и все её циклические сдвиги.
Запоминаем из такой группы только один синдром.
А дальше при декодировании надо перебрать все сдвиги $b(x)$,
каждый раз вычислить синдром, в какой-то момент в запомненный синдром попадём.

Времени на декодирование, конечно, станет в $n$ раз больше
(попробовать все сдвиги).
\end{Rem}

\subsection{Что-то про поля, \TODO}
Типа вводим поле $GF(q^m)$.

Возьмём $GF(q)$.
Пусть $(n,q)=1$.
Тогда можно определить мультипликативный порядок $q$ по модулю $n$:
минимальное $m$ такое, что $q^m \equiv 1 \mod n$.
То есть $n$ делит $q^m-1$.

И можно в любом поле написать, что $x^n-1$ делит $x^{q^m-1}-1$
(это отдельная теорема: если натуральное число $a$
делит $b$, то $x^a-1$ делит $x^b-1$ в произвольном поле).

Теорема: если многочлен $f(x)$ взаимно прост со своей производной
$f'(x)$, то у них нет общих корней.
Это почти во всех полях верно, за одним исключением.

Тогда применим к многочлену $x^n-1$.
Он в любом поле не делится на $nx^{n-1}$.
Таким образом, у него нет нулевых корней.
