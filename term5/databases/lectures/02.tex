В современных СУБД есть несколько уровней абстракции, позволяющих оптимизировать работу.
Оптимизировать мы можем не только непосредственно работу с данными, но и программиста.
Внесение изменений могут быть вызваны:
\begin{enumerate}
	\item Изменением требований;
	\item Изменение <<железа>>;
	\item Изменение нагрузки.
	\item ...
\end{enumerate}

Мы, как в прошлый раз разбирались, не хотели, чтобы, если пришлось менять механизм хранения, пришлось менять все клиентские приложения.
Традиционно, для решения проблемы используется \textit{трёхуровневая архитектура}:
\begin{description}
\item[Внешний уровень (уровень представления):] уровень общения конечного приложения с СУБД.
	Для различных клиентов может быть разным (бугхалтеру не нужна информация о складе, начальнику склада "--- расчёт зарплат).
	Тут могут быть, например, протоколы вида HTTP, или чистые SQL-запросы.

\item[Концептуальный (логический) уровень:] логическая модель данных.
	Описывает, что хранится:
	\begin{javacode}
	class Employee {
		int Salary;
		//...
	}

	class Warehouse {
		Employee boss;
		//...
	}
	//...
	\end{javacode}
	Надо понимать, что крайне редко модель данных неизменна.
	
\item[Физический уровень:]
	Сами данные могут храниться много где.
	Могут на одном диске, могут на сетевом кластере.
	Какие-то поля (фотография работника) могут эффективнее храниться отдельно от остальных данных.
	Естественно, мы не хотим, чтобы изменения на этом уровне вылезали выше.
\end{description}
Между соседними слоями существуют отображения.
Отображения между внешним и концептуальным поддерживаются прикладными программистами,
между концептуальным и физическим "--- администраторами и разработчиками СУБД.

\chapter{Модели данных}

\section{Модель данных}

\begin{Def}
	Модель данных "--- некоторый набор концепций, позволяющий описать структуру и поведение наших данных.
\end{Def}
В разработке также под моделью данных могут понимать уже конкретную выстроенную реализацию (называя концепции метамоделью).
Сами же данные могут называть экземпляром модели.

\begin{enumerate}
	\item Структурный аспект (например, вершины дерева)
	\item Ограничения (в дереве у вершины не более одного родителя)
	\item Операции с данными (обход дерева, поиск элемента)
\end{enumerate}

История моделей примерно такая: сначала была одна иерархическая модель (есть узел, можно спрашивать, что внутри).
Позже возникла и стала крайне распространённая релационная модель (таблицы с отношениями между ними).
В 1990х пришла объектная модель, в 2000х "--- слабоструктурированная.
Кроме них, ещё есть модели вида <<ключ--значение>>, смешанные виды.

Мы будем заниматься чистой реляционной моделью данных.

\section{Реляционная модель}

Гланвым структурным отношением в релационной модели является \textit{отношение} (\textit{relation}),
а также \textit{дом\'ен} (\textit{domain}).

\begin{Def}
	Домен "--- множество допустимых значений.
\end{Def}
Их множество: булевский, число, строка, время года; какие захотите.
У каждого домена есть свои правила операций и действий, в том числе сравнение, сложение, и так далее.

У отношения два определения. Они чем-то похожи, чем-то отличаются, важно понимать.
\begin{Def}
	Пусть есть некоторый список доменов $[D_1, D_2, \dots, D_n]$.
	Рассмотрим функцию, переводящую элементы декартова произведения домнов в булевский тип:
	\[ f\colon D_1 \times D_2 \times \dots \times D_n \ra \{true, false\} \]
	Такая функция и называется отображением.
\end{Def}
Пока совсем не ясно, а где тут таблицы?..

\begin{Def}
	Отношение "--- пара из схемы и тела.
	Схема отношения "--- множество атрибутов $\{A_i\}$, представляющих собой пары из имени атрибута, его индетифицируещего, и его домена.
	Атрибуты равны, если равны их имена.
	Тело отношения "--- множество кортежей $\{t_i\}$, содержащий пары из названия атрибута и значения из соотвествующего домена.
	Каждый атрибут встречается ровно один раз.
	Кортежи равны, если для каждого атрибута его значения равны.
\end{Def}
\begin{Rem}
	В теории, можно разрешить дубликаты кортежей в теле.
\end{Rem}
Самым естественным видом такой конструкции является двумерная таблица.
Столбцам соотвествуют атрибуты: в заголовке каждый столбец подписан его именем, указан его домен.
Порядок атрибутов по определению не зафиксирован. Собственно, заголовок и является схемой.
Тело представлено строками таблицы, в каждой строке в соотвествующем столбце записаны значения атрибутов.
Порядок строк, опять-таки, не зафиксирован.
\begin{center}\tt\begin{tabular}{|c|c|c|c|}
\hline
$a_1: D_1$ & $a_2: D_2$ & $a_3: D_3$ & $a_4: D_4$ \\
\hline
1 & 2 & "foo" & true \\
2 & 4 & "bar" & false \\
2 & 5 & "baz" & false \\
\hline
\end{tabular}\end{center}

В чём же связь?
В первом определении можно сказать, что функция выдаёт значение, есть ли такой кортеж в теле; и наоборот, тело может задавать определение функции.
Важное отличие: в первом определении фиксирован порядок атрибутов, но не заданы имена атрибутов (их просто нет).
Мы будем пользоваться вторым определением, как более близкому к практической стороне.

Какие есть отношения ограничения в этой модели?
\begin{Def}
	Потенциальный ключ (candidate key) отношения $R$ "--- набор атрибутов из схемы отношения $R$ ($K \subset S_R$), обладающий свойствами:
	\begin{description}
	\item[Уникальность:]
		Если взять два кортежа из отношения $t_i$ и $t_j$, если они равны по всем атрибутам ключа, то они равны целиком:
		\[ V_K(t_i) = V_K(t_j) \Ra t_i = t_j \]
	\item[Неизбыточность:]
		Любое собсвтенное подмножество атрибутов ключа не обладает свойством уникальности.
	\end{description}
\end{Def}

\begin{Def}
	Суперключ "--- надмножество потенциального ключа (и, следовательно, обладает уникальности).
\end{Def}

Понятно, что потенциальных ключей может быть несколько.
Традиционно, один из них выбирается \textit{первичным ключом} (\textit{primary key}).
Ничем от других, кроме выбора, он не отличается.
Это ограничение "--- одно из самых важных.
По первичному ключу можно находить и индетифицировать записи.
