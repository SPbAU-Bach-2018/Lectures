\setauthor{Егор Суворов}
\subsection{Разминка 29.09.2016}

Задача: пусть есть отношения $R(a, b, c)$, $S(b, d)$, $T(c, e)$.
Они имеют размеры $|R|$, $|S|$, $|T|$.
Также мы знаем, что $S.b$ "--- это внешний ключ для $R.b$,
а $T.c$ "--- это внешний ключ для $R.c$.
Мы хотим узнать размер отношения $|(R \bowtie S) \bowtie T|$.

Ответ: что-то не большее $\min(|S|, |T|)$.

\subsection{Функциональные зависимости}
	\begin{Def}
		Пусть есть отношение $R(A, B, C)$.
		Тогда мы говорим, что $B$ (\textit{зависимая часть})
		textit{функционально зависит} от $A$ (\textit{детерминант}), если для любого экземпляра
		$R$ (любого набора кортежей) верно следующее:
		\[ \forall t, t' \in R \colon V_A(t) = V_A(t') \Ra V_B(t) = V_B(t') \]
		То есть если две строки имеют одинаковые
		значения атрибутов $A$, то они гарантировано имеют одинаковые значения
		атрибутов $B$.
	\end{Def}
	\begin{Rem}
		Обозначается $A \rightarrow B$; $A$ \textit{функционально определяет} $B$.
	\end{Rem}
	\begin{Rem}
		Функциональная зависимость "--- это ограничение на уровне схемы,
		а не свойство конкретного экземпляра.
	\end{Rem}
	\begin{exmp}
		Пусть есть такой экземпляр $R$:
		\[
			\begin{matrix}
				A & B & C \\
				2 & 4 & 5 \\
				2 & 4 & 6 \\
				3 & 8 & 1 \\
				3 & 8 & 2 \\
			\end{matrix}
		\]
		Тут мы не можем сказать, есть ли функциональная зависимость между $A$ и $B$,
		потому что мы не знаем ничего про остальные возможные экземпляры $R$, нам дали только один.
	\end{exmp}
	\begin{exmp}
		Ключ всегда является детерминантом для всех остальных атрибутов.
	\end{exmp}

	\begin{exmp}
		Пусть есть таблица со следующими атрибутами, описывающая космические перелёты:
		планета, политический строй, дата, корабль, капитан, рейтинг капитана.

		Тут есть ключ (планета, дата), если мы считаем, что в день не больше одного рейса на планету.

		Помимо ключа, есть ещё два детерминанта:
		\begin{enumerate}
			\item Планета функционально определяет политический строй на планете.
			\item Капитан функционально определяет его рейтинг.
		\end{enumerate}
	\end{exmp}
	Видим, что храним много избыточной информации.

	Давайте теперь предположим, что у нас нет ключа (планета, дата), но зато мы знаем,
	что от (планета, дата) есть функциональная зависимость к капитану.
	А от капитана "--- к кораблю.

	А теперь видим, что у нас возникает некоторое количество неявных функциональных зависимостей:
	по транзитивности и взятию подмножество можно сделать вывод, что (планета, дата) функционально
	определяет всё остальное.
	Тогда полный набор зависимостей называется \textit{замыканием}.
	Соответствующие формальные правила называются аксиомами Армстронга:
	\begin{enumerate}
		\item Самоопределение: $A \to A$.
		\item Рефлексивность: $AB \to A$.
		\item Транзитивность: если $A \to B$ и $B \to C$, то $A \to C$.
		\item Дополнение: если $A \to B$, и $A \to C$, то $A \to BC$.
		\item Если $A \to BC$, то $A \to B$ и $A \to C$.
		\item Если $A \to B$ и $C \to D$, то $AC \to BD$.
	\end{enumerate}

	Если бы какая-нибудь БД желала бы проверять функциональные зависимостей, то ей
	бы эти правила очень помогли для вывода зависимостей.
	Но этим никто не занимается, кроме проверки уникальности ключа.
	\begin{Def}
		Два множества зависимостей $S$ и $T$ называются эквивалентными ($S \sim T$),
		если совпадают множества их замыканий: $S^{+} = T^{+}$.
	\end{Def}
	В целом СУБД могла бы найти эквивалентное множество зависимостей, но этого никто не делает.
	Считается, что это забота программиста.

\subsection{Нормальные формы}
	Давайте вспомним наш пример с космическими полётами.
	Там было много функциональных зависимостей и возникали следующие практические проблемы:
	\begin{enumerate}
		\item
			Если у капитана поменялся рейтинг, то его надо обновить во всех строчках.
			Мы считаем, что нас прошлый рейтинг не интересует, иначе мы скатываемся в
			так называемые <<темпоральные базы данных>>, которые являются отдельной банкой с червями.
		\item
			Если была открыта новая планета, то мы не сможем сохранить о ней информацию,
			пока не полетит хотя бы один рейс.
			Например, потому что первичным ключом является (планета, дата).
		\item
			Если увольняем капитана, то надо удалить все его полёты и, возможно, даже некоторые планеты.
	\end{enumerate}

	Нормальная форма "--- это некоторый набор правил/условий.
	Каждая более высокая НФ содержит все правила более низких НФ.
	\begin{Def}
		\textit{I нормальная форма}: любое корректное отношение находится в I НФ.
	\end{Def}
	\begin{Rem}
		Тут важно то, что в каждом атрибуте каждого кортежа находится ровно одно значение.
	\end{Rem}
	\begin{Rem}
		На практике довольно часто нарушается.
		Например, если вы в таблицу с космическими полётами добавите атрибут <<имена пассажиров через запятую>>,
		то вы нарушите I нормальную форму.
		Формально нарушения нет (одна же строчка в атрибуте хранится), но идеологически нарушение есть.

		На самом деле даже если БД поддерживает тип данных <<массив>>, то она уже нас провоцирует
		нарушать первую нормальную форму подобным образом.
	\end{Rem}

	\begin{Def}
		Функциональная зависимость $A\rightarrow b$ \textit{неприводима},
		если из левой части ничего нельзя выкинуть.
	\end{Def}
	\begin{Def}
		\textit{II нормальная форма} для отношения с ровно одним потенциальным ключом (не суперключом):
		любой неключевой атрибут (который не является частью ключа) функционально неприводимо зависит от этого ключа.
	\end{Def}

	\begin{exmp}
		Вспоминаем таблицу с полётами и ключом (планета, дата).
		Она не находится во II нормальной форме, так как атрибут <<строй>> зависит только
		от атрибута <<планета>>, то есть функциональная зависимость не неприводима.
	\end{exmp}
	\begin{Rem}
		Если в отношении ключ не составной, то II нормальная форма автоматически выполняется.
	\end{Rem}
	\begin{Rem}
		Тут, опять же, можно формально хитрить, заведя суррогатный ключ (SERIAL и иже с ним, значения которых генерируюются автоматически).
		Но это неинтересно: стоит смотреть на <<реальные>> ключи.
	\end{Rem}
Что же делать чтобы соблюдать 2 нормальную форму?
Стандартный приём "--- декомпозиция.
Декомпозиция "--- разложить отношнение на проекции, собирать обратно склейкой.
Понятно, что при этом у проекций должен быть общие атрибуты, но кажется, это не полное требование.
Мы можем разбить нашу сложную строчку про корабли, выделив планеты, но общим атрибутом не надо оставлять строй.
Поэтому надо добавить требование, чтобы соединение проекций было равно исходному отношению.
Такая декомпозиция называется безопасной.

Нужен критерий безопасности декомпозиции.
\begin{theorem}[Хита (Heath)]
	Если в отношении $R(a, b, c)$ есть функциональная зависимоть $a \ra c$,
	то $R$ можно безопасно декомпозировать в проекции $(a, b)$ и $(a, c)$.
\end{theorem}
Например, у нас в таблице про корабли имеет смысл выделить проекцию Планета"---Строй, оставив у рейса аттрибут Планета.
Это кажется довольно очевидным, но тем не менее важно и полезно.
