\setauthor{Егор Суворов}
\subsection{Разминка 03.11.2016}

	Пусть есть буффер в памяти из $M=100$ блоков, а также есть отношение $R$,
	состоящее из $B(R)=10\,090$ блоков.
    Вопрос: за сколько операций ввода-вывода мы сможем его отсортировать?

    Решение: если $B(R) \le M^2$, то мы могли бы отсортировать за $3B(R)$
    чтений и ещё $B(R)$ записей, итого $4B(R)$.
    Но у нас на 90 блоков больше, есть несколько вариантов:
    \begin{itemize}
    	\item
    		Можно сначала отсортировать первые $10\,000$ блоков,
    		потом отсортировать хвост за 180 операций, 
    		потом слить два результата за $10\,000+90$ операций,
    		получаем чуть больше $5\cdot 10^4$ операций ввода-вывода.
		\item
			Давайте посмотрим повнимательнее, что происходит
			в алгоритме сортировки $10\,000$ блоков.
			А конкретнее "--- на ситуацию, когда у нас уже
			есть 100 списков из 100 отсортированных блоков в каждом
			(перед сливанием).
			В этот момент мы сделали $20\,000$ операций.

			Давайте сольём 91 список (из ста) и запишем на диск.
			Потом давайте прочитаем хвост из 90 блоков в память, отсортируем.
           	Осталось 10 слотов в памяти.
			Из них 9 слотов отведём под головы оставшихся неслитых девяти списков,
			а один слот "--- под голову списка-результата.

			Получим порядка $48\,000$ операций.
		\item
			Третий подход: сначала будем сливать не 91 список, а 50.
			Потом сольём 90 блоков из хвоста.
			Итого получили 52 списка, которые уже можно слить за один подход по диску.

			Результат "--- порядка $40,270$ операций.
		\item
			А если мы сольём не 50 списков, а 10 (хвост тоже сольём), то получим 92 списка,
			их тоже можно слить за один подход.

			Получим порядка $32\,270$ операций.
		\item
			А если сольём ещё меньше списков, то получится $30\,670$.
    \end{itemize}

\section{Операции соединения}
	Пусть есть отношения $R$ и $S$, которые мы хотим соединить.
	У нас есть алгоритм соединения nested-loop-join с его стоимостью работы $B(R) + \frac{B(R)\cdot B(S)}{M}$ (в I/O операциях).

\subsection{Sort join}
	Давайте попробуем улучшить результат при помощи так называемого sort join.
	Сначала предположим, что памяти у нас довольно много ($B(R), B(S) \le M^2$).
	Тогда отсортируем $R$ и $S$ по общему атрибуту за $4(B(R)+B(S))$,
	и будем их объединять методом двух указателей за ещё $B(R)+B(S)$,
	на это потратим ещё $B(R)+B(S)$ чтений (записывать результат обратно на диск не будем).
	Итого $5B(R)+B(S)$, если памяти хватает.

	Но есть проблема: у нас соединение может каждому элементу сопоставлять несколько.
	Например, если общий аттрибут в $R$ везде равен единице, то нам нужно будет
	вывести для каждого элемента $S$ вывести все $R$.
	Если $R$ целиком поместился в буфер, то проблем нет, а иначе нам придётся читать с диска
	старые блоки $R$.

	Более строго: если у нас для любого значения общего аттрибута либо все такие строки
	из $R$ помещаются в память, либо из $S$, то проблем не возникает "--- читаем то,
	чего меньше, а потом выводим результат (конечно, надо угадать, кто поместится в память;
	либо попробовать прочитать каждое и честно посчитать, либо воспользоваться статистикой и угадать).
	А вот если и там, и там строк много, то у нас получится большое декартово произведение.
	И придётся сделать вложенный цикл с чтением блоков.

\subsection{Улучшение sort join}
	Пока что sort join проигрывает nested-loop-join на небольших отношениях.
	Например, если $M=100$, $B(R)=1000$, $B(S)=500$, то NLJ отработает за:
	\[
		B(R) + \frac{B(R)\cdot B(S)}{M} = 1000+\frac{1000\cdot500}{100}=5500
	\]
	А вот sort join будет читать с диска намного больше:
	\[
		5(B(R)+B(S)) = 5 \cdot (1000+500) = 7500
	\]

	Что делать?
	Можно, конечно, просто применять NLJ для небольших отношений.
	Но можно и соптимизировать sort join.
	Давайте посмотрим на сортировку в тот момент, когда она уже собрала списки,
	но ещё не начала их сливать вместе.
	В отношении $R$ она получила 10 списков, в отношении $S$ "--- 5 списков.
	Можно загрузить в память одновременно головы всех списков и выполнять merge списков
	одновременно с соединением, тогда нам не надо записывать на диск промежуточные результаты.
	Итого получим на каждый блок из каждого отношения две операции для получения списков (чтение+запись),
	и ещё одну операцию чтения после получения списков:
	\[
		3(B(R)+B(S)) = 3 \cdot (1000+500) = 4500
	\]
	Мы выкинули промежуточную запись-чтение между вторым этапом multiway merge sort и соединением отношений.
	Это всё работает только в том случае, если $B(R)+B(S) \le M^2$ и если нам не надо возвращаться читать уже выкинутые блоки при помощи вложенных циклов.
	Это покрывает большое количество случаев; обычно соединения идут по ключу и внешнему ключу, а со стороны ключа каждая строчка уникальна,
	поэтому во вложенные циклы с повторным чтением блоков мы не свалимся.

\subsection{Hash join}
	Основная идея: сгруппируем кортежи с одинаковым хэшом по корзинам хэш-таблицы,
	обработаем каждую корзину отдельно.
	\begin{enumerate}
		\item
			Выбираем количество корзин $K$, заведём столько корзин на диске.
			Каждая корзина "--- сколько-то блоков, которые мы будем заполнять кортежами.
		\item Для каждого кортежа $r$ из $R$ вычисляем номер корзины и кладём его туда:
			\[ i = hash(V_a(r)) \bmod K \]
		\item Аналогично для всех кортежей из $S$.
		\item Теперь внутри каждой корзины лежит сколько-то кортежей из $R$ и сколько-то кортежей из $S$.
		\item Теперь обработаем каждую корзину:
			\begin{itemize}
				\item Если корзина маленькая, то мы можем целиком прочитать её в память.
				\item Иначе можно написать NLJ. Если хотя бы одно отношение из корзины целиком поместится в память, то чтений всё ещё будет линейно.
				\item А если в корзине каждого отношения больше памяти, то всё плохо.
			\end{itemize}
	\end{enumerate}
	Обычно корзины получаются маленькие.
	Итоговое количество чтений:
	\[
		\underbrace{2(B(R)+B(S))}_{хэширование} + \underbrace{(B(R)+B(S))}_{обработка корзин}
	\]

	Тонкости: на первом этапе (хэширование) нам требуется, чтобы мы могли хранить
	последний (недозаполненный) блок от каждой корзины.
	Если $K > M$, то нам в худшем случае при добавлении кортежа в корзину придётся лезть на диск,
	и мы получим вообще $|R|$ операций ввода-вывода вместо $B(R)$, что очень плохо.
	Значит, точно требуется $K \le M$.

	А также надо, чтобы после хэширования размер каждой корзины получился не более $M$.
	Так как в сумме блоков в корзинах получается $B(R)+B(S)$, то мы получаем следующее ограничение применимости:
	\[ B(R)+B(S) \le M^2 \]
	Тут, конечно, не учитывается то, что кортежи могут распределяться между корзинами неравномерно.
