\begin{Def}
	Индекс "--- персистентная избыточная структура данных для ускорения некоторых операций.
	Обычно создаётся для одного атрибута, и позволяет быстро находить записи с заданными значениями атрибутами.
\end{Def}
Например, мы храним в кортежи отсортированно по аттрибуту, и помним, где какой.
Так мы при поиске по имени можем экономить чтения с диска, так как читаем только имена и позиции записей.

У одного отношения может быть много индексов по разным атрибутам.
Индексы бывают разные.
Например, разреженный индекс (Sparce index) содержит указания не на все аттрибуты.
Плотный индекс содержит все записи. Иногда даже полезно создать индекс для индекса.

Как для атрибута хранить его записи?
Если все кортежи для заданного значения аттрибута лежат плотно, то есть на диске кучно, почти заполняя блок, то индекс называется кластеризующим.
Если же котрежи лежат неплотно, то индекс "--- некластеризующий.

Плюс: операции поиска становятся шустрее.
Минус: индекс надо поддерживать в корректном состоянии, ещё и на диске место занимает. При больших обновлениях их легче перестраивать с нуля, очень дорого.

Есть ещё B-деревья.
Это дерево поиска, обычно глубины 2-3.
Она уже построенна на дисковых блоках.
В нижнем уровне хранятся упорядоченные значения.
В промежуточных хранятся какие-то значения ($n$), указатели на нижние уровни слева и справа от него (всего $n+1$).

Как ищем? Встали в корень. Выбрали диапазон, в который попало значение.
Перешли на следующий уровень, там то же самое.
И так далее до нижнего уровня, где просто идём слева направо до нашего значения.

Цель B-дерева состоит в том, чтобы глубина дерева была постоянной.
При модификации надо поддерживать это.
Пусть мы хотим добавить значение.
В лучшем случае в подходящем листе есть место.
Иначе "--- расщипляем лист на два, и добавим диапазон в родителе.
Там тоже может расщипиться (только так, чтобы слева и справа в поддеревьях оказалось поровну).
