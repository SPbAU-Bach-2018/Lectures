Рассмотрим алгоритм Multiway Mergesort.
Его используют очень многие СУБД.
Пусть у нас есть $M$ блоков в буфере.
Через них мы будем сортировать $N$ блоков на диске.

\begin{enumerate}
\item
	Читаем группами по $M$ блоков, сортируем их в RAM, сохраняем на диск.
	Получили $\lceil N / M \rceil$ отсортированных отрезков на диске.

\item
	Хотим сливать блоки.
	Берём, и из всех отсортированных отрезков загружаем первый блок, оставив один блок на вывод (если поместятся, иначе ниже).
	Выбираем минимум, его выталкиваем в блок вывода, переходим к следующему элементу в соотвествующем блоке.
	Если в блоке кончились элементы "--- догружаем следующий блок из его списка.
	Если в выводе место кончилось "--- на диск его!
\end{enumerate}
Всего операций I/O: каждая запись пишется и читается по 2 раза, то есть $4N / M$.
Работает, оно, конечно, когда $N \le M^2$.
Например, если у нас 16Гб RAM, то мы можем сортировать до $2^60$ байт.

Если не хватает "--- то во много слоёв. Обращений к диску линейно зависит от количества слоёв.

Можно, кстати, вывод делать не на диск, а на дальнейшую обработку по конвееру.
Например, при обработке запроса
\begin{sqlcode}
SELECT name, COUNT(*)
	FROM T
	GROUP BY name;
\end{sqlcode}
можно отсортировать по имени, и дальше передавать это в оконную функцию.

\begin{sqlcode}
SELECT *
	FROM T
	WHERE Year = 1990;
\end{sqlcode}
Как можно это выполнить?
Ну не знаю.
\begin{description}
\item[Full Scan:]
	Читать всёёёёёё!

\item[Index:]
	Если есть уверенность, что данные в целом разные, то можно по какой-то структуре понять,
	где лежат все записи с таким значением, и это быстрее полного чтения.

\item[Отсортированность:]
	Если предыдущий элемент конвеера дал отсортированные по году данные,
	быстро пропускать данные до, дождаться конца нужных и убить оставшиеся.
	Или можно воспользоваться тем, что данные целиком отсортированы, и сделать двоичный поиск.
\end{description}

Что посложнее:
\begin{sqlcode}
SELECT *
	FROM T
	NATURAL JOIN T2;
\end{sqlcode}
Тут помогут \textbf{Nested loops}.
У нас есть массивы, хотим по ним построить пары.
Как можно это сделать:
\begin{pythoncode}
for i in a:
	for j in b:
		if i.id = j.id:
			output(i, j)
\end{pythoncode}
Куда уж проще?

Пусть у нас есть мало (можно уместить в оперативную память) записей одного типа и много других.
Тех, которых мало, можно загрузить в память и держать там.
Потом из большого отношения читаем все записи (поблочно, нам больше одной записи за раз не нужно), выписываем им все парные, идём дальше.
Чтений получается суммарный объём данных.

А если оба не помезаются?
Можно одно отношение читать большим окном, и с этим окном пробежаться по другому.
Если читаем окном отношение $T$, а пробегаемся по $S$, то получим $B(T) + \lceil \frac{B(T)}M \rceil B(S)$ чтений.

Ещё есть всякие \textbf{SORT JOIN}, \textbf{HASH JOIN}.
