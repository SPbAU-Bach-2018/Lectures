\chapter{Транзакции. Конкурентный доступ}

Откуда вообще параллельный досутп?
Многопроцессорность, минимизация ожидание начала операции, ожидание диска.
Как же с ней жить?

Вспомним, что ещё есть менеджер буферов: страницы, которые прочитали с диска или недавно изменили, хранятся в памяти.
Если мы храним каждую страницу не более чем в одном экземпляре,
то одна транзакция может увидеть ,,грязные`` промежуточные данные другой транзакции, и они отработают не так, как хотелось бы.
В идеале, конечно же, мы хотим, чтобы транзакции имели такой же эффект, как если бы они выполнялись последовательно.

С точки зрения программиста, транзакция "--- атомарная операция,
переводящая БД из одного согласованного состояния (выполнены все ограничения) в другое согласованное.
Эта атомарная операция состоит из более чем одного запроса, и в конце БД или принимает результат этих запросов, или откатывает целиком.

Какие бывают свойства у транзакций? ACID:
\begin{description}
	\item[Atomic, Атомарность:] Программист выставляет границы транзакции, СУБД гаранирует атомарность исполнения.
	\item[Compatability, Согласованность:] Программист за транзакцию не нарушает согласованность, СУБД гарантирует сохранение согласованности.
	\item[Isolation, Изолированность:] Это ниже.
	\item[Durability, Долговечность:] СУБД гарантирует, что результаты транзакции, помеченных как выполненые, уже персистентно хранятся.
\end{description}

Изолированность даёт политики, по которым транзакция работает, как будто она одна;
мы можем управлять тем, когда результаты транзакций становятся доступны другим.

Рассмотрим расписание выполнения транзакций (schedule).
Доступ к диску должен быть как-то упорядочен.
Упрощённо, транзакции читают страницы, пишут страницы и выполняют какую-то арифметику.
Расписанием для транзакций будет упорядоченная последовательность действий, которые выполнется в БД,
что каждая транзакция имеет естественный порядок своих действий, а между транзакций "--- ничего не знаем.

Формализуем операции:
\begin{description}
	\item[$R_i(x)$:] чтение данных $x$ в память транзакции.
	\item[$W_i(x)$:] запись данных $x$ из памяти транзакции.
	\item[$A_i(x)$:] манипулирование данных в памяти транзакции.
\end{description}

Можно составить сериализуемое расписание, эквивалентное некоторому последовательному исполнению транзакций.
Пусть есть расписание:
\[\begin{array}{cc}
	R_1(x) & \\
	A_1(x) & \\
	W_1(x) & \\
	& R_2(x) \\
	& A_2(x) \\
	& W_2(x) \\
	R_1(y) & \\
	A_1(y) & \\
	W_1(y) & \\
	& R_2(y) \\
	& A_2(y) \\
	& W_2(y) \\
\end{array}\]
Это сериализуемое расписание, но не последовательное.
Тут легко можно переставить пару $W_1$ - $R_2$ местами, и оно вообще перестанет быть сериализуемым.

Не стоит рассчитывать, что изменения пользователя не меняют данные, слишком это плохо предсказывается.
Это конечно увеличивает множество сериализуемых расписаний, но опираться на это не надо;
надо строить расписания, сериализуемые независимо от действий.

В СуБД есть компонент ядра, управляющий транзакциями, и планировщик.
Планировщик взаимодействует с обработчиком запросов, узнавая, что за действия хочет выполнить транзакция.
Он должен разрешить конфликтующие дейсвтия "--- соседние действия, порядок которых влияет результат.

Действия внутри транзакции по определению конфликтуют.
Действия между транзакциями...
\[\begin{array}{c|cccc}
	       & R_2(X) & R_2(Y) & W_2(X) & W_2(Y) \\ \hline
	R_1(X) &   +    &   +    &   -    &   +    \\ 
	R_1(Y) &   +    &   +    &   +    &   -    \\ 
	W_1(X) &   -    &   +    &   -    &   +    \\ 
	W_1(Y) &   +    &   -    &   +    &   -    \\ 
\end{array}\]
Неконфликтующие соседние действия коммутируют, можем менять местами.
Если расписание таково, что такими перестановками можно получить последовательное расписание, сериализуемое по конфликтам.

Важно понимать, что бывают сериализуемые расписания, не сериализуемые по конфликтам.
Например, если изменения данных их не меняют, то конфликт есть, а менять местами что-то можно.

Как понять сериализуемость по конфликтам расписания?
Может помочь граф: вершины "--- транзакции, рёбра "--- пары транзакций, между действиями которых есть конфликты,
причём ребро идёт в порядке выполнения действий в расписании.

Сам критерий... В следующей серии!
