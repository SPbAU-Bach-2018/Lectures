Сейчас мы будем строить всякие модели для подсчёта размера соединений.
Это очень важно. Нужно, чтобы
\begin{itemize}
\item Считалось быстро.
\item Результаты были похожи на истину
\item Были верные в том числе в граничных случаях
\item Не зависили от способа и порядка выполнения
\end{itemize}

Предположения:
\begin{description}
\item[Вложенность множеств значений атрибутов:]
	если есть отношения $R(a, b)$ и $S(a, c)$, и есть ординальность $V(R, a) < V(S, a)$, то $\sigma_a(R) \subset \sigma_a(S)$.
	Применим:
	\[ |R \bowtie S| = \frac{T(R) T(S)}{\max\{V(R, a), V(S, a)\}} \]
	Если мы строим декартого произведение ($V = 1$), то работает.
	Если мы соединяем по внешнему ключу, то тоже работает.

\item[Сохранения множества значений атрибутов:]
	$V(S, a) = V(R \bowtie S, a)$.
	Оно работает, если каждому значению есть пара, иначе чуть грустнее.
	Поприменяем:
	\begin{gather*}
		| T(c, d) \bowtie (R \bowtie S)) |
		= \frac{T(T) \cdot \frac{T(R) T(S)}{\max\{V(R, a), V(S, a)\}}}{\max\{V(T, c), V(R \bowtie S, c)\}}
		= \frac{T(T) T(S) T(R)}{\max\{V(R, a), V(S, a)\}\max\{V(T, c), V(R \bowtie S, c)\}}
	\end{gather*}
\end{description}

Вообще, при соединениях количество видов планов растёт очень быстро.
Ведь соединения образуют деревья, и вариантов деревьев с заданным числом листьев растёт очень и очень быстро\footnote{Числа Каталана}.	

Давайте думать про сложность соединений.
Пока мы соединяем два, у нас нет промежуточных отношений, и сложность есть 0.
Если уже три, то понятно, что стоит взять минимальную пару в качестве промежуточного результата.
Если уже хотя бы 4...

\begin{center}\begin{tabular}{c|cccc}
	     & R(a, b) & S(b, c) & T(c, d) & U(a, d) \\
	T()  & 1k      & 2k      & 5k      & 10k     \\
	V(b) & 200     & 2k      &         &\\
	V(c) &         & 500     & 1k      &\\
	V(d) &         &         & 2k      & 5k   \\
	V(a) & 1k      &         &         & 100
\end{tabular}\end{center}
Пробовать будем только леворекурсивные деревья, потому что алгоритмам обычно нужно какую-то определённую сторону держать в памяти,
а держать кучу временных результатов дорого.
\begin{center}\begin{tabular}{c|cccccc}
	     & RS & RT & RU  & ST  & SU  & TU \\
	Size & 1k & 5M & 10k & 10k & 20M & 10k \\
	Cost & \multicolumn{6}{c}{0}
\end{tabular}\\\begin{tabular}{c|cccc}
	     & (RS)U & R(TU) & (ST)U & (RS)T \\
	Size & 10k   & 10k   & 20k   & 5k \\
	Cost & 1k    & 10k   & 10k   & 1k
\end{tabular}\end{center}
Вы знаете динамическое программирование, мы им тут пользуемся.
Выбираем, что добавляем к результату, и выбираем оптимальный.
Ответ, кстати, оказался стоимостью в 6k.

Такой подход всё равно требует какой-то неприличный размер расчётов.
Можно брать жадный алгоритм: каждый раз присоединям чтобы результат был поменьше.
Он, конечно, смотрит только на малое число вариантов, и иногда, кажется, может лажать, но хорош.
