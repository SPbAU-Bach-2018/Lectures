\begin{Rem}
	Разминка 13 октября.
	Есть отношение: Капитан, Корабль, Дата, Планета, Расстояние.
	В один день и капитан, и корабль не могут совершать больше одного полёта.
	Расстояние до планеты зависит от даты.
	В одну дату до заданной планеты происходит
	\begin{enumerate}
	\item много
	\item не более одного
	\end{enumerate}
	рейса.
	В какой нормальной форме находится отношение?

	Решаем.
	Капитан, Дата "--- ключ.
	Корабль, Дата "--- тоже ключ.
	Планета, Дата "--- определяют расстояние.
	Ещё, возможно, Планета с Датой является ключом.

	Как видно, в варианте 2 в левой части во всех детерминантах стоят ключи, так что НФБК;
	а в варианте 1 расстояние зависит от неключа, нет НФБК.
	При этом расстояние "--- единственный неключевой аттрибут "--- зависит от всех ключей, но не нетранзитивно
	(например, Капитан, Дата "--- Планета; Планета, Дата "--- расстояние). Поэтому только вторая.
\end{Rem}

Как мы видели, доступ к оперативной памяти заметно дешевле диска.
Явно хочется не работать с диском, а работать без оперативной памяти не получается.
Поэтому мерой эффективности будем считать количество обращений к диску.

Хочется взять все данные, загрузить в оперативную памяти и жить.
И всё неплохо, но её может не хватить.
Понятно, что в какой-то момент хочется прочитанные данные обратно сбросить.
Этим занимается buffer manager (по-русски не будем называть):
он обрабатываем запросы "Дай страницу с диска", отвечает или из памяти, или из диска, при этом, возможно, убирая что-то на диск или выкидывая.
Какие могут быть политики:
\begin{description}
\item[Время последнего обращения (Least recently used, LRU):]
	Выкидываем страницу, которую просили раньше всех других.
	Нужно при этом хранить структуру данных, отслеживающую времена обращений.

\item[Очередь (FIFO):]
	Простая структура.

\item[Количество обращений (Least frequently used, LFU):]
	К кому меньше всего обращаются, того и тапки.
	Но, проблема: если к кому-то очень много раз обратились и забыли, то <<тонуть>> оно будет долго.

\item[Часы:]
	Пусть есть кольцевой буфер.
	У каждый странице есть бит "--- было ли обращение.
	Ещё есть стрелка.
	Каждый раз, когда надо вытеснить страницу "--- мы двигаем стрелку до первого нуля, при этом обнуляя счётик всем, кого посетили.
	Таким оразом, если за оборот стрелки страница не нужна "--- её выкидывают.

	Можем расширить счётчик численными значениями, чтобы можно задавать вес.
	По-сути, комбинируем сюда предыдущий подход.
\end{description}

Окей, а что же со страницами?
Мы читаем с диска какими-то блоками.
Удобно их и брать.
В страницах мы храним сколько-то кортежей, каждый кортеж обычно хранится как просто набор байт подряд.
Внутри страницы хранятся подряд несколько кортежей, и вряд ли очень хочется хранить кортеж по частям в разных страницах.

Теперь ищем запись в странице.
Если мы знаем, что они фиксированного размера, то просто по сдвигу.
Можно хранить в начале страницы директорию, где какая запись.

Как правило, отношение на странице не поместится, нужно по многим страницам.
Можно устроить связный список страниц, для каждого отношения хранить первую страницу.
Нужны указатели страниц на диске.
Можем нумеровать блоки, а как мы помним, у диска есть поверхности, на них дорожки (цилиндры), на них сектора.
Зачем нам нужна вся эта информация? Мы бы хотели, чтобы страницы шли подряд и быстро читались, для этого их хочется двигать.
При этом рушатся физические адреса.

Хотим логические адреса на диске.
С пейджингом и скоростью доступа.
Это реализует файловая система, ОС или даже контроллер диска, хотя некоторые СУБД работают с диском напрямую, решая этот вопрос сами.
