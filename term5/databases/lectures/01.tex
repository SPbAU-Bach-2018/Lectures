\chapter{Введение}

\section{Организационное}

Отчётность "--- дифференцированный зачёт по теории, письменный.
Если по практикам всё плохо "--- минус балл.
В начале лекции "--- разминка, небольшой тест на небольших бумажке.
В конце лекции "--- контрольные вопросы на \href{http://goo.gl/ptnYrW}{Stepik}-е, поощерение за выполнение теста на месте быстро и правильно "--- печеньки.

Про практику "--- две контрольные работы.
Только они решают, прошли вы практику или нет.
Про структуру практик "--- подробнее на практиках.

На лекциях будут следующие темы:
\begin{enumerate}
	\item Модели данных
	\item Физическая реализация
	\item Транзакции, оптимизация запросов.
\end{enumerate}

Контакты: \href{mailto:dbms@barashev.net}{\texttt{dbms@barashev.net}}, по поводу курса пишите именно сюда, и никуда более.
Есть вебсайтик (может, даже, работает) \url{http://dbms.barashev.net}, там могут появляться материалы.

\section{Введение}

Всем очевидно, что надо хранить какие-то данные.
Хранить \textit{персистентно}, то есть чтобы данные сохранялись.
Вот вы программист, вам надо хранить данные пользователя приложения.
Как вы можете их хранить?
\begin{description}
\item[Файлик:]
	Ваше приложение <<Контакты>> просто хранит на телефоне текстовый файлик \\\texttt{contacts.txt},
	в котором на каждой строке записан один контакт "--- имя, фамилия, телефон,..

	В будущем, предположим, у вас появляется вторая программа <<Почта>>, которой хочется работать с теми же данными.
	Пока, чтение и там, и там, происходит чтение так:
\begin{javacode}
class ContactsReader {
	//...
}
\end{javacode}
	Вам скажут: копипаста кода, плохо!

\item[Библиотека:]
	Через сколько-то усилий появляется библиотека \verb'read_contacts', которая и работает с файликом.

	И тут вы получаете race condition на чтение-запись в файл.
	Поплакав над убытками, вы добавляете блокировку на ваш файл.

	Ваш бизнес растёт, вы уже обслуживаете IKEA, и ваши программы уже крутятся на многих компьютерах во многих экземплярах.
	Они все хотят читать-писать наш файлик, который расположен на сетевом диске, и даже если средства синхронизации работают,
	но из-за задержек, количества пользователей, невозможности заблокировать кусок файла, всё работает уже совсем так себе.
	Что делать?

\item[Сервис:]
	Теперь у нас уже отдельный сервис \texttt{ContactsManager}, управляющий данными, а остальные с ним общаются.
	Общение уже не на языке Java, кстати "--- по сети вызовы методов не идут.

	И как только эта задача будет решеша, вы, кстати, и написали свою \textit{систему управления базами данных (СУБД)}
	"--- програмный комплекс, предоставляющий другим сервисам доступ к базам данных.
	Часто ещё говорят, что программа подключается или обращается к базе данных, на самом деле имея в виду обращения к СУБД.
	Сама же база данных у нас "--- ровно те файлики, в которых в каком-то формате хранят данные.
	Но теперь к вам приходят и предлагают создать аналогичную базу данных для продажи авиабилетов.
	Но наша СУБД завязана внутри на мебель!
	В каждом файлике же хранятся, без пометок, только значения:
	\begin{center}\begin{tabular}{|cc|}
		\hline
		1 & 20 \\
		2 & 130 \\
		3 & 200 \\
		5 & 32  \\
		\ldots & \ldots \\
		\hline
	\end{tabular}\end{center}

\item[Настоящая СУБД:]
	Когда вы обобщите сервис от конкретной структуры данных, а сами базы данных внутри также будут описывать, что они хранят,
	вы получите настоящую, мощную базу данных.
\end{description}

\begin{Def}
	База данных "---
	струтурированное,
	персистентное (сохраняющее данные между запусками),
	самодокументированное (описывающее свою структуру),
	интегрированное (позволяющее связывать состояния многих блоков данных)
	хранилище данных.

	Строгого общего определения нет, у всех что-то подобное этому.
\end{Def}
Как видно, наш текстовый файлик очень слабо подходит под это, нужно на него достаточно всего наворачивать.

Какие же функции у нашей СУБД?
\begin{enumerate}
	\item Физически хранит данные.
	\item Язык запросов.
	\item Контроль доступа.
	\item Конкурентный доступ.
	\item Предоставление гарантий на случай сбоя.
	\item Поддержка целостности и согласованности данных.
\end{enumerate}

Современные бызы данных появились в 1970-х годах, благодаря идеям IBM.
К 1990 уже трудно представить предприятие без БД от Microsoft, Sybase, Sun или кто ещё тогда был.

\begin{samepage}
	Сейчас, из самых популярных проприеритарных:
	\begin{itemize}
		\item Oracle
		\item IBM DB2
		\item Microsoft SQL Server
	\end{itemize}
	а из открытых
	\begin{itemize}
		\item MySQL / MariaDB
		\item PostgreSQL
	\end{itemize}
\end{samepage}

\section{Архитектура информационных систем}

\subsection{Встроенные БД}
Работает прямо в приложении; как правильно, один пользователь; нет конкурентного доступа и контроля доступа (зачем?).

\subsection{Классическая клиент-серверная архитектура}
Стала крайне распространена в 1990-х, довольно широко используется и сейчас.
Есть отдельный процесс СУБД (чаще всего, даже на отдельном хосте); есть набор клиентских приложений с интерфейсом и бизнес-логикой,
обращающихся к СУБД для получения и сохранения данных.

Проблема "--- если надо обновить бизнес-логику, надо обновить код \textit{на всех клиентах}, тысячах их. Одновременно. Удачи!

\subsection{Многоуровневая архитектура}
В современности делают так "--- клиентское приложение общается с сервером приложений, находаящаяся рядом с базой данных.
Сервер получает запросы (например, по HTTP), преобразует их по акутальной бизнес-логике в настоящие запросы к БД
(если вообще не откидывает, не кеширует, чёрт его знает). В клиентской части остаётся только интерфейс.
