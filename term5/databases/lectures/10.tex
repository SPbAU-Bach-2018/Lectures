Хотим хеш-таблицу для индекса.
Все помнят, что такое хеш-таблица?

Например, мы хешируем значение, которое хотим сохранить, смотрим в соотвествующую ячейку и смотрим список значений в ней.
При хорошей хеш-фукнции (т.е. наиболее близкой к случайной) и правильном размере хеш-таблицы доступ будет за амортизированную O(1).
Когда элементов становится многовато (то есть какой-то список стал великоват), надо перестроить хеш-таблицу на размере побольше (в 2 раза).

На диске это живёт так: есть блок(и) с указателями на списки, сами списки хранятся на блоках, и больше, чем один блок, мы их не позволяем.
Когда размер кончится, рехеширование будет долго жужжать диском.

Применим Extensible Hashing.
Пусть размер хеш-таблицы всегда будет только степень двойки $2^k$.
Каждой корзине сопоставим $b_i$ "--- \textit{количество значищих бит} для этой корзины. Что это такое "--- чуть дальше.
Возьмём и нестандартную хешфукнцию "--- которая берёт первые $k$ бит от хеша.

Поиск: взяли хеш, смотрим, куда, радуемся.
Изменение размера: пусть какая-то корзина стала большая.
Увеличили размер хеш-таблицы в два раза.
Большую корзину расщепляем на две: так как из хеша мы теперь берём на бит больше, значения расползутся, увеличиваем у них число значищих бит $b_i$ на 1.
Для всех старых блоков мы записываем указатель на них дважды, для каждого префикса, но у них количество значищих бит осталось прежним.

Теперь, если какой-то ещё блок станет слишком большим, то мы увидим, что у него $b_i \ne k$, и это означает, что не надо переделывать саму хештаблицу, надо просто разбить блок на два и переставить указатели.

По-сути, мы теперь каждый блок разрезаем лениво, помня про него, насколько много бит хеша он использует.

У хеш-таблички есть проблемка: искать значение оно умеет, а вот
\begin{sqlcode}
SELECT * FROM T WHERE id < 1000;
\end{sqlcode}
"--- до свидания.
Зато \sql'JOIN' очень весело идёт.
Взяли каждую строчку, нашли в хеш-табличке парные, радуемся.
\[ B(R) + T(R) \cdot ? \]
Сколько же записей сопосатвится каждой?
Если индекс по $S.b$ кластеризующий, то надо прочитать
\[ ? = B(S) / V(S, b) \]
$V$ "--- как там много значений такого аттрибута.
Если некластеризующий, то куда больше, совсем грустно.
\[ ? = T(S) / V(S, b) \]

В целом, алгоритм выглядит так себе эффективным, если объединять всё со всем, но если на какую-то таблицу есть сильные ограничения или сделана фильтрация, то всё будет куда лучше.

Ещё есть Zig-Zag Join, который не читает строчки таблицы, которые нужны, например, если из объединения есть только индекс.

