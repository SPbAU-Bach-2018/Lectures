Какие вообще записи можно разместить в журнале?

\subsection{Undo-logging}
Надо точно записывать начала и завершения (успешные и неуспешные) транзакций.
Ещё будем записывать, что в такой-то транзакции такой-то элемент хотят записать, вместе со старым значением.
Зачем? Это делает эту запись Undo, то есть отменяемой.

Если мы будем следовать правилам:
\begin{itemize}
\item
	Перед записью данных пишем в журнал, что хотим записать.
\item
	Пишем подтверждение транзакции после успешного завершения записи всех данных.
\end{itemize}
то сможем легко восстановить данные при сбое:
\begin{itemize}
\item
	Найти в журнале все неподтверждённые транзакции.
\item
	С конца отменять их действия.
\end{itemize}

Работает хорошо!
Проблемы: надо читать весь журнал, \sql'COMMIT' ждёт запись на диск.

Как не ждать весь журнал?
Checkpoint "--- контрольная точка в журнале.
Записываем в журнал, что началась контрольная точка, ждём окончания всех транзакций, только потом закрываем точку и продолжаем.
Или, точнее, выкидываем весь журнал "--- всё на диске. Это крайне наивный подход "--- не хочется, чтобы транзакции ждали конца других, долго.

Лучше так: при начале контрольной точки выписываем все текущие транзакции. Новые мы принимаем, но как только все старые завершились "--- завершаем контрольную точку. При чтении журнала с конца читать дальше завершённой контрольной точки не надо.

\subsection{Redo-logging}
Пишем начала транзакции, концы транзакции, и те же записи о записях на диск.
Но правила другие: мы ничего не пишем на диск, пока не подтвердится транзакция.
Тогда все неподтверждённые транзакции ещё ничего не записали, а подтверждённые, если чего-то не записали, то имеют запись о успехе.
Для восстановления надо найти все подтверждённые транзакции и читая журнал с начала записывать все их операции.

Проблема: очень уж много изменений в памяти может накопиться.
Тут тоже можно сделать контрольные точки: в ходе неё подтверждённые транзакции берём и таки записываем.
Можно воспользоваться битом изменения страниц памяти: берём и пишем все грязные страницы подтверждённых транзакций.
Итого: надо восстанавливать только с момента начала последней контрольной точки.

Этот журнал хорош для реплицирования: можно другой реплике посылать журнал и он сам восстановится.

\subsection{Undo-redo-logging}
Пишем всё так же, правило одно: WAL (пишем в журнал до записи на диск).
Восстановление: найти подтвердившиеся, откатить неподтвердившиеся, применить подтвердившиеся.

\section{Timestamp-based scheduler}
MVCC "--- Multi-Version Concurring Control.

Каждая транзакция получает время старта.
Каждая операция проверяется: может ли в момент начала транзакции быть применена эта операция.
Для этого хранятся моменты времени, когда каждый элемент последний раз был прочитан и записан; а ещё флаг подтверждения для каждых данных.

Например, две транзакции: первая началась, вторая началась, первая записала X, вторая прочитала его же.
Тогда вторая увидит в момент чтения, что в момент начала своей транзакции она хочет прочитать значение, изменённое транзакцией, начавшейся до него, и всё, что она сделает "--- подождёт, пока та подтвердит запись в элемент.

Если же порядок будет другой, и транзакция пытается прочитать значение, записанное транзакцией, начавшейся после её начала, её откатывают.

Запись "--- если последняя операция с элементом была транзакцией, начавшейся до нас, тупо пишем.
Если читал кто-то новее "--- дохнем.
Если писал кто-то новее "--- если подтвердил, то забиваем на нашу запись, иначе "--- ждём подтверждения, проверяем.

Проблема "--- может откатывать даже чтения.

\chapter{Список литературы}

Крис Дейт. ,,Введение в системы баз данных``.
Там неплохо про первую часть курса.

Jeffrey Ullman, et at. Database system implementation.
Есть рефакторинг: ,,Базы данных: полный курс``.

Борис Новиков. ,,Настройка производительности баз данных``.
