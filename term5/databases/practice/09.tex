\setauthor{Егор Суворов}
\chapter{03.11.2016}

	Следующая итерация соединяет несколько тем:
	\begin{itemize}
		\item
			Общение с БД из какого-нибудь языка общего назначения (мы возьмём Python).
			Всё, что применимо к Python, применимо и к другим языкам без существенных изменений.
		\item
			Почему СУБД тормозят и кто в этом виноват (СУБД, программист, звёзды?).
	\end{itemize}

\section{Приложение на Python}
	Работать будем с нашей знакомой БД космических полётов.
	Приложение на Python (\t{app1.py}) будет позволять работать с рейсами в браузере.
	Будем изучать не только, как писать, но и как его потом поддерживать.

\subsection{Основные нужные компоненты}
	Как правило, для каждой СУБД выпускаются так называемые \textit{драйвера}
	(либо разработчиками самой СУБД, либо сторонними разработчиками).
	Задача драйвера "--- формирование сообщений для сетевого общения с СУБД.
	Для того, чтобы в принципе соединиться по сети, нужно знать несколько вещей про сервер:
	\begin{itemize}
		\item IP-адрес или имя хостаГ, где располагается СУБД.
		\item Порт, где СУБД ожидает подключения.
		\item Имя пользователя для подключения к СУБД.
		\item Пароль (если требуется).
		\item Имя базы данных на сервере.
	\end{itemize}
	В первых строках \t{app1.py} мы как раз видим создание некоторой штуки под названием
	\t{SimpleConnectionPool}, которой передаются эти параметры.

	Обычно в стандартных библиотеках языков (Python, Java) имеется стандартный
	интерфейс для всех драйверов (JDBC в Java, DB API в Python, ODBC в продуктах Microsoft, и прочие).
	Как правило, драйверы более-менее полно реализуют эти интерфейсы.
	Во все интерфейсы обычно входят две сущности:
	\begin{itemize}
		\item \textit{Соединение} с базой данных.
		\item \textit{Курсор} "--- выполняет запрос и позволяет итерироваться по полученному результату.
	\end{itemize}
	Установка соединения с СУБД "--- дорогая операция (может занять несколько сотен миллисекунд),
	поэтому в приложениях обычно держат так называемые \textit{пулы соединений}.
	Если кому-то нужно сделать запрос к СУБД "--- берётся соединение из пула,
	выполняется запрос, после чего соединение возвращается обратно в пул.
	Позволяет не устанавливать соединение на каждый запрос.

\subsection{Структура app1.py}
	В последних строках (в классе \t{MarsoflotApp}) находится описание веб-морды нашего приложения.
	Перед ним в отдельных функциях находятся какие-то функции, которые выполняют запросы.
	Первым параметром они принимают курсор с названием \t{db}.

	Метод \t{db.execute()} выполняет SQL-запрос, метод \t{db.fetchall()} возвращает все строчки запроса.
	Иногда бывает выгоднее получать строчки по одной (\t{db.fetchone()}) и сохранить СУБД от выполнения работы.

	В Python довольно спартанский API; к аттрибуту в конкретном кортеже можно обратиться только по номеру.
	Это довольно неудобно: например, если поменять местами аттрибуты в \t{SELECT}, то они
	поменяются местами и в результате, и из-за отсутствия типизации мы про это сразу не узнаем.
	Вообще говоря, курсор может нам рассказать, какой номер в кортеже имеет столбец с нужным именем,
	но это лишний код.
	В Java можно получать значение сразу по названию столбца.

	Страница, которая позволяет добавить полёт, располагается по адресу \t{localhost:8080/add\_flight}.
	На ней выбрать параметры полёта, нажать кнопку, получим пустую страницу, если не произошло никаких ошибок.
	Если потом вернёмся на основную страницу, то увидим новый полёт.
	Описание страницы расположено в методе \t{add\_flight}, который делает запросы к справочникам,
	а само добавление (страница после нажатия на кнопку) расположено в методе \t{do\_add\_flight}.

\subsection{Первые проблемы}
	Пусть мы выпустили приложение в продакшн и им радостно пользуются.
	Тут марсофлот закупил новый корабль, где одним капитаном не обойтись, и нужно добавлять ещё экипаж.
	Наша схема на это не рассчитана.
	Давайте подправим:
	\begin{itemize}
		\item
			Добавим таблицу \t{Crew}, в которой будет хранится про экипаж
			полёта: номер полёта, ссылка на человека (в таблицу \t{Commander})
			и булевский флаг <<верно ли, что это капитан>>.
		\item Таблицу \t{Commander} переименовывать не будем, потому что лень (но проблемы не от этого).
		\item
			А из таблицы \t{Flight} удалим ссылку на капитана (для нормализации) "--- теперь у
			нас целый экипаж, который хранится в \t{Crew}.
	\end{itemize}
	Появилась первая проблема: у нас теперь запросы стали некорректными, потому что аттрибута \t{Flight.commander\_id} больше нет.
	Приложение упало.
	Мы опытные программисты, так что это было ожидаемо.
	Поменяем код: добавим в запросы \t{JOIN} и \t{WHERE}, чтобы найти капитана.

	Вторая проблема: при попытке добавить полёт мы снова огребаем.
	Значит, надо поменять и запросы с \t{INSERT}: добавим второй \t{INSERT}.

	Наблюдение: у нас чуть-чуть поменялась схема, а нам пришлось менять вообще все запросы.
	Хорошо, что у нас было всего сто строчек кода.
	Хотелось бы, чтобы эти изменения были всё-таки изолированы в одной части кода.
	Можно было бы добавить представление (VIEW), которое <<эмулирует>> старую таблицу,
	но в него нельзя вставлять данные.

	В идеале бы хотелось, чтобы можно было писать на языке команды вроде \t{for f in Flight.get\_all()},
	которые инкапсулируют схему базы данных.
	Это стандартный подход: такого рода классы можно либо писать самостоятельно, либо
	есть специальные генерилки кода, называются ORM (object-relational mapping).
	Например, для Python есть PonyORM (и ещё куча всяких), для Java "--- Hibernate ORM.
	Однако сейчас мы будем эти классы писать руками.

\subsection{Своя ORM}
	Смотрим на вторую версию приложения (\t{app2.py} и соседствующие файлы).
	В \t{templates.py} лежит код, который генерирует HTML-код по кортежам из запроса,
	в \t{app2.py} остался код для запросов к БД, а в \t{model.py} есть описания тех
	самых классов, которые инкапсулируют схему БД.
	Они довольно похожи.
	Например, есть класс \t{Flight}, в котором есть методы \t{create\_flight}, \t{get\_all\_flights} и прочие.

	Можно запустить приложение, оно работает.
	А вот если добавить не 500 рейсов, а $10\,000$, то приложение начинает очень тормозить при загрузке страницы.
	Ага, наверняка СУБД тормозит?!
	Кажется, что да: если открыть менеджер процессов, то во время загрузки postgres будет грузить процессор на 80\%.

	Однако же если выполнить запрос напрямую в консоли БД (а не из веб-приложения), то это произойдёт мгновенно.
	Странно.
	А проблема в следующем: в функции \t{get\_flights} мы делаем один большой запрос к БД,
	а дальше десять тысяч раз вызывает методы \t{get\_commander}, \t{get\_spacecraft} и остальные.
	Каждый метод делает запрос к Postgres.
	Итого примерно $30\,000$ запросов, что довольно до фига.
	К сожалению, это популярная проблема: код корректен, но делает слишком много запросов к БД.
	Даже опытные программисты иногда этим страдают, например, если код несколько раз переделывался.
	Или если ORM недостаточно умный и сам сгенерировал такой код где-то внутри.

	Можно возразить: мы в запросе сохраняли только дату полёта, а могли бы ещё и сохранять номера командира.
	Это бы не помогло: имя командира всё равно осталось бы в БД, а не в приложении.
	Решение <<вытягивать вместе с каждым полётом имя командира>> неочевидно: не всегда ясно, что это правильное решение.
	Не всегдя ясно, где надо в этих связях остановится.
	Например, если нам от полёта нужно получить только дату, то делать дополнительный \t{JOIN} расточительно.

	Поэтому нам хочется некоторого баланса: чтобы не вытягивать всю базу на каждый чих, и чтобы
	программист мог писать привычный ООП-код, не думая о том, что обращение к полю "--- это обращение к БД.
	Это сложная задача, предлагается подумать дома, как к этому можно приблизиться.

\subsection{Оптимизация запросы}
	Пусть мы захотели для каждого полёта также вывести количество пассажиров.
	Можно просто добавить столбец в функцию \t{get\_flights} в \t{model.py}:
\begin{minted}{sql}
(SELECT COUNT(*) FROM Booking WHERE flight_id=F.id) AS booking\_count
\end{minted}
	Добавили, обновили страницу, она стала существенно медленнее.
	Кажется, теперь-то точно СУБД тормозит?
	Оказывается, да: если скопировать его в консоль, то он действительно долго выполняется.
	Может возникнуть подозрение, что подзапрос отдельно выполняется на каждую строчку и \t{JOIN}'ом с запросом с \t{GROUP BY} будет быстрее:
\begin{minted}{sql}
... старый запрос ...
LEFT JOIN (
  SELECT flight_id, COUNT(*) AS booking_cnt
  From Booking
  GROUP BY flight_id
) AS T2
ON T1.flight_id = T2.flight_id
\end{minted}
	Подозрение оправдывается: стало работать быстрее.
	То есть СУБД действительно тормозила из-за того, что был запрос составлен как-то не так.

	Хочется научиться самостоятельно понимать, насколько хорошо выполняется запрос.
	В Postgres есть замечательная команда \t{EXPLAIN}, которая показывает, как именно будет выполняться запрос:
\begin{minted}{sql}
explain select * from flight;
\end{minted}
	Он выведет дерево запросов и сложных операций, а в скобках "--- какие-то оценки postgres на разные темы
	(\t{cost} "--- примерное время выполнения в попугаях; \t{rows} "--- количество строк; \t{width} "--- примерный суммарный размер аттрибутов в попугаях).
	А если написать \t{EXPLAIN ANALYZE}, то он ещё и выполнит запрос и покажт, как разошлись оценки с реальностью.

	Если подсунуть команде \t{EXPLAIN} какой-нибудь запрос посложнее, мы увидим кучу всякой информации
	в виде дерева выполнения запроса.
	Например, можно увидеть \t{Seq Scan} (сканируем всю таблицу), известные нам \t{hash join}.
	Таким образом можно самостоятельно анализировать, какая часть запроса тормозит,
	время, потраченное на планирование запроса (planning time) и на выполнение (execution time).

	Если запустить первую попытку (с \t{SELECT COUNT(*)}) в \t{EXPLAIN ANALYZE}, то
	мы в конце увидим замечательную строчку \t{Aggregate (... loops=10000 ...)}, в детях которой
	будет \t{Seq Scan (... loops=10000 ...)}.
	Получили, что наша БД выполняла запрос за квадратичное время.

	Наша задача, как программиста "--- избавляться от многократного сканирования таблиц.
	Иногда Postgres догадывается, как соптимизировать, а иногда нет.
	В частности, почти никакая СУБД (кроме Oracle) не умеет нормально работать с подзапросами,
	которые зависят от значений окружающего запроса (как мы написали на первой попытке).
	Oracle умеет кое-как.
	Если выполнить \t{EXPLAIN ANALYZE} на оптимизированном запросе, то мы никакой фигни не увидим и
	запрос выполняется быстро.

	Другой пример: возьмём все полёты, выполненные капитаном с id=1 (вместе с именем капитана):
\begin{minted}{sql}
SELECT * FROM Flight JOIN Commander on Flight.commander_id = Commander.id WHERE commander_id=1
\end{minted}
	Посмотрим на \t{EXPLAIN ANALYZE}.
	Выглядит хорошо.
	Попробуем ещё подсказать (сначала найди капитана, а потом полёты):
\begin{minted}{sql}
SELECT * FROM Flight JOIN (SELECT * FROM Commander WHERE id=1) ON Flight.commander_id = Commander.id
\end{minted}
	Окажется, что план выполнения абсолютно такой же.

	Мораль: СУБД, тем не менее, довольно умная, и такого сорта вещи (сначала выбери одно, потом другое)
	умеет оптимизировать самостоятельно.
	Поэтому сначала пишем запросы для читаемости, а не для мифической оптимизации или подсказки базе данных.
