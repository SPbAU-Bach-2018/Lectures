\setauthor{Никонов Михаил}

\chapter{Выпуклые многоугольники, динамическая выпуклая оболочка}

\section{Простые задачки на выпуклые многоугольники}

\subsection{Точка внутри многоугольника?}

\begin{enumerate}
    \item Выберем самую левую точку многоугольника. Проведем из нее лучи во все остальные точки. 
    Таким образом аля триангулировали многоугольник. Теперь проведем луч в точку запроса. Хотим понять, в каком треугольники она потенциально может лежать. Бин-поиск по углу. 
    \item Нашли треугольник. Теперь за $O(1)$ проверяем, внутри ли она (какое-нибудь в.п.)
\end{enumerate}

\subsection{Крайняя точка по направлению}
Задача: Дан выпуклый многоугольник и направление. Грубо говоря нужно найти такую точку в многоугольнике, что по заданному направлению, остальные будут ''за ней''. 

Итак, есть в.м., зафиксируем его обход (например против часовой стрелки). Направление задается нормалью. Рассмотрим прямую, перпендикулярную нормали 
(пусть у нее угол $\Beta$), и $\alpha[i]$ - углы, соответствующие ребрам, выходящим из ввершин. Если вершины многоугольника пронумерованы таким образом, что 
угол у нулевой вершины минимален, то нужная вершина - это $lower\_bound(\alpha[], \Beta)$.


\subsection{Касательная к многоугольнику из точки}
Строим касательные из точки A. Зафиксируем ориентацию и точку многоугольника (a). Поймем, эта точка лежит на ближней к нам стороне, или на дальней (в.п.).
Пусть на дальней. Таким образом вершины разбились на те, что справа (если смотреть на a) и на те, что слева. 

Найдем правую касательную (соответствующую ей точку B). Сделаем бин-поиск по ''правым'' вершинам. Пусть текущаяя вершина x. Тогда до B знак в.п. луча (A, x) 
и ребра исходящего из x будет одним, а после B - другим.

Проверять, что мы попали в левую долю можно векторным произведением относительно (A, a)

\begin{cppcode}
    L = 0, R = n;
    while (R - L > 1) {
        M = (L + R) / 2;
        if ((p[M] - A)x(P[0] - A) < 0       // Проверка того, что мы в правой части
            && (P[M] - A)x(P[M + 1] - P[M]) > 0)    // Где мы относительно B
            L = M;
        } else {
            R = M;
        }
\end{cppcode}


\subsection{Пересечение многоугольника и прямой}
Возьмем далеко на прямой $v$ точку $A$. Посмотрим на вершину многоугольника $x$ и знак в.п. прямой с $(A, x)$. Кайф. Все вершины разбились на те, что с одной стороны и те, что с другой.
Фактически имеем что-то вроде $[1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1]$. Нам надо найти границы. Просто бин-поиск сделать не можем, т.к. не факт, что первая и последняя вершины 
многоугольника имеют разный знак. Проведем касательные из $A$ и по ним ''разрежем'' массив $[1, 1, 1, 1, 1, 0, 0, 0, 0]$ и $[0, 0, 0, 1, 1, 1, 1]$. Теперь можем сделать бин-поиск.


\section{Общие касательные к двум в.м.}

\textit{Многоугольники не пересекаются и не лежат друг в друге}

\subsection{Ближайшая к точке вершина многоугольника}
Есть в.м. и точка $A$. Найдем ближайшую к ней вершину. Для этого из A проведем касательные к многоугольнику, тем самым разобьем его на две части: ближнюю и дальнюю. 
Рассмотрим ближнюю. На ней расстояние от $A$ до точек многоугольника выпукло, значит можно сделать тернарный поиск. На паре формально доказывалось, почему это так. Рассуждения велись от: 
''Пойду в одну сторону, расстояние уменьшится, т.к. угол тупой; пойду в другую - угол острый, расстояние увеличится''.  

\subsection{Ближайшие точки для двух многоугольников}
За $O(\log^2{n})$. 
\begin{enumerate}
    \item Возьмем $x_0$ из первого многоугольника и найдем для него ближайший $y_0$ из второго. 
    \item Проведем касательные из $y_0$ и рассмотрим ближнюю половинку первого многоугольника.
    \item С этой половинки запустим тернарник, минимизирующий расстояние до второго многоугольника. Успех.
\end{enumerate}


\subsection{Общие касательные}
\begin{enumerate}
    \item Найдем $x_{ans}$ и $y_{ans}$ предыдущим алгоритмом.
    \item Проведем через них прямую, по которой ''разрежем'' многоугольники. 
    \item Построим отдельно касательные для верхних и нижних половинок за $O(\log^2{n})$. 
\end{enumerate}
Научимся строить общую касательную для верхней половинки. Касательная будет задаваться парой точек $(A, B)$ - из первого и второго многоугольника. 
Таким образом мы можем легко проверить, является ли прямая касательной: ребра смежные с $A$ и смежные с $B$ должны находиться по одну сторону от $(A, B)$. 

Сделаем бинарный поиск по вершинам из первого многоугольника (вернее его верхней половинки). Из очередной вершины строим касательную и смотрим:
\begin{enumerate}
    \item Если полученная прямая действительно является касательной, то нашли.
    \item Если это дальняя до $B$ вершина, то двигаем правую границу (можем проверить, если зададим ориентацию многоугольника).
    \item Иначе левую. 
\end{enumerate}

Полезно знать, что существует алгоритм, находящий их за $O(\log{n})$


\section{Динамическая выпуклая оболочка}
Хотим за $Poly(\log)$ уметь:
\begin{itemize}
    \item Add(x, y)
    \item Del(x, y)
    \item Количество вершин в в.о. (например)
\end{itemize}

У нас будет два дерева отрезков: для верхней части в.о. и для нижней. Деревья отрезков по $X$. Считаем, что все $X$ различны.

Будем говорить о верхней части. В вершинах д.о. хранятся декартовы деревья для выпуклых оболочек (в данном случае для их верхних частей). 
Чтоб получить значение в корне, нужно найти верхнюю общую касательную для сыновей, посплитить по вершинам этой касательной и добавить 
в корень их объединение (merge). 

Чтоб избежать персистентности, в детях будем оставлять грызки - то, что осталось после подсчета значения для корня. Теперь, при спуске в детей,
нужно родителя посплитить по соответствующей координате и, таким образом, их починить.

Оценим время работы очередного запроса:
$O\left(\log{C}\left(\log{n} + \text{общ. касательная} \right)\right)$

Если не думать, то общую касательную мы находим за $O(\log^3{n})$. Если понять, что бин-поиск - это спуск по дереву, то за $O(\log^2{n})$. 
Держим в уме, что существует алгоритм, делающий это за $O(\log{n})$.

Оценка на память: $O(n\log{C})$.
