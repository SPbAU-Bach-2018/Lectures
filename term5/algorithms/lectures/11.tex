\setauthor{Лабутин Игорь}


\section{Random walk}
Найдем паросочетание в $d$-регулярном двудольном графе рандомизированно за $O(n \log n)$

По лемме Холла совершенное паросочетание существует.

Будем искать дополняющий путь случайным блужданием, то есть из свободных вершин идем по случайному ребру.

Пусть текущий размер паросочетания $k$, тогда будем запускать Random walk на глубину $\frac{3n}{n-k}$, пока он не найдет дополняющий путь.

Вероятность того, что один такой Random walk найдет путь больше некоторого $\varepsilon>0$ (без доказательства). Значит матожидание числа запусков для одного $k$ равно $\frac{n}{\varepsilon}$

Время работы это $\sum\limits_{k=0}^{n-1}\frac{3n}{n-k}$, т.е. $O(n \log n)$

\chapter{Полуплоскости}

\section{Нахождение пересечения полуплоскостей}
Хотим найти пересечение полуплоскостей за $O(n \log n)$

Найдем отдельно пересечение всех полуплоскостей вида $y \le k_i x + b_i$ (нижние полуплоскости) и отдельно всех полуплоскостей вида $y \ge k_i x + b_i$, а затем получим из них общее пересечение.

Научимся искать пересечение полуплоскостей вида $y \le k_i x + b_i$

Отсортируем полуплоскости по $k_i$, это то же самое что сортировка по углу. Затем сделаем проход в отсортированном порядке со стеком.

Будем поддерживать стек прямых и координат точек пересечения двух соседних прямых в пересечении первых $i$ полуплоскостей. Чтобы было меньше случаев, положим в начало стека вертикальную прямую далеко слева. При добавлении следующей полуплоскости достаем со стека полуплоскости, пока их точки пересечения лежат в новой полуплоскости

\begin{cppcode}
$while (y.top() > k_i \cdot x.top() + b_i) {
	x.pop();
	y.pop();
	lines.pop();
}
x.push(intersectionX);
y.push(intersectionY);
lines.push(newLine);$
\end{cppcode}

\begin{lemma}
$x_i, y_i \in Z \cap [-C;C] \Rightarrow$ чтобы не было проблем с точностью, в худшем случае нужен тип хранящий числа порядка $C^3$. Без доказательства.
\end{lemma}

Этот алгоритм похож на построение верхней части выпуклой обоочки.

\subsection{Биекция с задачей нахождения выпуклой оболочки}
Чтобы построить верхнюю часть выпуклой оболочки, мы сортируем все точки по координатам, затем делаем проход со стеком, доставая точки, пока угол с предыдущим отрезком больше $2\pi$.

\begin{theorem}

Существует биекция между задачами нахождения пересечения полуплоскостей вида $y \ge k_i x + b_i$ и нахождения верхней части выпуклой оболочки.
\end{theorem}

Построим сначала биекцию между прямой $y = k x + b_i$ и точкой $(x,y)$:
$$(x, y) \rightarrow (k=x, b=-y)$$
$$(k, b) \rightarrow (x=k, y=-b)$$

\begin{lemma}
Биекция сохраняет отношение "ниже"
\end{lemma}
\begin{proof}
Точка $(p_x,p_y)$ лежала под прямой $y=kx+b$, значит после преобразования, прямая $y=p_x x-p_y$ лежит под точкой $(k,-b)$, т.к. $p_y < k p_x+b$
\end{proof}

\begin{lemma}
Прямая с точкой лежащей на ней переходит в точку лежащую на прямой.
\end{lemma}

\begin{lemma}
Точка пересечения двух прямых переходит в прямую проходящую через точки, в которые перешли прямые.
\end{lemma}

\begin{lemma}
Верхняя часть выпуклой оболочки переходит в пересечение полуплоскостей вида $y \ge k_i x + b_i$
\end{lemma}
\begin{proof}
Следует из предыдущих лемм.

Прямая из пересечения полуплоскостей переходит в точку выпуклой оболочки и наоборот. А прямая между соседними точками выпуклой оболочки переходит в точку пересечения соседних прямых из пересечения полуплоскостей.

Точка внутри выпуклой оболочки ниже всех прямых между соседними точками, значит она перейдет в прямую, которая будет выше всех точек пересечения соседних прямых и эта прямая не будет принадлежать границе пересечения полуплоскостей.
\end{proof}

Следствие.

Умеем пересекать полуплоскости за то же время, что и строить выпуклую оболочку. Например для выпуклой оболочки есть алгоритм "заворачивания подарка", работающий за $O(nk)$, где $k$ это число точек на выпуклой оболочке.

\subsection{Общий случай пересечения полуплоскостей}
Мы научились отдельно искать пересечение верхних полуплоскостей и нижних полуплоскостей, теперь получим общее пересечение.

Чтобы не было вертикальных прямых, повернем все на случайный угол, точнее применим любое невырожденное афинное преобразование ($a,b,c,d \ne 0$):
$$x \rightarrow ax+by$$
$$y \rightarrow cx+dy$$

Идем двумя указателями слева направо по полуплоскостям верхней и нижней части. 
Пересекаем отрезки.

Можно таким же методом найти все точки пересечения двух монотонных слева направо ломаных за время $O(n + Answer), Answer < 2n$
