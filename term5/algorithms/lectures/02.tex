\date{September 15, 2016}
\author{Chernikova Olga}

\chapter{Суффиксный автомат}
\section{Определение, связь с суффиксным деревом, единственность, конечные вершины}
\begin{description}
    \item[Суффиксное дерево:]
    Построем \textbf{несжатое} суффиксное дерево для строки \textbf{ababc}:
    
    %{\color{RED} TODO рисунок суффдерева, которое превращается в автомат.}

    У дерева есть вершины, в которых заканчиваются суффиксы, то есть
    терменальные вершины и есть корень, то есть стартовая вершина. 

    \begin{Rem}
    Суффиксное дерево является детерменированным конечным автоматом(ДКА), 
    который принимает суффиксы строки и только их. 
    \end{Rem}

    \item[Определение суфавтомата:]
    \begin{Def}
    \textbf{Суффиксный автомат} "--- минимальный по числу вершин ДКА, 
    который принимает все суффиксы данной строки и только их.
    \end{Def}

    \item[Из дерева в автомат:]
    Отличие дерева от автомата, что в дереве очень много лишних вершин. 
    Например, следующие 4 вершины абсолютно одинаковые, их можно склеить:
   
    %{\color{RED} TODO рисунок суффдерева, которое превращается в автомат.}

    Есть еще пара вершин, которые совсем одинаковые, из ни выходит по одному ребру 
    с символом $c$ и оно ведет в терминальную вершину. Тоже сожмем:
    
    %{\color{RED} TODO рисунок суффдерева, которое превращается в автомат.}
    
    Ну и еще две вершины тоже равны, тоже можно склеить:

    %{\color{RED} TODO рисунок суффдерева, которое превращается в автомат.}

    Проверяем, что в получином автоматие есть все суффиксы и нет ничего лишнего. 
    Пока не понятно, почему этот автомат минимальный.  Это мы поймем чуть позже.
    \item[Еще один пример:]
    
    Теперь построим дерево для строчки \textbf{ababb}, что бы понять важность терминальных вершин:
    
    %{\color{RED} TODO рисунок суффдерева, которое превращается в автомат.}

    Это дерево принципиально отличается тем, что есть терминальная вершина, которая не в листе.

    Здесь попробуем так же склеить.
    
    %{\color{RED} TODO рисунок суффдерева, которое превращается в автомат.}

    Заметим, что мы \textbf{не} можем склеить терминальную и не терминальную вершину. Поэтому в этом 
    автомате вершинок получилось чуть больше, чем раньше. 
    
    \item[Правые контексты:]
    \begin{Def}
    Правый контекст $v$ относительно $S$ это следующее множество:\\
    $R_S(v) = \{w: vw $"--- суффикс $S\}$ \\
    То есть множество всех строк,  котрые нужно дописать к $v$, что бы  получить суффикс $S$.
    \end{Def}

    Теперь, что бы понять как писать автомат, хочется понять в каком случае две вершины являются одинаковыми. 
    Вершины одинаковые, если их правые контексты одинаковые. 

    С точки зрения дерева, это все пути из вершины, которые ведут до терминального состояния. То есть, 
    если есть две вершины $u, v$, такие что $R_S(v) = R_S(u)$, то эти две вершины надо слить.
    
    \item[Теорема об устройстве суффиксного автомата:]
    \begin{theorem}
    $V_А = \{u \colon R_S(u) = A\}$ "--- множество строк с правым контекстом $A$.\\
    Каждому непустому классу $V_A$ должна соответствовать ровно одна вершинка в автомате. 
    \end{theorem}

    Так же $V_A$ можно воспринимать как множество строк, которые закончатся в соответствующей вершине. 
    
    Вершину назовем $A$.

    \begin{proof}
    Доказывать данную теорему не будем, 
    в связи с существанием у нас курса по формальным языкам, где 
    данное утверждение уже было доказано. Это, кстати, не значит, что его
    не надо уметь доказывать, просто доказательство можно найти в другом конспекте. 
    \end{proof}

    \item[Ребра автомата:]
    Однозначно можно понять, как между вершинами проводить ребро. 
    $$\left.
    \begin{aligned}
    S &\in& V_A\\
    Sa &\in& V_B
    \end{aligned}
    \right\} \Ra A \overset{a}{\rightarrow} B$$
    
    Берем какую-то строчку, у которой правый контекст $A$, добавляем символ $a$, 
    смотрим какой правый контекст у новой строчки и туда проводим ребро.

    Тогда наша задача просто найти эти правые контексты, автомат будем строит по \textbf{индукции}:
    \begin{description}
    \item[База:]
     Есть одна вершинка last, $s$ - пустая.\\
     Вершина last - это вершина, которая соответствует всей строке. 
    \item[Переход:]
     Построили автомат для $s$, теперь перестроим для строки $sa$, где $s$ - строка, $a$ - символ.
    
     И что бы нам это сделать, нужно сначала понять, как будут меняться правые контексты. 
    \end{description}
    \item[Устройство классов $V_A$:]
    \begin{lemma}
    Был у нас праввый контекст $R_S(v)$, теперь хотим посчитать $R_{Sa}(v)$. 
    Правый контекст получается из правого дописыванием символа $a$ ко всем строчкам и, 
    возможно, добавлением $\varepsilon$

    $R_{Sa}(v) = \{za|z \in R_S(v)\} +? \{\varepsilon\}$
    \end{lemma}
    
    \begin{lemma}
    $R_S(v) = R_S(u) \Ra v$ и $u$  "---  либо $v$ суффикс $u$, либо $u$ суффикс $v$. 
    \end{lemma}

    \begin{Def}
    Обозначение: $v \le u \Lra v$ "--- суффикс $u$
    \end{Def}

    \begin{lemma}
    $v \le w \le u$ и $R_s(v) = R_s(u) \Ra R_s(w) = R_s(v)$.
    \end{lemma}
    
    \begin{Def}
    Обозначение: $v \subset S$ "--- v подстрока S. 
    \end{Def}

    \begin{proof}
    Если v подстрока S, то правый контекст v не пустое множество. Размер правого контекста равен количеству 
    вхождений строчки v в строчку S. 

    Теперь, если мы говорим, что два не пустых правых контекста равны, то там есть хотя бы одна строчка $z$.
    Возьмем строчку $v$, допишем $z$, получили $vz \le S$, но так же и $uz \le S$. Пусть $v$ короче $u$, тогда
    из этого следует, что $vz \le uz \Ra v \le u$. Что и требовалось.
    \end{proof}
    \begin{proof}
    Теперь доказательство второй леммы. Есть строчка $u$, есть $v$, между ними вклинилась строчка w. 

    Пусть есть строчка $z$, которую мы можем дописать к $u$ и получить суффикс строки $S$, но $w$ суффикс $u$, тогда $uz$  суффикс $S$.

    И в другую сторону, если мы что-то могли дописать к $w$, то тоже самое можно дописать и к $v$ и так же получить суффикс $S$.
    \end{proof}
    
    \begin{lemma}
    $V_A$ "--- отрезок суффиксов.
    %рисунок 
    \end{lemma}
    \begin{exmp}
    Есть строчка ababa:
    $R(aba) = R(ba) \ne R(a)$.
    $R(aba) = R(ba) = \{\varepsilon, ba\}$
    $R(a) = \{\varepsilon, ba, baba\}$.
    \end{exmp}

    То есть вершины автомата "--- это классы эквивалентности, каждому классу 
    эквивалентности соответствует отрезок суффиксов. 
    
    \item[Конечные вершины:]
    Давай-те понимать, где у автомата конечные вершины. У автомата точно есть 
    вершина, в которой заканчивается строчка S. Это вершина $V_{\{\varepsilon\}}$.

    Эта вершина конечная. Этот класс "--- это некоторые суффиксы. Суффикс S и какие-то поменьше.
    И есть какой-то еще суффикс $x$, который принадлежит другой вершине $V_A$. И как 
    нам находить эту вершину, мы будем поддерживать связь в виде суффиксной ссылки. 
    %рисунок 

    \begin{Def}
    $suf[V_{\{\varepsilon\}}] = V_A$ "--- суффиксная ссылка. 

    $suf[v]$ "--- это вершина, которая соответствует наибольшему из суффиксов строки вершины $v$, котрый 
    уже данному классу не принадлежит.
    \end{Def}

    Конечными вершинами тогда являются : $last, suf[last], suf[suf[last]], \cdots$.

    \begin{Def}
     Также будем поддерживать длину максимального суффикса, который заканчивается в этой вершине.\\
     $len[v] = max|s| \colon s \in V$
     %картинка 
    \end{Def}
    
    Длину минимальной, если нам вдруг понадобится можно считать так: $len[suf[v]] + 1$.
    \end{description}
\section{Онлайн алгроитм построения за $O(n)$}
    \begin{description}
    \item[В каких случаях разделяется вершина:]
    Вершина это какой-то правый контекст $R_{S}(v)$. Теперь дописали символ $a$ и 
    правый контекст изменился следующим образом $R_{Sa}(v) = \{za | z \in R_S(v)\} +? \varepsilon$
    
    От сюда видно, что если две строки заканчивались в разных вершинах, то если к строке дописать символ a, 
    то они все еще будут заканчиваться в разных вершинах.

    Если строки заканчивались в одной вершине, то что мы можем сказать, про то, заканчиваются ли они в
    одной вершине в новом автомате, то есть если $R_{S}(x) = R_{S}(y)$, равны ли $R_{Sa}(x)$ и $R_{Sa}(y)$.

    Они могут быть не равны только если в одном из них есть $\varepsilon$, в другом нет.
    
    Пусть $x \le y$ и $R_{Sa}(x) \ne R_{Sa}(y)$. Значит в классе $R_{Sa}(x)$  содержится $\varepsilon$, 
    а в $R_{Sa}(y)$ "--- нет.
    \item[На две поделится максимум одна вершина:]
    \begin{lemma}
    Существует не более 1 $R_s(v)$, которая поделится попалам.
    \end{lemma}
    \begin{proof}
    Почему на два? Потому что он мог преобразоваться только двумя способами: с эпсилоном и без, то 
    есть больше, чем на две части он точно не мог поделиться. 
    
    %рисунок.
    
    Рассмотрим x, такое что $|x|$ "--- max и содержит в правом контекте $\varepsilon$.\\
    Это значит x "--- самый длинный суффикс $Sa$. А более короткие суффиксы $Sa$ мы  можем получить 
    по суффиксной ссылке от этой вершины.

    $V_{R_S}(x) \Lra V[x]$.

    То есть вершины, которые еще могут подойти под эту конструкцию заканчиваются в $suf[v[x]], suf[suf[v[x]], \cdots$.
    
    \begin{lemma}
    $R_S(v)$ "--- поделится на две $\Lra\exists x \in R_S(v), y \in R_S(v)$\\
    x "--- суффикс $Sa$\\
    y "--- не суффикс $Sa$\\
    \end{lemma}
    
    \end{proof}
 
    \item[Про ребра:]
    Если две вершинки не поменялись, то и ребра между ними не поменялись.
    \\
    Почему? Если между вершинами было ребро, это значит, была какая-та страка x, которая заканчивалась в этой вершине. 
    И была какая-та строка xb, которая заканчивает в соседней вершине. Вершина "--- это множество строчек, 
    когда мы гворим, что вершина не поменялась, это значит, строка x все еще заканчивается в этой вершине. Вторая 
    вершина тоже не поменялась, значит xb все еще заканчивается во второй вершине. Значит должно быть ребро из x в xb.
    \\
    Нужно менять ребра только с новыми вершинами. А новых вершин будет
    максимум три. Старая поделилась на две и еще одна совсем новая.
    \\  
    \item[Алгоритм поиска max|x|]
    x "--- максимальный суффикс Sa и $x \subset S$.

    %рисунок
   
    Разделить нужно на несколько классов суффиксы Sa. Они удобны тем, что их легко переберать.
    Если x суффикс Sa, то он заканчивается на a. Значит есть в вершину x какое-то ребро по a из вершины,
    например, w.
                                                   
    В более верхних слоях не могло быть ребра по символу a, иначе бы мы получили бы более длинный суффикс 
    строки Sa.

    То есть нужно идти по суффиксным ссылкам, пока не встретим первое ребро по букве a.

    \item[Как проверить, что все строки в данной вершине являются суффиксами Sa:]
    То есть, нужно ли раздваивать вершину. Мы знаем, что |x| = |w| + 1.

    Пусть строчка w лежит в вершине p, а x в q. 

    w максимальная строчка в своем классе, то есть |w| + 1 = Len[p] + 1.
    А максимальный размер строки в классе q равен Len[q]. 

    Ну и остается проверить, совпадает ли он с длиной x.
    
    Если равны, то раздваивать вершину не надо, если не равны, то надо.


    \end{description}
\section{Написание алгоритма}
\begin{cppcode}
int last, suf[maxn], len[maxn], next[maxn][alf];

last = 1, 
suf[last] = 0, 
len[last] = 0;

void add(a) {
    p = last, last = new Vertex;
    Len[last] = len[p] + 1;
    while(p != 0 && Next[p][a] == 0) {
        next[p][a] = Last;
    }
    
    p = suf[p];
    
    if (p == 0) {
        suf[last] = 1;
    } else {
        q = next[p][a];
        if (len[q] = len[p] + 1) {
            suf[last] = q;
        } else {
            r = new Vertex
            suf[r] = suf[q];
            suf[q] = r;
            suf[last] = r;
            len[r] = len[p] + 1;
            next[r] = next[q]
            while (p != 0 && next[p][a] = q)  {
                next[p][a] = r;
                p = suf[p];
            }
        }
    }
}

\end{cppcode}
\section{Оценка размера автомата}
\begin{theorem}
В автомате $\le 2n$ вершин и $\le 3n - 2$ ребра. 
\end{theorem}

\begin{proof}
С вершинами все просто. когда пустая строка - две вершины, а дальше по индукции будет добавляться 
не более двух вершин. 

С ребрами чуть интереснее. Разобъем ребра на два класса. 
\begin{enumerate}
    \item Короткие ребра. Это такое ребро $A A \overset{a}{\rightarrow} B$, что $len[B] = len[A] + 1$

    Короткие ребра образуют дерево. Во-первых, поймем почему нет циклов. Пусть из A есть два пути по коротким ребрам 
    до B. Эти два пути одинаоковой длины, потому что мы просто через len можем их узнать. Но это 
    значит, что в B заканчиваются две строчки одинаковой длины, которые не равны. Противоречие.

    Еще надо понять, что это дерево, а не лес. Граф связен по построению. Добавляется новая вершина, 
    она привешивается за единичное ребро. Перевешиваем мы не единичные ребра. И когда вершину раздваиваем к новой 
    ведет еденичное ребро. Значит все дерево. 

    А в дереве на 2n вершинах 2n - 1 ребро. 
    \item Длинные ребра. Рассмотрим ребро длины хотя бы два. От двух ее концов можно 
    дойти до началькой и конечной вершины по единичным ребрам. То есть можем каждому ребру сопоставить 
    суффикс. Причем каждому ребру свой суффикс, так как каждый суффикс задается единственным путем. 

    Значит длиных ребер $\le n - 1$. 
\end{enumerate}
Значит всего ребер $\le 3n - 2$.
\end{proof}
\section{Оценка времени работы}
\begin{theorem}
Время построения автомата $O(n)$.
\end{theorem}
\begin{proof}
%рисунок

\begin{lemma}
$B \le A + 1$
\end{lemma}

\begin{proof}
   Доказываем по принцепу Дирихле. В нижней часте все B вершин 
   являются суффиксами строки $Sa$, значит в каждую должно вести ребро a. 
   При этом в каждую из своей вершины. Значит в верхней части их хотя 
   бы B - 1.
\end{proof}

$\Phi_{old} = A + k$ \\
$\Phi_{new} = B + 1 \le A + 2$\\
\\
$a_i = t_i + \Delta \Phi = O(1)$\\

\end{proof}


