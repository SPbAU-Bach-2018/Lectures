\date{September 22, 2016}
\author{Chernikova Olga}

\section{Простейшие свойства}
У нас был текст, построили от него суффиксный автомат. $text \to S.A(text)$.
\begin{description}
\item[Провекра, входит ли строка в текст]
    Есть строчка S, хотим проверить, входит ли S в текст за $O(|S|)$.

    Подстрока текста, это префикс какого-то ее суффикса. То есть, нужно просто 
    съесть строчку S автоматом, и если были все переходы по дорогие и в конце мы 
    оказались в какой-то, не обязательно терминальной, вершине, значит входит.

\item[Подсчет количества вхождений строки S]
    Обозничим v(S) "--- вершину, в которую мы попали, когда съели строчку S.

    Теперь хотим посчитать, размер правого контекста вершины v(S). То есть, 
    если мы прочитали строчку S, сколько способов дописать символы, что бы 
    получить суффикс text. 

    Для этого посчитаем динамику. Пусть $x_i$ все возможные вершины в которые 
    можно попасть за один шаг из вершины $v$. $f[v]$ "--- размер правого контекста вершины. 
    Тогда $f[v] = \sum_{x_i} + is_term[v]$.
\item[Самое левое вхождение строки S]
    При добавление вершины при построение суффиксного автомата,
    запомним в какой позиции мы добавили эту вершину. При расщипление
    вершины, позиция самого левого вхождения не меняется.

    \begin{cppcode}
    for (int i = 0; i < n; ++i) {
        add(text[i]);
        left[last] = i;
    }
    \end{cppcode}

    При расщипление \cpp"left[r] = left[q]"
\item[Самое правое вхождение]
    Это считается динамикой по автомату. Самое правое вхождение у
    последней вершины мы знаем. У остальных вершин надо взять максимум по соседям и вычесть 1. 
\end{description}

\section{Примеры задач}
\subsection{Наибольшая общая подстрока k строк}
    \begin{enumerate}
    \item Строим суффиксный автомат от минимальной из k строк. S.A(минимальная $S_i$)
    \item Съедаем последующие строчки атоматом, переходя по суффиксным ссылкам, если не 
    можем пройти по символу и в каждой вершине помним длину наибольшей общей строчки. 

    Так же храним, ограничение с предыдущих строк $Max[v]$ "--- максимальная длина 
    подстроки, которая являлвсь общей для предыдущих вершин. 
    \item 
    
    w[v] "--- максимальная общая подстрока текущей и нулевой строки которая заканчивается в вершине v. 

    Надо не забыть в конце пробросить по суффиксным ссылкам в обе стороны. 

    \begin{cppcode}
    max[v] = len[v]
    for (int g = 1; g < k; ++g) {
        v = root, x = 0, w = {0}
        for (int j = 0; j < s[g].size(); ++j) {
            while (go[v][s[g][j]] == -1) {
                v = suf[v];
                x = min(x, Max[v]);
            }
            v = go[v][s[g][j]];
            ++x;
            w[v] = max(w[v], x);
        }

        vector<int> vs[len]; //список вершин с данной длиной.
        for (int i = len[last]; i >= 0; --i) {
            for (v : vs[i]) {
                Max[v] = min(Max[v], w[v]);
                Max[suf[v]] = min(Max[suf[v]], Max[v]);
            }
        }
    }
    \end{cppcode}
    
    \item Время работы $O(\sum_{k = 1}^{m}s_k + Nm)$
    
    Память $O(N)$.
    \end{enumerate}
\subsection{LZSS за O(n)}
    \begin{description}
    \item[Определение:] 
    Есть строчка s. Для каждого i находм такое j < i,
    что k = LCP(s[j:], s[i:]) максимально. И
    выписываем j k, если k = 0, то выписываем симовол s[i].
    \item[Пример:]
    s = aaaaabbbaaabb

    lzss:\\
    a\\
    0 4\\
    b\\
    5 2\\
    2 5\\
    
    \item[Алгоритм]
    Заметим, что для i имеем право найти ответ за O(k).

    Строим автомт от строки и считаем left[v]. 

    Что бы найти ответ для i идем по автомату до тех 
    пор, пока left[v] < i + k - 1. То есть проверяем, 
    что левое вхождение строки левее позиции i.
    \end{description}
\section{Суффиксное дерево по автомату}
    \begin{theorem}
    Ребра из v в suf[v] "--- это ребра суффиксного дерева перевернутой 
    строки S.
    \end{theorem}

    Заметим так же, что часто нам не нужно 
    строить суффиксное дерево явно. 

    Например, что хорошего есть в суффиксном дереве, чего нет 
    в автомате. Там есть LCA = LCP. 

    \begin{description}
    \item[Пример:]

    \item[Доказательство теоремы:]
    Тут как-то все плохо и нужно будет дописывать. 

    Если таким образом образовалась вершина, то она либо терминальная, 
    либо развилка.
    \end{description}

\section{Перебор всех вхождений строки в текст за O(|S| + |Answer|)}
В решение этой задачи как раз помогает неявное построение суффиксного дерева.

Берем суфиксное дерево. Которое мы построили методом взяли автомат
перевернутой строки и запомнили \cpp"list[suf[v]].push(v)".  