\setauthor{Никита Подгузов}

\section{Линейные рекурренты}

\subsection{Решение линейных рекуррент}

Хотим решить линейную рекурренту вида $f_n = \sum\limits_{i=1}^k a_i f_{n-i}$.

Умеем решать тремя способами (два из которых мы знали и раньше):

\begin{enumerate}
	\item 
		$O(nk)$

		Просто считаем очередное значение $f_i$ с помощью цикла длины $k$.

	\item 
		$O(k^3 \log n)$

		$\begin{pmatrix}
			f_n     \\
			f_{n-1} \\
			f_{n-2} \\
			\vdots  \\
			f_{n-k+1} 
		\end{pmatrix}
		=
		\begin{pmatrix}
			a_1      & a_2    & \cdots & a_{k-1} & a_k    \\
			1        & 0      & \cdots & 0       & 0      \\         
			0        & 1      & \cdots & 0       & 0      \\         
			\vdots   & \vdots & \ddots & \vdots  & \vdots \\
			0        & 0      & \cdots & 1       & 0
		\end{pmatrix}
		\begin{pmatrix}
			f_{n-1} \\
			f_{n-2} \\
			f_{n-3} \\
			\vdots  \\
			f_{n-k} \\
		\end{pmatrix}$
	
	\item
		$O(k \log k \log n)$

		Заметим, что $f_n$ как-то выражается через первые $k$ членов нашей последовательности $f$:

		$f_n = f_{k-1} x_{k-1} + f_{k-2} x_{k-2} + \dots + f_0 x_0$.

		Теперь наша задача --- быстро найти $x_i$.

		$f_n \rightarrow \sum\limits_{i=1}^k a_i f_{n-i}$.

		Давайте переобозначим $f_n$ за $z^n$.

		$z^n \rightarrow \sum\limits_{i=1}^k a_i z^{n-i}$.

		В частности, $z^k \rightarrow \sum\limits_{i=1}^k a_i z^{k-i}$.

		То есть, на самом деле $z_k \rightarrow z_k \mod P(z)$, где $P(z) = z^k - \sum\limits_{i=1}^k a_i z^{k-i}$.

		Это верно для любого $n$: $z_n \rightarrow z_n \mod P(z)$.                                                                           

		Заметим, что $\deg P = k$, поэтому все операции с этим многочленом (например, деление и взятие по модулю) мы умеем делать за $O(k \log k)$.

		Теперь осталось быстро посчитать $z^n \mod P(z)$, сделаем это с помощью бинарного возведения в степень. 
		То есть каждый шаг мы возводим текущий многочлен в квадрат (или умножаем на $z$), а затем берем по модулю $P(z)$.
		В любой момент времени степень нашего многочлена $O(k)$, а всего операций будет $O(\log n)$, поэтому итого все будет работать за $O(k \log k \log n)$.

\end{enumerate}

\section{Диаграмма Вороного}

\subsection{Постановка задачи}

На плоскости дано $n$ точек. 
Для каждой из точек есть часть плоскости (возможно, бесконечная), для которой эта точка --- ближайшая среди всех. 
Наша задача --- разбить всю плоскость на такие области.

\begin{exmp}
	Если нам дано две точки, то нам просто нужно разбить плоскость на две полуплоскости, проведя серединный перпендикуляр между исходными точками.
\end{exmp}

Этот частный случай поможет нам решить задачу для произвольного $n$.

Кроме того, любая диаграмма Вороного на самом деле представляет из себя планарный (даже плоский) граф, в каждой грани которого находится одна из $n$ исходных точек.

\subsection{Алгоритм за $O(n^2 \log n)$}
                                        
Зафиксируем точку $i$, хотим найти часть области, относящуюся к ней (она также называется "ячейкой диаграммы"). 
Как мы поняли для двух точек, их всегда разделяет серединный перпендикуляр. 

То есть для каждой из оставшихся точек $j$ проведем серединный перпендикуляр между точками $i$ и $j$ и направим нормаль по направлению к точке $i$.
Теперь нам осталось просто пересечь все получившиеся полуплоскости, а это мы умеем делать за $O(n \log n)$.

Итого для каждой из $n$ точек мы пересекаем $n-1$ полуплоскость и получаем итоговую асимптотику $O(n^2 \log n)$.

\subsection{Алгоритм за $O(n^2)$}

Но, как оказывается, существует алгоритм за $O(n^2)$ (и который на практике проще пишется).

Он основан на идее "заворачивания подарка".
Сразу отметим, чтобы избежать проблем с точками на бесконечности при реализации, удобно воспользоваться идеей Bounding Box.


Давайте вновь, как и в прошлом алгоритме, для каждой точки выделять ее ячейку диаграммы.

Зафиксируем точку $i$ и рассмотрим ближайшую к ней $j$. 
Заметим, что точка $\frac{P_i + P_j}{2}$ точно лежит на границе ячейки (т.к. точка $j$ ближайшая к $i$).

Будем идти от этой точки по направлению серединного перпендикуляра и заворачиваться по часовой стрелке.
Пусть мы уже прошли какой-то путь, у нас сейчас есть какое-то направление. 
Из всех серединных перпендикуляров между $i$-й и $k$-й точками выберем тот, точка пересечения которого с лучом (именно лучом, а не прямой) направления --- ближайшая к текущему концу пути 
(если таких несколько, то выберем из всех минимальный по углу, то есть тот, при котором мы "заворачиваем"{} больше всего).

Итого, просто на очередном шаге мы рассматриваем $n-1+4$ прямые ($n-1$ серединных перпендикуляра и $4$ прямые Bounding Box-а) и выбираем наилучшую.

Казалось бы, работать это будет за $O(n^3)$, но нет, итоговая асимптотика $O(n^2)$ из-за того, что в диаграмме Вороного $O(n)$ ребер
(а именно столько раз мы и делаем выбор очередной прямой).

\begin{lemma}
	В диаграме Вороного $O(n)$ ребер.
\end{lemma}

\begin{proof}
	Как мы упоминали в самом начале, граф, соответствующий диаграме, планарен, поэтому в нем выполняется формула Эйлера: $V+G=E+2$.

	Кроме того, вершины в диаграме появляются только, когда соприкасаются $\geqslant 3$ ячейки, поэтому $\forall v: \deg v \geqslant 3$.

	$2E = \sum\limits_v \deg v \geqslant 3V \Rightarrow E \geqslant \frac{3V}{2}$.

	$V + G = E + 2 \geqslant \frac{3V}{2} + 2 \Rightarrow n = G \geqslant \frac{V}{2} + 2 \Rightarrow V \leqslant 2n - 4 \Rightarrow E \leqslant 3n$.

	Итого, показали, что ребер $O(n)$.
\end{proof}

Стоит отметить, что существует алгоритм за $O(n \log n)$, о котором нам должны рассказать на курсе вычислительной геометрии.

\section{Факторизация}

\subsection{Факторизация чисел}

Хотим научиться факторизовать (то есть раскладывать на простые) числа за $2^{o(\log n)}$.

Уже умеем это делать за $n^{1/4} = 2^{\log n / 4}$ с помощью алгоритма $\rho$-Полларда.

Также есть вероятностный алгоритм проверки на простоты --- тест Миллера-Рабина, который работает за $\log n$.
Примерно так работает $isProbablePrime()$ в $Java$ и похожая функция в $NumPy$.

\subsection{Алгоритм Крайчика}

Наша текущая задача --- найти любой нетривиальный делитель $n$, то есть такое $x$, что $\gcd(n, x) \ne 1$ и $\gcd(n, x) \ne n$.
После этого мы можем запуститься от $x$ и $n/x$, например, рекурсивно.

Рассмотрим последовательность $x_i = \lfloor \sqrt{n} \rfloor + i$ и $y_i = x_i^2 \mod n$, понятно, что можно оценить $y_i$, примерно как $2i\sqrt{n}$.

Мы хотим найти такой набор $\{i_k\}$, что $\prod\limits_{i_k} y_{i_k} = z^2$ для какого-то $z$.

$z^2 = \prod\limits_{i_k} y_{i_k} = \prod\limits_{i_k} x_{i_k}^2 \underset{n}{\equiv} (\prod\limits_{i_k} x_{i_k})^2$.

Если обозначить $\prod\limits_{i_k} x_{i_k}$ за $\alpha$, то получим, что $\alpha^2 \underset{n}{\equiv} z^2$, то есть $(\alpha - z)(\alpha + z) \vdots n$.
Утверждается, что тогда с вероятностью, близкой к $1$, $\gcd(\alpha - z, n)=x$ --- нетривиальный делитель $n$.

Что значит, что $\prod y_i$ --- квадрат? Значит, в записи $\prod y_i = \prod prime_j^{B_j}$ все $B_j$ --- четные.
То есть нас интересует только четность степени вхождения каждого простого.

Давайте рассмотрим только $B$-гладкие $y_i$ (то есть такие, у которых все простые в разложении $\leqslant B$).
Их мы, очевидно, можем факторизовать за $O(B + \log y_i)$, просто перебрав все простые до $B$ и попробовав на них поделить.
Итого, теперь каждое $y_i$ задается своим вектором четностей простых до $B$, длина этого вектора равна $m = \frac{B}{\ln B}$.

Выберем первые $m + \epsilon$ $B$-гладких $y_i$ и запустим на них Гаусса.
Так как векторов больше, чем размерность, то они будут линейно зависимы.
Давайте в $\epsilon$ свободных переменных запишем случайные значения, остальные выводятся из них.
Как мы знаем, вероятность того, что мы сразу найдем нетривиальный делитель близка к $1$, но не равна ей, поэтому мы и выбираем изначально $m+\epsilon$ чисел 
(чтобы было просто сгенерировать новый набор $y_i$ и проверить на нем).

Пример, иллюстрирующий вектора четностей простых:
\begin{exmp}
	\begin{tabular}{ r | c c c c}
		   & 2 & 3 & 5 & 7 \\
		\hline 
		6  & 1 & 1 & 0 & 0 \\
		7  & 0 & 0 & 0 & 1 \\
		8  & 1 & 0 & 0 & 0 \\
		10 & 1 & 0 & 1 & 0 \\
		15 & 0 & 1 & 1 & 0 \\
	\end{tabular}

	Можем выбрать три линейно зависимых строки: соответствующие числам $6$, $10$ и $15$.
	И действительно, $6 \cdot 10 \cdot 15 = 900 = 30^2$.
\end{exmp}

Гаусс работает за $\frac{m^3}{word\_size}$, но есть алгоритм Видемана, который умеет решать систему с $k$ единичками за $O(km)$.
В нашем случае мы можем оценить количество единичек как $O(m \log m)$, т.к. в каждой строчке задействовано $\leqslant \log m$ простых.
Итоговая асипмптотика будет $O(m^2 \log m)$.

Утверждается, что можно подобрать такое $B$, что алгоритм будет работать корректно и при этом время работы будет $e^{C\sqrt{ln n}}$.

На практике для $n$ порядка $2^{64}$ подходит $B=100$.

\subsection{Факторизация многочленов}

Хотим научиться факторизовать многочлены:
\begin{enumerate}
	\item
		над $\mathbb{R}$
	\item
		над $\mathbb{C}$
	\item
		над $\mathbb{F}_p$
\end{enumerate}                                    

Давайте научимся решать эти задачи.

\begin{enumerate}
	\item
		Нам дан многочлен $P$ над $\mathbb{R}$, мы хотим найти все его вещественные корни. 

		Пусть мы знаем корни производной $P'$.
		Тогда заметим, что корни производной соответствуют точкам экстремума многочлена $P$, а значит между двумя соседними корнями производной $P$ монотонен.
		Поэтому мы можем найти корень обычным бинпоиском.

		То есть если мы знаем корни производной то мы можем найти все вещественные корни нашего многочлена за $O(n^2 \log C)$, т.к. мы запускаем бинпоиск на $n$ участках,
		при этом в каждом $\log C$ итераций, в каждой из которых мы за $O(n)$ вычисляем значение в точке.

		Осталось понять, как же вычислить корни производной? 
		Рекурсивно!
		То есть просто запускаем нашу функции поиска корней рекурсивно, пока не дойдем до линейного многочлена (его корень мы можем вычислить сами), а затем откатываемся обратно.

		В этой рекурсии будет $n$ шагов (каждый раз степень многочлена уменьшается на $1$), поэтому итоговая асимптотика $O(n^3\log C)$.
		Кроме того, стоит отметить, что из-за рекурсии у нас теряется точность вычислений, поэтому по-хорошему нам нужно еще хранить ${\sim}n$ знаков, тогда асимптотика будет $O(n^4 \log C)$.

		\begin{tikzpicture}
			\begin{axis}[xmax=10]
				\addplot[domain=-6:9, color=black] {0};
				\addplot[domain=-5:8, color=red] {x^3-5*x^2-8*x+12};
				\addplot[color=black, only marks] coordinates {(-2,0)(1,0)(6,0)};
				\addplot[color=blue, only marks] coordinates {(-0.6666666666, 14.8148148148)(4,-36)};
			\end{axis}
		\end{tikzpicture}		

		Картинка, иллюстрирующая то, как мы ищем корни: корни производной разбивают все на три отрезка: от $-\infty$ до первого корня, от первого до второго и от второго до $\infty$.
		На каждом из них все монотонно, поэтому просто ищем бинпоиском новый корень.
	\item
		Нам дан многочлен $P$ над $\mathbb{C}$, мы хотим найти все его комплексные корни.

		Если мы нашли хотя бы один корень $x_*$, то мы можешь поделить на $x-x_*$ и запуститься рекурсивно, поэтому наша текущая задача --- найти один корень нашего многочлена.
		\begin{itemize}
			\item
				Случайный поиск.

				Возьмем какую-нибудь случайную точку и относительно большой радиус $R$.
				Будем итерационно выполнять следующие действия: попробуем потыкаться в $C$ рандомных точек в шаре радиуса $R$ с центром в текущей точке,
				выберем из всех ту, у которой $|P(x)|$ минимален, перейдем в нее, а радиус изменим по формуле $R_{t+1} = R_t \cdot d, d < 1$.

				На практике можно брать $C{\sim}100$, $d{\sim}0.9$.

				Утверждается, что во многих случаях такой алгоритм находит корни.

			\item
				Метод Ньютона.

				Вспомним, как работает метод Ньютона для одномерного случая (в нашем случае $f(x) = P(x)$).

				Мы берем какое-то первое приближение ответа $x_0$, а затем на каждой итерации изменяем $x$ по формуле $x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$ (в геометрической интерпретации удобно понимать сходимость к корню через проведение касательных).

				Оказывается, что для комплексного случая формула $z_{n+1} = z_n - \frac{f(z_n)}{f'(z_n)}$ тоже работает.
				Кроме того, есть следующая формула: $z_{n+1} = z_n - \frac{|f(z)|\nabla f(z)}{|\nabla f(z)|^2}$.

		\end{itemize}                                                                                                                         
	\item
		Нам дан модуль $p$ и $a<p$, наша задача найти такой $x$, что $x^2 \underset{p}{\equiv} a$ или сказать, что такого $x$ не существует.

		Алгоритм:

		\begin{enumerate}
			\item
				Если $a^\frac{p-1}{2} \ne 1$, то решений нет.
			
			\item
				Пока не нашли корень:

				\begin{itemize}
					\item
						Выбираем случайное $i$.

					\item
						Рассмотрим многочлен $A(x) = ((x+i)^\frac{p-1}{2} - 1) \mod (x^2-a)$.

					\item
						Он, очевидно, первой степени, то есть имеет вид $A(x) = bx+c$.
						Если $b \ne 0$, то возвращаем $x = -c \cdot b^{-1}$.									
				\end{itemize}
		\end{enumerate}
	
	    \begin{proof}
	
	    	Доказательство коррекности:

		    \begin{enumerate}
				\item
					Заметим, что у любого числа либо ни одного, либо ровно два квадратных корня.
					Действительно, пусть $a^2 \underset{p}{\equiv} b^2$, значит $(a-b)(a+b) \vdots p$, то есть либо $a \underset{p}{\equiv} b$, либо $a \underset{p}{\equiv} -b$.

				\item
					Всего у нас $p-1$ квадрат: $1^2$, $2^2$, \dots $(p-1)^2$, при этом из предыдущего пункта все разбивается на пары, 
					значит квадратный корень существует ровно у $\frac{p-1}{2}$ чисел.

				\item
					Группа остатков по просто модулю циклична, то есть $\exists z: z^0, z^1, \dots, z^{p-2}$ --- различные остатки по модулю $p$

				\item	
					$\forall x: 0 < x < p$ $\exists t: z^t = x$.

					Если $t$ чётное, то $x^\frac{p-1}{2} = (z^\frac{t}{2})^{p-1} = 1$, 
					если нечетное, то $x^\frac{p-1}{2} = (z^\frac{t-1}{2})^{p-1} \cdot z^\frac{p-1}{2} = z^\frac{p-1}{2} = -1$, т.к. $z^\frac{p-1}{2}$ --- квадратный корень из $1$.

				\item
					Если $a^\frac{p-1}{2} = -1$, то $1 = x^{p-1} = (x^2)^\frac{p-1}{2} = a^\frac{p-1}{2} = -1$, противоречие, то есть для таких $a$ действительно решений нет.
					Всего таких $a$ ровно $\frac{p-1}{2}$, соответственно для всех остальных корень существует.

				\item
					Обозначи корни уравнения $x^2=a \mod p$ за $z_*$ и $-z_*$.
					Рассмотрим $P(x) = (x+i)^\frac{p-1}{2} - 1$, его корни --- это числа вида $z-i$, где $z$ --- квадратичный вычет по модулю $p$.

					Также обозначим $Q(x)=(x-z_*)(x+z_*)$.

					Теперь, если оба числа $z_*$ и $-z_*$ являются корнями $P(x)$, то $P(x) \mod Q(x) = 0$, и по нашему алгоритму $x$ мы не найдем.
					
					Если ни одно из чисел $z_*$ и $-z_*$ не является корнем $P(x)$, то по КТО $P(x) \mod Q(x) = const \ne 0$, поэтому $x$ мы снова не найдем.

					А вот если корнем является ровно одно из чисел, например $z_*$, то $P(x) \mod Q(x) = R(x)(x-z_*) \mod (x+z_*)(x-z_*) = c \cdot (x-z_*)$, $c \ne 0$.
					Получили ненулевой коэффициент при $x$, значит по алгоритму найдем корень $z_*$.
		    \end{enumerate}

	    \end{proof}

	    Оценка времени работы: 
	    \begin{enumerate}
	    	\item
				Вероятность того, что случайное $i$ подойдет, равна $\frac{1}{2}$.

				Как мы поняли из доказательства, мы хотим найти такое $i$, что ровно одно из чисел $z_*-i$ и $-z_*-i$ является квадратичным вычетом.
				Иначе говоря $\binom{z_*+i}{p} \ne \binom{-z_*+i}{p}$ (тут мы заменили $i$ на $-i$ для чуть более простой записи).

				На всякий случай, $\binom{a}{p}$ --- обозначение символа Лежандра.

				$\binom{z_*+i}{p} \ne \binom{-z_*+i}{p} \Rightarrow \binom{(z_*+i)/(z_*-i)}{p} = -1$.

				Заметим, что $i \rightarrow \frac{z_*+i}{z_*-i}$ --- биекция.
				Действительно, пусть $\frac{z_*+i}{z_*-i} = \frac{z_*+j}{z_*-j}$, то есть $(z_*+i)(z_*-j) = (z_*+j)(z_*-i)$, значит $2iz_*=2jz_* \Rightarrow i = j$.

			    Мы знаем, что невычетов ровно $\frac{p-1}{2}$, а случайное $i$ дает нам случайное $\frac{z_*+i}{z_*-i}$, 
			    поэтому с вероятностью $\frac{1}{2}$ $\frac{z_*+i}{z_*-i}$ будет невычетом, а значит ровно одно из чисел $z_*$ и $-z_*$ будет корнем $P(x)$,
			    и наш алгоритм завершится на этом шаге.

	    	\item
	    		$A(x)$ мы вычисляем с помощью бинарного возведения в степень, как в алгоритме для решение рекуррентных соотношений 
	    		(только здесь у нас степень всегда $O(1)$, поэтому работать будет за $O(\log p)$).

	    \end{enumerate}

		Итого, получили оценку матожидания времени работы $O(\log p)$.

	\item
		Теперь мы хотим разложить многочлен $P(x), \deg P = n$ над $\mathbb{F}_p$, 
		причем нам известно, что $P(x)$ является произведением нескольких неприводимых многочленов степени $d$.

		Опять же, достаточно найти хотя бы один нетривиальный делитель $T(x)$, а дальше можно запуститься рекурсивно от $T(x)$ и $P(x) / T(x)$ рекурсивно.

        Алгоритм:

		\begin{enumerate}
			\item
				Возьмем случайный многочлен $Q(x), \deg Q < n$.

			\item 
				Если $\gcd(P(x), Q(x)) \ne 1$, то мы нашли нетривиальный делитель.
			
			\item
				Рассмотрим $R(x) = (Q(x)^\frac{p^d-1}{2}-1) \mod P(x)$, как и раньше, считаем мы это бинарным возведением в степень и всегда берем по модулю $P(x)$.

			\item
				Утверждается, что с вероятностью $\frac{1}{2^{n-1}}$ $\gcd(R(x), P(x))$ является нетривиальным делителем $P(x)$.
		\end{enumerate}

		Стоит отметить, что это в некотором смысле обобщение предыдущего алгоритма: когда мы искали квадратный корень, мы полагали $d=1, n = 2$.
		
\end{enumerate}                                        	                             	
