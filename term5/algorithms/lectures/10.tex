\setauthor{Валин Глеб}

\section{Планарные граф --- окончание}

\subsection{Физическая модель}

Рассмотрим физическую модель соответствующую планарному графу:
пусть вершины, соединённые рёбрами, соответствуют некоторым точкам,
которые связаны пружинками. Пусть длина пружинки 1, тогда 

\begin{itemize}
    \item Если $len > 1$, то точки притягиваются и $F \sim len^2$
    \item Если $len < 1$, то пусть точки отталкиваются с $F \sim e^{1/d} - 1$
\end{itemize}

Теперь хотим красивый плоский граф. Для этого будем пересчитывать состояние
ситемы так (из-за экспоненты, в какой-то момент, система прийдёт в равновесие):

Пусть $R_k = R_0 \cdot e^{-t \cdot const}$, $t$ --- время

\begin{cppcode}
    for i = 1..n:
        x[i] = (sum\_j F[i][j]) * R[k]
\end{cppcode}

Чтобы не образовывались сгустки вершин, граф иногда можно "встряхнуть"
\begin{cppcode}
    x[i] += random * R[k]
\end{cppcode}

\section{Пересечение, объединение невыпуклых многоугольнков}

Многоугольники --- это плоские графы.

Пусть было 2 многоугольника по $N$ вершин, напишем оценки на размер пересечения:

\begin{itemize}
    \item $V \leq N^2 + 2N$ --- максимальное число пересечений отрезков,
        второе число вершин в каждом исходном
    \item $E \leq 3V - 6$
\end{itemize}

Теперь сам алгоритм:
\begin{enumerate}
    \item Берём каждое ребро первого многоугольника и пересекаем его
        со вторым многоугольником. Точки пересечения сортируем по 
        расположению на отрезке, соседние нужно соединить ребром.
        Кроме того, вокруг каждой вершины нужно упорядочить рёбра
        по углу.

    \item Исходный граф плоский, значит грани пересечения --- это циклы 
        того, что нарисовали. Начинаем идти по ребру в каком-то направлении, 
        зашли в вершину, выходим по следующему ребру в отсортированном порядке.
        Когда зациклимся получим грань. Если пойдём по ребру в противоположном 
        направлении, то получится другая грань. Нужно заметить, что у внешней
        грани ориентация будет отличаться от остальных.

\begin{cppcode}
    for edge:
        if (!used[edge]):
            cc++
            for (i = edge; !used[i]; i = next[i]):
                used[i] = cc;
\end{cppcode}

        Ещё нужно запоминать какой грани какое ребро принадлежит, чтобы построить
        двойственный граф.

    \item Теперь осталось только понять, какие грани входят в пересечение,
        какие нет. Для каждого ребра посчитаем маску в какую фигуру оно входит
        (т.е. число от 0 до 4, но 0 никогда не бывает). Теперь нам нужен 
        двойственный граф (вершины --- грани, смежные соединены рёбрами).
        В нём мы начинаем идти с внешней грани, DFS-ом.
        Для каждой грани тоже заведём маску какой фигуре оно принадлежит (для внешней она 0)
        Тогда маска грани определяется в обходе DFS $mask(p) \otimes mask(edge)$, 
        где $p$ --- это грань из которой мы идём.
\end{enumerate}

Оценка на время: $T = N^2\log N + N^2 \cdot \left|\frac{K}{w}\right| + K N^2 \log N + KN^2$

\section{Локализация точки}

Дан плоский граф, нужно определить какой грани оно пренадлежит.

\subsection{Online}

Будем делать scanline, поэтому вначале запрещаем вертикальные 
отрезки (либо честно выбираем хороший угол, либо выбираем случайный 
и поворачиваем на него) и разбиваем граф на грани.

Преподсчитаваем структуру: для каждой вертикальной прямой список отрезков, которые
её пересекают, упорядоченные по $y$.  сначала удаляем входящие рёбра, потом добавляем
исходящие.

\TODO рисунок, с ним всё будет понятно

Нужно быть аккуратным если несколько вершин имеют одинаковый $x$, нужно будет
сначала удалить все входящие во все вершины, а потом добавить все исходящие.

Теперь провели вертикальную прямую, через точку пересечения, она пересекает,
какие-то рёбра, вершины, их можно получить из значений для прямой,
в нашей структуре которая левее локализуемой точки:

Если локализуемая точка крайняя, то грань внешняя. Иначе мы смотрим на рёбра, 
ограничивающие её снизу и сверху, смотрим какой грани они принадлежат.

\subsection{Offline}

Теперь у нас есть какой-то набор локализуемых точек.
Событими будут: $x_1 < x_2 \ldots < x_n$.

Поступим почти аналогично предыдущему случаю: заведём персистентное дерево по $y$,
для рёбер пересекающих прямую.

\begin{cppcode}
    // x*, y* - кооординаты локализуемой точки
    get(x*, y*):
        i = lower\_bound(x, x*); // находим нужный вариант состояния дерева
        root[i] -> get(y*);      // находим какими отрезками ограничена наша точка
\end{cppcode}


\chapter{Рандомизированные алгоритмы}

\section{Лас-Вегас}

\textit{тянем случайный и проверяем правильность}

\subsection{Простой пример}

Есть массив, хотим взять элемент, который в отсортированном стоит на позиции $\geq \frac{n}{2}$
Возьмём случайный элемент с вероятностью $P \geq \frac{1}{2}$ он подойдёт.

\subsection{Арифметическая прогрессия}
Дан массив, нужно выбрать подмножество $|A| \geq \frac{n}{2}$ элементов, образующих
арифметическую прогрессию.

Ткнём в 3 элемента. С вероятностью $P > \frac{1}{8}$, они образуют арифметическую прогрессию.

Вероятность, что $x$ входит в арифметическую прогрессию: 
\begin{gather*}
    x = a + dk \LRa x-a = dy \Ra y = gcd(|a_j - a_i|, |a_k - a_i|) \\
    P\{gcd(j-i, k-i) = 1\} > 0
\end{gather*}
Значит можно вытаскивать случайно элемент, проверять, что он входит в прогрессию и если
нет, то вытаскивать снова.

\section{Монте-Карло}

\textit{посчитать что-нибудь}

\subsection{Площадь пересечения}

Классический пример: пусть есть две фигуры на плоскости в какомто ограничивающем квадрате
хотим найти пересечение. Умеем проверять принадлежность точки пересечению.
Будем много раз тыкать в наш квадрат и будем приближать вероятность как отношение
попаданий ко всем попыткам. Тогда площадь можно считать как мат. ожидание:
$S_I = \frac{hit}{N} S$, где $N$ --- все попытки, $hit$ --- попадания, $S$ --- площадь 
ограничивающего множества.

Давайте посмотрим на погрешность, нам нужна дисперсия: $D = Np(1-p)$, т.к. $X\sim Bin(p, q)$

Теперь оценим погрешность так: $\frac{\sqrt{Np(1-p)}}{Np} = \theta(\frac{1}{\sqrt{N}})$
Т.е. при большом $N$ всё хорошо.

\subsection{Площадь пересечения, детерминированно}

Теперь рассмотрим другое решение, будем делать что-то похожее на Жорданову меру:
поместим наши фигуры в большой квадрат, и будем его дробить по серединам сторон,
пока дробление не станет меньше какого-то $\eps$. При дроблении у нас возможны следующие варианты:

\begin{enumerate}
    \item квадрат находится внутри фигуры: для выпуклых многоугольников
        достаточно проверить, что все вершины квадрата внутри.
    \item квадрат пересекает фигуру: это происходит, если есть нунулевая проекция
        на одну из сторон квадрата.
    \item иначе квадрат содержит фигуру.
\end{enumerate}

Тогда можно написать такую рекурсивную функцию:

\begin{cppcode}
    go(Root)
    if Root is Inside:
        return 1
    if Root is Outside:
        return 0
    if S(Root) < eps:
        return S(Root)/2;
    return 1/4(go + go + go + go)
\end{cppcode}

Погрешность $\frac{1}{N}$, где $N$ --- это число листьев завершившихся на 3-ем шаге.

Зачем про него вспомнили: при малых размерностях детерминированный вариант лучше: нет рандома
и погрешность меньше. Но нам приходится делать $2^n$ вызовов если $\dim = n$, что становится
плохо при больших размерностях. С большими размерностями придётся столкнуться при машинном
обучении, поэтому там лучше использовать Монте-Карло.

\section{Хеширование-Кукушка}

Добавление за рандомизированное $O(1)$, удаление и поиск за детерминированное, амортизированное $O(1)$.

Идея: у нас будет 2 хеш-функции (где брать хорошие? см совершенное хеширование)

\begin{cppcode}
    find(x):
        return X[H1(x)] == x || X[H2(x)] == x
\end{cppcode}

\begin{cppcode}
    del(x):
        if X[H1(x)] == x:
            x[H1(x)] = -1
\end{cppcode}

Добавление: как обрабатывать коллизии? Мы перекладываем элемент, с которым столкнулись, в ячейку $H1(y) + H2(y) - H1(x)$.
Если там образовалась коллизия, то мы продолжаем перекладывать. Возможны несколько исходов:
\begin{itemize}
    \item Мы нашили свободную ячейку и всё радуемся жизни.
    \item Цепочка вытеснений вытеснила элемент из таблицы.
    \item Цепочка вытеснений зациклилась. Как научиться понимать, что мы зациклились?
        \begin{itemize}
            \item Идём двумя указателями с шагами разной длины, 
                если они внезапно оказались в одной точке, то мы зациклились.
            \item Если есть память, то запомнить цепочку ходов
        \end{itemize}

        \begin{assertion}
            Не зациклимся с большой вероятностью
        \end{assertion}

        \begin{proof}
            Пусть $0 < H_1, H_2 < n$ и мы хотим добавить $m$ элементов.
            Если $m$ маленькое, то циколов не будет: $n > 5m \Ra E\(\text{кол-во циклов}\) \leq \frac{1}{2}$
	    $E = \sum_{\text{по всем циклам полного графа}} P(\text{цикл есть})$
            \TODO
        \end{proof}
        
        \begin{conseq}
            За $O(n)$ рандомизиованное найдём по $x_1, \ldots, x_n$ такую $f$, что
            $f: x_i \mapsto i$ за $O(1)$.
        \end{conseq}
\end{itemize}

Если случилась плохая ситуация, то меняем хеш-функции.


\section{Пересечение полуплоскостей}

\TODO

\section{Покрывающий круг}

\TODO

\section{Рёберная 3-связность}

\TODO














