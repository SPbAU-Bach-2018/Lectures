\setauthor{Валин Глеб}

\section{Планарные граф --- окончание}

\subsection{Физическая модель}

Рассмотрим физическую модель соответствующую планарному графу:
пусть вершины, соединённые рёбрами, соответствуют некоторым точкам,
которые связаны пружинками. Пусть длина пружинки 1, тогда 

\begin{itemize}
    \item Если $len > 1$, то точки притягиваются и $F \sim len^2$
    \item Если $len < 1$, то пусть точки отталкиваются с $F \sim e^{1/d} - 1$
\end{itemize}

Теперь хотим красивый плоский граф. Для этого будем пересчитывать состояние
ситемы так (из-за экспоненты, в какой-то момент, система прийдёт в равновесие):

Пусть $R_k = R_0 \cdot e^{-t \cdot const}$, $t$ --- время
\begin{cppcode}
    for i = 1..n:
        x[i] = (sum_j F[i][j]) * R[k]
\end{cppcode}

Чтобы не образовывались сгустки вершин, граф иногда можно "встряхнуть"
\begin{cppcode}
    x[i] += random * R[k]
\end{cppcode}

\section{Пересечение невыпуклых многоугольнков}

Многоугольники --- это плоские графы.

Пусть было 2 многоугольника по $N$ вершин, напишем оценки на размер пересечения:

\begin{itemize}
    \item $V \leq N^2 + 2N$ --- максимальное число пересечений отрезков,
        второе число вершин в каждом исходном
    \item $E \leq 3V - 6$
\end{itemize}

Теперь сам алгоритм:
\begin{enumerate}
    \item Берём каждое ребро первого многоугольника и пересекаем его
        со вторым многоугольником. Точки пересечения сортируем по 
        расположению на отрезке, соседние нужно соединить ребром.
        Кроме того, вокруг каждой вершины нужно упорядочить рёбра
        по углу.

    \item Исходный граф плоский, значит грани пересечения --- это циклы 
        того, что нарисовали. Начинаем идти по ребру в каком-то направлении, 
        зашли в вершину, выходим по следующему ребру в отсортированном порядке.
        Когда зациклимся получим грань. Если пойдём по ребру в противоположном 
        направлении, то получится другая грань. Нужно заметить, что у внешней
        грани ориентация будет отличаться от остальных.

\begin{cppcode}
    for edge:
        if (!used[edge]):
            cc++
            for (i = edge; !used[i]; i = next[i]):
                used[i] = cc;
\end{cppcode}

        Ещё нужно запоминать какой грани какое ребро принадлежит, чтобы построить
        двойственный граф.

    \item Теперь осталось только понять, какие грани входят в пересечение,
        какие нет. Для каждого ребра посчитаем маску в какую фигуру оно входит
        (т.е. число от 0 до 4, но 0 никогда не бывает). Теперь нам нужен 
        двойственный граф (вершины --- грани, смежные соединены рёбрами).
        В нём мы начинаем идти с внешней грани, DFS-ом.
        Для каждой грани тоже заведём маску какой фигуре оно принадлежит (для внешней она 0)
        Тогда маска грани определяется в обходе DFS $mask(p) \otimes mask(edge)$, 
        где $p$ --- это грань из которой мы идём.
\end{enumerate}

Оценка на время: $T = N^2\log N + N^2 \cdot \left|\frac{K}{w}\right| + K N^2 \log N + KN^2$

\section{Локализация точки}

Дан плоский граф, нужно определить какой грани оно пренадлежит.

\subsection{Online}

Будем делать scanline, поэтому вначале запрещаем вертикальные 
отрезки (либо честно выбираем хороший угол, либо выбираем случайный 
и поворачиваем на него) и разбиваем граф на грани.

Преподсчитаваем структуру: для каждой вертикальной прямой список отрезков, которые
её пересекают, упорядоченные по $y$.  сначала удаляем входящие рёбра, потом добавляем
исходящие.

\TODO{рисунок, с ним всё будет понятно}

Нужно быть аккуратным если несколько вершин имеют одинаковый $x$, нужно будет
сначала удалить все входящие во все вершины, а потом добавить все исходящие.

Теперь провели вертикальную прямую, через точку пересечения, она пересекает,
какие-то рёбра, вершины, их можно получить из значений для прямой,
в нашей структуре которая левее локализуемой точки:

Если локализуемая точка крайняя, то грань внешняя. Иначе мы смотрим на рёбра, 
ограничивающие её снизу и сверху, смотрим какой грани они принадлежат.

\subsection{Offline}

Теперь у нас есть какой-то набор локализуемых точек.
Событими будут: $x_1 < x_2 \ldots < x_n$.

Поступим почти аналогично предыдущему случаю: заведём персистентное дерево по $y$,
для рёбер пересекающих прямую.

\begin{cppcode}
    // x*, y* - кооординаты локализуемой точки
    get(x*, y*):
        i = lowerbound(x, x*); // находим нужный вариант состояния дерева
        root[i] -> get(y*);      // находим какими отрезками ограничена наша точка
\end{cppcode}


\chapter{Рандомизированные алгоритмы}

\section{Лас-Вегас}

\textit{тянем случайный и проверяем правильность}

\subsection{Простой пример}

Есть массив, хотим взять элемент, который в отсортированном стоит на позиции $\geq \frac{n}{2}$
Возьмём случайный элемент с вероятностью $P \geq \frac{1}{2}$ он подойдёт.

\subsection{Арифметическая прогрессия}
Дан массив, нужно выбрать подмножество $|A| \geq \frac{n}{2}$ элементов, образующих
арифметическую прогрессию.

Ткнём в 3 элемента. С вероятностью $P > \frac{1}{8}$, они образуют арифметическую прогрессию.

Вероятность, что $x$ входит в арифметическую прогрессию: 
\begin{gather*}
    x = a + dk \Lra x-a = dy \Ra y = gcd(|a_j - a_i|, |a_k - a_i|) \\
    P \{ gcd(j-i, k-i) = 1 \} > 0
\end{gather*}
Значит можно вытаскивать случайно элемент, проверять, что он входит в прогрессию и если
нет, то вытаскивать снова.

\section{Монте-Карло}

\textit{посчитать что-нибудь}

\subsection{Площадь пересечения}

Классический пример: пусть есть две фигуры на плоскости в какомто ограничивающем квадрате
хотим найти пересечение. Умеем проверять принадлежность точки пересечению.
Будем много раз тыкать в наш квадрат и будем приближать вероятность как отношение
попаданий ко всем попыткам. Тогда площадь можно считать как мат. ожидание:
$S_I = \frac{hit}{N} S$, где $N$ --- все попытки, $hit$ --- попадания, $S$ --- площадь 
ограничивающего множества.

Давайте посмотрим на погрешность, нам нужна дисперсия: $D = Np(1-p)$, т.к. $X\sim Bin(p, q)$

Теперь оценим погрешность так: $\frac{\sqrt{Np(1-p)}}{Np} = \theta(\frac{1}{\sqrt{N}})$
Т.е. при большом $N$ всё хорошо.

\subsection{Площадь пересечения, детерминированно}

Теперь рассмотрим другое решение, будем делать что-то похожее на Жорданову меру:
поместим наши фигуры в большой квадрат, и будем его дробить по серединам сторон,
пока дробление не станет меньше какого-то $\varepsilon$. При дроблении у нас возможны следующие варианты:

\begin{enumerate}
    \item квадрат находится внутри фигуры: для выпуклых многоугольников
        достаточно проверить, что все вершины квадрата внутри.
    \item квадрат пересекает фигуру: это происходит, если есть нунулевая проекция
        на одну из сторон квадрата.
    \item иначе квадрат содержит фигуру.
\end{enumerate}

Тогда можно написать такую рекурсивную функцию:

\begin{cppcode}
    go(Root)
    if Root is Inside:
        return 1
    if Root is Outside:
        return 0
    if S(Root) < eps:
        return S(Root)/2;
    return 1/4(go + go + go + go)
\end{cppcode}

Погрешность $\frac{1}{N}$, где $N$ --- это число листьев завершившихся на 3-ем шаге.

Зачем про него вспомнили: при малых размерностях детерминированный вариант лучше: нет рандома
и погрешность меньше. Но нам приходится делать $2^n$ вызовов если $\dim = n$, что становится
плохо при больших размерностях. С большими размерностями придётся столкнуться при машинном
обучении, поэтому там лучше использовать Монте-Карло.

\section{Хеширование-Кукушка}

Добавление за рандомизированное $O(1)$, удаление и поиск за детерминированное, амортизированное $O(1)$.

Идея: у нас будет 2 хеш-функции (где брать хорошие? см совершенное хеширование)

\begin{cppcode}
    find(x):
        return X[H1(x)] == x || X[H2(x)] == x
\end{cppcode}

\begin{cppcode}
    del(x):
        if X[H1(x)] == x:
            x[H1(x)] = -1
\end{cppcode}

Добавление: как обрабатывать коллизии? Мы перекладываем элемент, с которым столкнулись, в ячейку $H1(y) + H2(y) - H1(x)$.
Если там образовалась коллизия, то мы продолжаем перекладывать. Возможны несколько исходов:
\begin{itemize}
    \item Мы нашили свободную ячейку и всё радуемся жизни.
    \item Цепочка вытеснений вытеснила элемент из таблицы.
    \item Цепочка вытеснений зациклилась. Как научиться понимать, что мы зациклились?
        \begin{itemize}
            \item Идём двумя указателями с шагами разной длины, 
                если они внезапно оказались в одной точке, то мы зациклились.
            \item Если есть память, то запомнить цепочку ходов
        \end{itemize}

        \begin{assertion}
            Не зациклимся с большой вероятностью
        \end{assertion}

        \begin{proof}
            Пусть $0 < H_1, H_2 < n$ и мы хотим добавить $m$ элементов.
            Если $m$ маленькое, то циколов не будет: $n > 5m \Ra E(\text{кол-во циклов}) \leq \frac{1}{2}$
            $E = \sum_{\text{по всем циклам полного графа}} P(\text{цикл есть})$
            \TODO
        \end{proof}
        
        \begin{conseq}
            За $O(n)$ рандомизиованное найдём по $x_1, \ldots, x_n$ такую $f$, что
            $f: x_i \mapsto i$ за $O(1)$.
        \end{conseq}
\end{itemize}

Если случилась плохая ситуация, то меняем хеш-функции.


\section{Пересечение полуплоскостей}

У нас есть система неравенств, хотим найти все $x$, что 
$$
\left\{
    \begin{matrix}
        Ax \leq 0$ ($\dim = 2$) \\
        cx \lra 0
    \end{matrix}
\right.
$$

Ниже решение за рандомизированное $O(n)$:

\begin{rem}
    Живём в bound box
\end{rem}

\begin{enumerate}
    \item random shuffle полуплоскостей
    \item добавляем по одной полуплоскости, возможные варианты: 
        \begin{itemize}
            \item текущий ответ лежит в полуплоскости, тогда ничего делать не нужно.
            \item ответ лежит на прямой, задающей полуплоскость
        \end{itemize}
        \begin{cppcode}
            for i = 0..n-1:
                if (ans not in halfPlane):  // P <= 2/i
                    ans = solve(i, 0..i-1); // Theta(i)
        \end{cppcode}

        здесь \cpp{solve} решает задачу в меньшей размерности: нужный кусок
        границы --- это пересечение лучей от точек пересечения старого ответа
        и новой прямой.

        \TODO рисунок

        \begin{lemma}
            вероятность, что ответ лежит на прямой $P \leq \frac{2}{i}$
        \end{lemma}

        \begin{proof}
            точка пересечения, входящая в ответ задаётся 2-мя полуплоскостями,
            значит последняя, должна задавать эту точку.
        \end{proof}
\end{enumerate}

\subsection{Обобщение на большие размерности}

В текущем виде алгоритм обобщается на большие размерности, поменяется только
оценка на время:

\begin{theorem}
Для размерности $\dim = d$ мы решаем задачу за $n \cdot d!$
\end{theorem}

\begin{proof}
Доказательство по индукции, база $d = 2$, переход: 
$T_d = \sum_{i=1}^{n} \frac{d}{i} T_{d-1}(i) 
        = \sum_{i=1}^{n} \frac{d}{i} \cdot (d-1)! \cdot i = n \cdot d!$
\end{proof}

\section{Покрывающий круг}

Даны точки на плоскости, нужно найти круг минимально радиуса, который накроет их всех.

Аналогично предыдущей задаче алгоритм состоит из 2х частей: random shuffle точек
и итеративное изменение ответа:

\begin{cppcode}
solve_1():
    // строим стартовую окружность на P[1], P[2] P[3]
    // нумерация с 1
    for i = 4..|A|:
        if (P[i] not in ans):  // P <= 2/i
            ans = solve_2(i, i-1) // Theta(i)
\end{cppcode}

\begin{assert}
    Пусть есть множество точек $X$ и для них известен оптимальный ответ и есть точка $P$
    которая, не покрывается оптимальным ответом для $X$, тогда $P$ лежит на границе 
    оптимального ответа для $X \cup \{P\}$.
\end{assert}

\begin{proof}
   Пусть не так, тогда $P$ лежит внутри оружности, но мы знаем, что окружность задаётся либо
   3-мя точками -- это противоречит тому, что $P$ не покрывалось оптимальным ответом для $X$,
   либо 2-мя точками, это либо противоречит оптимальности ответа, если не на диаметре,
   то можно чуть-чуть уменьшить, либо снова тому, что ответ для $X$ не покрывал $P$.
\end{proof}

\begin{cppcode}
solve_2(x, A):
    // инвариант: точка "x" уже на границе ответа
    // строим стартовую окружность на x, P[1], P[2]
    for i = 3..A:
        if (P[i] not in ans):  // P <= 2/i
            ans = solve_3(x, i, i-1) // Theta(i)
    return ans

solve_3(x, y, A):
    // инвариант: точка "x", "y" уже на границе ответа
    // строим стартовую окружность на x, y, P[1]
    for i = 2..A:
	if (P[i] not in Ans):  // P <= 2/i
            ans = solve_4(x, y, i) // Theta(i)
    return ans

solve_4(x, y, z):
    // x, y, z однозначно задают окружность
    // находим центр центр описанной окружности
    retrun ans
\end{cppcode}

\begin{lemma}
вероятность, что очередная точка не принадлежит ответу $P \leq \frac{3}{i+1}$
\end{lemma}

\begin{proof}
окружность однозначно можно задать 3-мя точками
\end{proof}

Мат. ожидание времени работы оценивается так: $\sum \frac{3}{i} \cdot i = \theta(n)$
Вначале для \cpp{solve_3}, затем для \cpp{solve_2} и для \cpp{solve_1}.
Правда так считать можно, только если функции независимы, т.е. если
мы делаем shuffle в начале каждой из них. Но даже если сделать только 1 раз,
всё хорошо работает.

\section{Рёберная 3-связность}

Граф рёберно 3-связан тогда и только тогда, когда нет 2-разреза.

Рассмотрим произвольное остовное дерево, расставим на рёбрах
неостова произвольным образом числа $0$ и $1$. Хотим, чтобы было
чётное число нулей у всех вершин. Для этого красим остальные
рёбра дерева. Такая расраска есть: пойдём с листьев, а дальше по индукции.

\begin{assert}
    Посмотрим на 2-разрез. Рёбра покрашены в один цвет.
\end{assert}

\begin{proof}
    \TODO
\end{proof}

Алгоритм:
\begin{enumerate}
    \item рандомно покрасили неостов
    \item жадно докрасили остов
    \item повторим $k$ раз
    \item для каждого ребра храним историю раскрасок
    \item если у какой-то пары одинаковая история, то говорим, что это 2-разрез
\end{enumerate}

Алгоритм с одосторонней ошибкой: $P[error \ (e1, e2)] = (\tfrak{1}{2})^k)$

Повторим столько раз, чтобы ошибка стала нулевой 
$P[error] < E = \frac{m(m-1)}{2} (\tfrak{1}{2})^k) < \varepsilon$,
т.е. $k \sim \log m$

Итого, время $O(m \log m)$ вероятность ошибки $P < \frac{1}{2}$

