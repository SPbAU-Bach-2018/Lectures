\setauthor{Лапшин Дмитрий}
\chapter{Aвтоматы}

\begin{Def}
	Изоморфизм "--- если есть биекция по тому, как мы ходим.
\end{Def}
\begin{Def}
	Эвкивалентность "--- принимают одни и те же строчки.
\end{Def}

\section{Быстрая проверка на эквивалентность}

Если мы хотим проверить два автомата на эквивалентность, и один из них минимальный, то мы просто можем сделать синхронный dfs, запоминая, что для каждой вершины $i$ автомата $A$ она входит в класс, эквивалентный вершине $j$ автомата $\min(A)$. Если по дороге конфликт -- очень жаль.

\section{Эквивалентность}

Можно сделать оба минимальными, потом изоморфизм сделать.
Но это грустно.

Сделаем так: нарисуем фиктивный корень, из него по специальной букве (или по $\epsilon$, но буква \t a удобнее) два перехода: в начало первого и начало второго автоматов.

Минифицируем его. Если стартовые вершины исходных автоматов сжались в один класс "--- эквивалентны.

\section{Минификация}

Изначально есть два класса вершин "--- терминалы и нетерминалы.
Далее, мы дробимся по классу $R_1$.
Возьмём его прообраз по букве $V = a^{-1}(R_1)$, разделим его по всем классам:
\begin{align*}
	V &\cap R_1 & \bar V &\cap R_1 \\
	V &\cap R_2 & \bar V &\cap R_2 \\
	\vdots && \vdots
\end{align*}
Осталось понять, как это делать быстро.

\begin{abstractcode}
Q.push(T), Q.push(Q / T);
while (!Q.empty()) {
	R_i = Q.pop();
	for a in Σ {
		V = a^{-1}(R_i)
		// ???
	}
}
\end{abstractcode}
Мы стремимся к времени работы $O(|Σ| \cdot |E| \log |Q|)$.
Как делаем поиск прообраза в лоб: перебором обратных рёбер.
Мы хотим перебирать рёбра вершины $O(\log |Q|)$ раз.
Таким образом, каждая вершина должна попасть в очередь
$O(\log |Q|)$ раз.

Делаем так: когда мы захотим разбить класс на два, класть в очередь меньший класс.
Почему? Потому что когда мы будем по этому классу резать, вторая половина получится сама собой.

Осталось дописать код:
\begin{abstractcode}
Q.push(T), Q.push(Q / T);
while (!Q.empty()) {
	R_i = Q.pop();
	for a in Σ {
		V = a^{-1}(R_i)
		for u in V {
			list[class[u]].pb(u);
			non_zero_cnt.pb(class[u]);
		}
		for class in non_zero_cnt {
			cnt = list[class].size();
			if (cnt != size[class]) {
				// Если мы нашли не ВСЕ вершины данного класса
				if (cnt < size - cnt) {
					// Добавить новый класс
				} else {
					// Добавить новый класс, взяв его дополнение
				}
			}
		}
	}
}
\end{abstractcode}
Новый кусок работает за размер $O(V)$.

\chapter{Паросочетания}

У нас была лемма о дополняющем пути: в немаксимальном паросочетании есть дополняющий путь.

Также, есть лемма Куна: если из какой-то вершины не было дополняющего пути, то и не появится.

\section{Алгоритм Эдмунса поиска паросочетания в произвольном графе.}

Взяли свободную вершину $v$.
Из неё идут рёбра в какие-то уже взятые вершины, по ним можно перейти в парные, из них снова по рёбрам в другие занятые и так далее.
Если наш алгоритм не находит нечётный цикл "--- то всё как в двудольных графах и алгоритме Куна, нашли путь "--- есть путь.
\begin{Def}
	Соцветие: какой-то путь от свободной $v$, заканчивающийся вершиной,
	из которой идёт два незанятых ребра, называемый стеблем,
	и нечётный цикл на нём (включающий те два ребра), называемый циклом. \TODO картинка!
\end{Def}
Как видно, не все нечётные циклы подходят под это определение: \TODO картинки!

Как же мы это ищем? Если поиск дополняющего пути нашёл нечётный цикл, мы начинаем откатываться к $v$ до первого пересечения, вот и выписали соцветие.

\begin{theorem}
Можно сжать цикл в соцветии, дополняющий путь не пропадёт, а потом можно будет расжать обратно.
\end{theorem}
\begin{proof}
	Пусть мы нашли дополняющий путь после сжимания цикла.
	Посмотрим на то, входит ли в паросочетание ребро, выходящее из сжатого цикла.
	В зависимости от ответа выбираем правильную ветку цикла.

	В другую сторону: из графа $G$ сделаем $G'$, инвертировав стебель.
	Размер паросочетания не поменялся, значит доппуть всё ещё есть.
	Сожмём $\bar G'$, там цикл "--- свободная вершина.
	Возьмём любой дополняющий путь в $G'$. При сжатии он или не задет, или его можно закончить в сжатом цикле.
	Теперь покажем, что и в $\bar G$ он есть: переключим стебель (xor-им).
	Получим дополняющий путь в $\bar G$. Успех.
\end{proof}
Можно доказать, что в том числе будет и путь из $v$.

Теперь сам алгоритм поиска пути за $O(NM)$:
\begin{itemize}
	\item Запускаем поиск пути из $V$
	\item Нашли дополняющийся путь "--- радуемся
	\item Иначе, если нашли цикл в виде ребра из первой доли в первую долю "--- сжали соцветие, смотри пункт 1.
\end{itemize}
Сожмём не более $n$ раз. Само сжатие можно сделать тупо за $O(M)$: перевыписать все нужные рёбра.

\section{Реализация Габова за \texorpdfstring{$O(N^3)$}{O(N\textasciicircum3)}.}
\begin{abstractcode}
int match[N]; // парная вершина в паросочетании
int p[N]; // ссылки по восстановлению обратного пути; из 2 доли ведут только в 1
\end{abstractcode}
Пока ищем путь, входя в вершину второй доли (занятую) выставялем ей $p$.
Нашли незанятую "--- радуемся, по $p$ откатились.

Нашли нечётный цикл. Теперь выставляем $p$: по всему циклу выставляем ещё значения $p$-шек, встречные к существующим.
Это даёт возможность по этим ссылкам вернуться из любой точки цикла.
\begin{abstractcode}
queue q = { v:  p[match[v]] != -1 }
\end{abstractcode}
Инвариант: ссылки $v \ra p[match[v]]$ образуют дерево, по которым мы умеем корректно возвращаться.

Далее, заведём массив оснований цикла $base$ "--- для каждой вершины где основание её цветка.
Как находить? Ищем LCA в дереве $v \ra p[match[v]]$ за линейное время, в лоб.
Далее, на путях от замыкающего цикл ребра и включая нечётные петли на них, уже сжатые до этой компоненты, надо выставить новый $base$.
Как это делать? Это ровно все те вершины, которые имеют встреченный по дороге старый $base$.
\begin{abstractcode}
for x on path:
	visited[base[x]] = true;
for base_v in visited:
	base[base_v] = new_base
\end{abstractcode}

Ура, весь код! Там bfs, проще при изменении ссылок обрабатывать: тут код от Серёжи.

При перезаписи пешек: видяшка.

Время кубическое.

Небольшое упрощение: когда выставляем ссылки по уже cжатому циклу, можно не перевыставлять, а сразу в базу прыгнуть.
Это выкинет слагаемое.
