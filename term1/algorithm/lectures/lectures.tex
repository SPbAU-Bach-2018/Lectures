\documentclass[12pt]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsthm, amsmath, amssymb}
\usepackage[russian]{hyperref}
\usepackage{datetime}
\usepackage{cmap}
\usepackage{hologo}
\usepackage{enumerate}
%\usepackage{color}
\usepackage{picture}

\voffset=-20mm
\textheight=220mm

\hoffset=-20mm
\textwidth=175mm

\def\EPS{\varepsilon}
\def\SO{\Rightarrow}
\def\EQ{\Leftrightarrow}
\def\t{\texttt}
\def\O{\mathcal{O}}

\newcounter{theorem}[section]
\renewcommand{\thetheorem}{\thesection.\arabic{theorem}}
\newcommand*{\theoremheader}[1]{\par\refstepcounter{theorem}%
\textbf{Теорема \thetheorem.} #1}
\newenvironment*{theorem}[1]{
	\theoremheader{#1}%
}{%
\par
}

\newenvironment{MyTabbing}{
\t\bgroup
%\vspace*{-\baselineskip}
\begin{tabbing}
aaaa\=aaaa\=aaaa\=aaaa\=aaaa\kill
}{
\end{tabbing}
\t\egroup
}


\newcommand\Label[1]{\item {\bf #1}}
\def\Begin{$\bullet$\hspace{0.5em}}

\newenvironment{MyList}{
  \begin{enumerate}[1.]
  \setlength{\parskip}{-5pt}
  \setlength{\itemsep}{5pt}
}{
  \end{enumerate}
}

\newlength{\myskip}
\setlength{\myskip}{0.5em}

\newcommand\URL[1]{{\footnotesize{\url{#1}}}}

\begin{document}

\begin{center}
  {\Large \bf Лекции по алгоритмам} \\ 
  \vspace{0.5em}
  {\Large \bf Семестр 1} \\
  \vspace{0.5em}
  {\Large Лектор: Александр Куликов} \\
  \vspace{0.5em}
  {\large Автор конспекта: Ольга Черникова} \\
  \vspace{0.5em}
  {Собрано {\today} в {\currenttime}}
\end{center}

\vspace{-1em}
\noindent \underline{\hbox to 1\textwidth{{ } \hfil{ } \hfil{ } }}

\vspace{1em}
\tableofcontents
\pagebreak

\section{Числа Фибоначчи}

$0, 1, 1, 2, 3, 5, 8, 13 \ldots$ ~--- последовательность Фибоначчи.

$F_k = F_{k - 2} + F_{k - 1}$

\subsection{Экспоненциальный рекурсивный алгоритм}

\begin{MyTabbing} 
Fib(k):\\
\>if (k == 0):\\
\>\>return 0\\
\>if (k == 1):\\
\>\>return 1\\
\>return Fib(k - 1) + Fib(k - 2)\\
\end{MyTabbing}

$T(k) \ge T(k - 1) + T(k - 2) + 3 \ge F_k$

Скорость роста чисел Фибоначчи экспоненциальная. 

$F_k \sim \Phi^k \sim 1,618^k$

$F_k \ge 2^{\frac{k}{2}}$ - для $k \ge 6$ (экспоненциальная скорость роста).

{\bf Доказательство:}

Докажем по индукции. 

База:  k = 6, k = 7;

Переход: $k \to k + 1$

   $F_{k + 1} = F_{k - 1} + F_k \ge 2^{\frac{k - 1}{2}} + 2^{\frac{k}{2}} = 2^{\frac{k - 1}{2}}\left(1 + 2^{\frac{1}{2}}\right) \ge 2^{\frac{k + 1}{2}}$

$\blacksquare$

\subsection{Полиномиальный алгоритм}
\begin{MyTabbing} 
F[0...k]\\
F[0] = 0\\
F[1] = 1\\
for i = 2 ... k\\
\>F[i] = F[i - 1] + F[i - 2]\\
return F[k]\\
\end{MyTabbing}

Арифметических операций - $\O(k)$

Битовых операций - $O(k ^ 2)$

\section{Скорость роста функций}
\subsection{$\O$ ~--- символика}

T(n) ~--- время работы алгоритма.

T: $\mathbb N_0 \to \mathbb N_0$

\begin{enumerate}
\item T(n) = $\O(f(n))$, если $\exists c > 0: \forall n T(n) \le c f(n) (\le)$
\item T(n) = $\Omega(f(n))$, если $f(n) = \O(T(n)) ("\ge")$ 
\item T(n) = $\Theta(f(n)), если T(n) = \O(f(n)) и T(n) = \Omega(f(n)) (==)$
\item T(n) = $o(f(n)), если \frac{T(n)}{f(n)}_{n \to \inf} \to 0 (<)$ (T растет медленнее f) 
\end{enumerate}

\subsection{Рост функций}

\begin{enumerate}
\item

$n^2 = o(n^3)$

$\sqrt{(n)} = o(n)$

$n^a = o(n^b)$ если a < b

$3n^3 + 5n^2 + n + 20 = \O(n^3)$

\item

$(\log_2n)^{20} = o(n^{\frac{1}{10}})$

$(\log_2n)^{a}$(полилогарифм) $= o(n^{b})$

\item
$n^{10} = o(2^n)$ (экспонента)

полилогорифм < многочлен < экспонента

$\log n < \log^2 n < \sqrt{(n)} < \sqrt{(n)}\log n < n^{\frac{2}{3}} < n < n\log n < n^2 < n^3 < 2^n < 3^n$

$n! \sim (\frac{n}{e})^n$

$\log(n!) \sim n\log n$
\end{enumerate}

\section{Простейшие структуры данных}
\subsection{Стек}
 Стек: |ooooooo|$\to\_\_\_\_\_\_\_\_\_\_\_\_$  FILO (stack)
$\O(1)$ ~--- время работы.

Pop()

Push(x)

IsEmpty()

\subsection{Стек с поддержкой максимума}
Храним два стека. 

В первом элементы, во втором максимум на префиксе.

[3, 2, 4, 5 $\to$] (стек)

[3, 3, 4, 5 $\to$] (стек с максимумом)

Max()

\subsection{Очередь}

Очередь:$\_\_\to$|ooooooo|$\to\_\_$  FIFO (queue)

Push$\_$back(x)

Pop$\_$front

Очередь с помощью двух стеков.

{$\to$}(1)]  [(2) $\to$


Кладем элемент в первый стек

Достаем элементы из второго стека. 

Если во (2) стеке  кончились элементы перекладываем все элементы из первого стека.

Суммарное время работы $\O(N)$ (каждый элемент перекладываем три раза)

\subsection{дек}

Указатель на начало, указатель на конец. Закольцованный массив.

\subsection{Списки}

$\circ \to \circ \to \circ \to$

$\rightleftharpoons \circ \rightleftharpoons_{prev} \circ \rightleftharpoons^{next} \circ \rightleftharpoons \circ$

$\downarrow$ удаление элемента

$\rightleftharpoons \circ \rightleftharpoons \circ \rightleftharpoons \circ$

\subsection{Деревья}
Бинарное дерево(не более двух детей)


Можно у каждой вершины хранить две ссылки ~--- левый ребенок и правый сосед

{\bf Почти полное бинарное дерево}

[2i] $\gets$ [i] $\to$[2i  +1]

Вместо дерева можно хранить в массиве [1, 2, 3, 4 $\ldots$

\section{Расширяющийся массив}

Когда место заканчивается, создаем новый массив большего размера и копируем туда элементов.

Осталось понять, насколько надо увеличивать массив.

\begin{enumerate}
\item
адетивная схема реалокации ($l \to l + 10$)

$c + 2c + 3c +\ldots + n = c(1 + 2 + \ldots + \frac{n}{c}) = \Theta(n^2)$

(не подходит)

\item
мультипликативна схема($l \to 1,5 l$) 

$c + c^2 + c^3 + \ldots + n = \Theta(n)$
\end{enumerate}

\subsection{Метод потенциалов}

$c_1 + c_2 + \ldots + c_n \le n * \max_{1 \le i \le n} c_i$

$c_i ~--- (истесанная) стоимость$

$c_i' = c_i + \delta \Phi_i = c_i + \Phi_i - \Phi_{i - 1}$ ~--- учетная стоимость.

$\sum_{i = 1}^{n}c_i' = \sum^{n}_{i = 1}c_i + (\Phi_n - \Phi_0)$

l - длина, k - количество занятых ячеек

$\Phi = 2k - l \ge 0$

\begin{enumerate}
\item добавление без перевыделения 

$\Phi_{i - 1} = 2k - l$

$\Phi_{i} = 2k - l + 2$

$c_i' = c_i + \delta\Phi = 3$

\item с перевыделением 

$c_i' = c_i + \delta \Phi_i = (k + 1) + (2(k + 1) - 2k) - (2k - k) = k + 1 + 2k + 2 - 2k - 2k + k = 3$

$3n = \sum c_i + (\Phi_n - \Phi_0) \Rightarrow \sum c_i \sim \O(n)$
\end{enumerate}

\section{Сортировки}

A[]
A'[]

$A'[1] \ge A'[2] \ge A'[3] \ge A'[4] \ge \ldots \ge A'[n]$

\subsection{Квадратичные сортировки}

Время работы $\O(n^2)$

Просты в реализации.

Маленькая константа, быстро работают при маленьком размере массива. 

\subsection{Подсчетом}
A[] ~--- исходный массив

B[2, 2, 1] ~--- количество элементов данного вида

C[0, 2, 4] ~--- c какого места надо начинать записывать.

\section{Нижняя оценка $\Omega(n\log n)$ для сортировки}.

Построим дерево вопросов и возможных итоговых ответов.

Ответы - листья дерева.

Время работы - глубина дерева

d - глубина.

Количество листьев $\le 2^d$

глубина = $\Omega(\log_2$(количество листьев))

$\log_2(n!) = \Theta(n\log n)$

В среднем случае оценка тоже верна.

\subsection{cтабильная сортировка}

Если a == b  и a было раньше b изначально, то и в отсортированном массиве a будет идти раньше.

Стабильные сортировки: подсчетом, вставками, слиянием.

\subsection{цифровая сортировка}

сортируем сначала по последней цифре, потом по предпоследний и т.д.

Результат будет корректный, поскольку сортировка подсчетом стабильная. 


Время работы $\O(d * n)$, d - длина, n - количество элементов.

\section{Сортировка слиянием} 

\subsection{с рекурсией}

Метод "разделяй и властвуй"

\begin{MyTabbing}
MergeSort(A, l, r)\\
\>if r-l <= 30\\
\>\>InsertSort(A, l, r)\\
\>m = (l + r)/2\\
\>MergeSort(A, l, m)\\
\>MergeSort(A, m + 1, r)\\
\>Merge(A, l, m, r)\\
\end{MyTabbing}

$T(n) \le 2T(n/2) + \O(n) \Rightarrow T(n) = \O(n\log n)$

\subsection{без рекурсии}

\begin{MyTabbing} 
Q = Queue()\\
for i = 1 to n:\\
\>Q.push\_back(\{A[i]\})\\
while Q.size() > 1\\
\>A1.PopFront()\\
\>A2.PopFront()\\
\>B=Merge(A1, A2)\\
\>Q.push\_back(B)\\
\end{MyTabbing}

\section{Быстрая сортировка}

\begin{MyTabbing}
QuickSort(A, l, r):\\
\>m=Partition(A, l, r)\\
\>QuickSort(A, l, m - 1)\\
\>QuickSort(A, m + 1, r)\\
\\
Partition(A, l, r):\\
\>x = A[l]\\
\>j = l;\\
\>for i = l + 1 to r:\\
\>\>if(A[i] <= x) \\
\>\>\>swap(A, i, j + 1)\\
\>\>\>j = j + 1\\
\>swap(A, l, j)\\
\>return j\\
\end{MyTabbing}

\subsection{Среднее время работы}

\begin{theorem}
Математическое ожидание времени работы QuickSort есть $\O(n\log n)$. В худшем случае ~--- $\O(n^2)$.
\end{theorem}
{\bf Доказательство:}  Время работы $\sim$ количество сравнений $ = \Theta$(количества сравнений)

E(время работаты) = $\Theta(E(количества сравнений))$

E(количества сравнений) = $E\sum_{1\le i < j \le n} x_{ij}$ = $\sum_{1\le i < j \le n}E x_{ij}$ = $\sum(P(x_{ij} = 1))$ = $\sum \frac{2}{j - i + 1}$ = $\Theta(n \log n)$

$$
x_{ij} = \begin{cases}
1, &\text{если произошло сравнение A'[i] и A'[j], A' ~--- отсортированный массив;}\\
0, & \text{иначе}\\
\end{cases}
$$

{\bf Лемма:} $P(x_{ij}  = 1) = \frac{2}{j - i + 1}$

{\bf Доказательство:}
    $P(x_{ij} = 1) = P(первый разделяющим элементом из A'[i$\ldots$ j] оказался A'[i] или A'[j] )$

{\bf Утверждение} $1 + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n} = \Theta{\log n}$ 

$\frac{\log n}{2} \le \frac{1}{2} + \frac{1}{4} + \frac{1}{4} \ldots + \frac{1}{n} \le 1 + \frac{1}{2} + \frac{1}{3} + \ldots + \frac{1}{n} \le 1 + \frac{1}{2} + \frac{1}{2} + \ldots + \frac{1}{n} \le \log n + 1 = \Theta{\log n}$ 

\subsection{IntroSort}
Если работает дольше $c\log n$ прерываем qsort и сортируем heap sort

\subsection{Создание небольшой глубины рекурсии}
\begin{MyTabbing}
QuickSort(A, l, r):\\
\>m=Partition(A, l, r)\\
\>QuickSort(A, l, m - 1)\\
\>QuickSort(A, m + 1, r) ~--- хвостовая рекурсия, tail recursion\\
\end{MyTabbing}

Для маленькой глубины рекурсии.

\begin{MyTabbing}
QuickSort(A, l, r):\\
\>while l < r\\
\>\>m = Partition(A, l, r)\\
\>\>идем в меньший\\
\>\>\>QuickSort(A, l, r - 1)\\
\>\>\>l = m + 1\\
\end{MyTabbing}

Глубина не более $\log n$.

\subsection{QuickSort3}

Делим массив на 3 части. Элементы, которые меньше нашего, которые равны нашему и которые больше нашего. 

\section{Куча}

\subsection{heap sort}
Строим кучу за линейное время, после этого вытаскиваем элементы. 

\subsection{Частичная сортировка}
Хотим  узнать в отсортированном порядке первые k элементов и что бы остальные шли как-то. 

Строим кучу за линейное время и вытаскиваем первые k.

Время работы $\O(n) + \O(k\log(n))$

\subsection{очередь с приоритетами(priority queue)}

Getmin() $\O(1)$

Extractmin() $\O(h)$

Insert(x) $\O(h)$

Delete(ptr) $\O(h)$

Change Priority$\O(h)$

\subsection{Двоичная куча}

Двоичное дерево.

Для любого поддерева верно, что элемент в корне больше/меньше всех элементов в поддереве.

{\bf ShiftDown $\O(h)$}

Просеивание вниз.  Если в корне не верный элемент, а для обоих поддеревьев куча верная. Хотим построить правильную кучу.


Для этого выбираем min/max из вершины и детей. Меняем корень и меньшего местами и идем в меньшего ребенка.


\begin{MyTabbing}
Extractmin()\\
\>swap(root, c последним элементом)\\
\>SiftDown()\\
\>return последний элемент\\
\end{MyTabbing}

{\bf SiftUp() $\O(h)$}

{\bf Insert(x)}

добавляем в конец.

SiftUp();

{\bf Delete()} 

меняем с последним элементом просеиваем вниз.

храним дерево в массиве

\subsection{Построение кучи за линейное время}

Сначала построим дерево из элементов массива не обращая внимание на из порядок, потом для всех элементов, у которых есть потомок вызовем просеивание вниз. Просеивание вниз будем вызывать в порядке от листьев к корню.

$n = 1 + 2 + 4 + \ldots + 2 ^ k$

Время работы $2^k+ 2*2^{k - 1} + 3*2^{k - 2} + \ldots + k = n + n/2 + n/4 + \ldots + 1 = \Theta(n)$ 

\subsection{k-ичная куча}

У каждого элемента до k детей.

SiftDown - $\O(d\log_d n)$

SiftUp - $\O(\log_d n)$


\section{Порядковая статистика}

Хотим узнать, кто стоит на k-ой позиции в отсортированном массиве

$E(T(n)) = \O(n)$

$T(n) \le T_o(n \to \frac{3n}{4}) + T(\frac{3n}{4})$

$E(n) \le E(время перехода n \to \frac{3n}{4}) + E(\frac{3n}{4})$

{\bf Лемма:} среднее количество подбрасывания честной монетки до первого выкидывания орла = 2.

{\bf Доказательство:}

$E = \sum_{i = 1}^{\inf} i*P[орел выпал на i раз] = \sum_{i = 1}^{\inf} i \frac{1}{2^i} = 2$ 

$\blacksquare$

$E(n) \le E(\frac{3n}{4}) + \O(n) \Rightarrow E(n) = \O(n)$

$E(n) \le cn + E(\frac{3n}{4}) \le cn + c\frac{3n}{4} + E(\frac{9n}{16}) = cn(1 + \frac{3}{4} + \frac{9}{16})\text{убывающая геометрическая последовательность} \Rightarrow E(n) = \O(n)$

\section{Динамическое программирование}
\subsection{Динамика вперед/назад/ленивая}
$x \to x + 1$

$x \to 2x$

$x \to 3x$

Найти минимальное количество ходов, чтобы получить нужное число.

\subsubsection{Назад}

$$
d[x] = \text{сколько нужно ходов, что бы получить x.}
$$
$$
ans = d[n]
$$
$$
d[1] = 0
$$
$$
d[x] = 1 + min\begin{cases}
d[x - 1]\\
d[x/2], & \text{если кратно 2}\\
d[x/3], & \text{если кратно 3}\\
\end{cases}
$$

\subsubsection{Вперед}

\begin{MyTabbing}
d[] = inf \\
d[1] = 0\\
for x = 1 to n\\
\>relax(x + 1, d[x]  +1)\\
\>relax(2x, d[x]  +1)\\
\>relax(3x, d[x] + 1)\\
\end{MyTabbing}

\subsubsection{Ленивая}

\begin{MyTabbing}
int f(int x)\\
\>if(marked[x])\\
\>\>return d[x]\\
\>marked[x] = 1\\
\>d[x] = f(x - 1)\\
\>if(x mod 2 = 0)\\
\>\>d[x] = min(d[x], f(x/2))\\
\>if(x mod 3 = 0)\\
\>\>d[x] = min(d[x], f(x/3))\\
\>return ++d[x]
\end{MyTabbing}

Бонусы ленивой динамики:
\begin{enumerate}
\item перебирает только то, что нужно.
\item не думаем, в каком порядке надо перебирать вершины.
\end{enumerate}
\subsection{Максимальная возрастающая подпоследовательность}

$A[1\ldots n]$  $1 \le i_1 < i_2 < i_3 < \ldots < i_k \le n$   $A[i_1] < A[i_2] < A[i_3] < \ldots < A[i_k]$   


$D[1 \ldots n]$
D[i]= длина максимальной возрастающий подпоследовательности A, заканчивая в A[i].

$D[i] =\max_{i \le j \le i - 1} [D[j]: A[j] < A[i]] + 1$

\subsection{Рюкзак}
Есть предметы определенного веса и рюкзак вместимостью W. Нужно поместить как можно больше предметов.

$\sum_{i}a_i \le W$

$\sum_{i}a_i \to max$

{\bf назад}
\begin{MyTabbing}
is[0, 0] = 1\\
for i = 1 to n\\
\>for w = 0 to W\\
\>\>is[i, w] = is[i - 1, w] or is[i - 1, w - a[i]]\\
ans = is[n, w]\\
\end{MyTabbing}

Можно хранить только два массива. 

\subsubsection{Рюкзак. Восстановление ответа}

\begin{MyTabbing}
is[0, 0] =  1\\
for i = 1 to n\\
\>for w = 0 to W\\
\>\>is[i, w] = is[i - 1, w]\\
\>\>p[i, w] = 0\\
\>\>if (w >= a[i] and is[i - 1, w - a[i]])\\
\>\>\>is[i, w] = 1\\
\>\>\>p[i, w] = 1\\
\\
if (is[n, W])\\
\>for i = n to 1\\
\>\>if(p[i, w] = 1)\\
\>\>\>print(a[i])\\
\>\>\>w -= a[i]\\
\end{MyTabbing}

{\bf Уменьшим количество памяти. Динамика вперед}

\begin{MyTabbing}
is[0] = 1\\
for i = 0 to n - 1\\
\>for w = W to 0\\
\>\>if is[w]\\
\>\>\>is[w + a[i]] = 1\\
ans = is[w]\\
\end{MyTabbing}


\begin{MyTabbing}
is[0] = 1\\
for i = 0 to n - 1\\
\>for w = W to 0\\
\>\>if is[w] and !is[w + a[i]](важное условие, тест 1 2 3)\\
\>\>\>is[w + a[i]] = 1\\
\>\>\>p[w + a[i]] = 1
\\
if (is[w])\\
\>while(w > 0)\\
\>\>i = p[w]\\
\>\>print(a[i])\\
\>\>w -= a[i]\\
\end{MyTabbing}

\subsection{Оптимальная триангуляция}
(картинка)
\begin{MyTabbing}
D[i, j] = первая и последнее вершина, которая задает многоугольник\\
for i = 1 to n - 2:\\
\>D[i, i + 2] = 0\\
for l = 3 to n\\
\>for i = 1 to n - l\\ 
\>\>j = i + l\\
\>\>D[i, j] = $min_{i < k < j}$(D[i, k]  + D[k, j] + d(i, k) + d(k, j))\\
\end{MyTabbing}

\subsection{Независимые множества в деревьях}
(картинка)

$I \subseteq V(G)$ - независимо, если $\forall u, v, \in I: (u, v) \notin E(G)$

Взвешенное дерево.

$D[u]$ - ответ для дерева с корнем в u.

$D[u] = \max (w[u] + \sum D[\text{внуков}], \sum D[\text{сынов}])$

\section{Алгоритм Хиршберга нахождение расстояния редактирования(Расстояние по Левенштейну)}
x[n]

y[m]

Строчки, можем удалять, заменять элементы.

\begin{MyTabbing}
EditDistance(x[1..n], y[1..m])\\
D[n + 1, m + 1]\\
for i = 0 to n\\
\>D[i, 0] = i\\
for j = 0 to m\\
\>D[0, j] = j\\
\\
for i = 1 to n\\
\>for j = 1 to m\\
\>\>D[i, j] = min(1 + D[i, j - 1], 1 + D[i - 1, j])\\
\>\>if (x[i] == y[j])\\
\>\>\>D[i][j] = min(D[i][j], D[i - 1][j - 1]);\\
\end{MyTabbing}

Достаточно хранить только два последних слоя. 

Памяти - $\O(n)$

Время - $\O(nm)$

Хотим найти ответ от 0 0 до n m.

\begin{MyTabbing}
Hirschbery(x, y)\\
\>найдем k\\
\>k = $argmin_{1 \le i \le m}(dist((0, 0) \to (i, n/2)) + dist((i, n/2) \to (m, n)))$\\
\>Hirschberg(x[1...n/2], y[1..k])\\
\>Hirschberg(x[n/2...n], y[k + 1, m])\\
\end{MyTabbing}

$T(n, m) \le \O(nm) + T(n/2, k) + T(n/2, m - k) \le cnm + c(\frac{n}{2} k) + c\frac{n}{2}(m - k) \le c nm \Rightarrow T(n, m) = \O(nm)$

\section{Динамика на подмножествах}
\subsection{Задача о гамильтоновом цикле}

Пройти по всем вершинам ровно по одному разу. $\O(2^nn^2)$

D[S, i] - оптимальный путь из  1 в i проходящий по вершинам из S по разу.

\section{Поиск в глубину}

{\bf Способы хранения графа:}
\begin{enumerate}
\item Список смежности
\item Матрица смежности
\item Список ребер
\end{enumerate}

\begin{MyTabbing}
Explore(v)\\
\>visited[v] = true\\
\>for (u, v) $\in$ E\\
\>\>if visited[u] == false\\
\>\>\>Explore(u)\\
\\
DFS()\\
\>for v $\in$ V\\
\>\>visited[v] = 0\\
\>for v $\in$ V\\
\>\>if (visited[v] = false)\\
\>\>\>Explore(v)\\
\>\>\>++cc - количество компонент
\end{MyTabbing}

Время работы $\O(V + E)$

\subsection{Топологическая сортировка}

Ациклический ориентированный графы DAG.

{\bf Лемма:} у графа есть топологическая сортировка тогда и только тогда граф ацикл.

{\bf Доказательство:}

У ацикл. графа всегда есть исток и сток.

Сток можем поставить в конец и из графа удалить. Таким образом ничего не испортится. (Доказательство, по количеству вершин)

\section{Выделение компонент сильной связности}

Отсортируем вершины топ сортом, не смотря на то, что топологической сортировки там может и не быть.

Будем перебирать вершины в порядке топологической сортировки и запускать dfs на инвентированном графе. То что выделит dfs и будет компонента сильной связности.

{\bf Доказательство корректности}
 Вершины s и t лежат в одной компоненте тогда и только тогда, когда они в итоге в одном дереве dfs.

$\Rightarrow$

Если s и  t взаимодостижимы, то в итоге они будут лежать в одном дереве обхода в глубину.(Из t запустим dfs и он дойдет до s)

$\Leftarrow$

\begin{enumerate}
\item Вершины s и t лежат в одном дереве, значит в инвентированном графе они обе достижимы из корня r.
\item r шло раньше в порядке топ сорта, чем s и t.
Рассмотрим два случая. 
\begin{enumerate}
\item в прямом графе s и t достижимы из r, тогда все ок. 
\item хотя бы одна, пусть t из r не достижима. При этом известно, что r достижима из t, но тогда бы r шло позже t по построению. Противоречие. 
\end{enumerate} 
\end{enumerate}

\section{Поиск в ширину}

Невзвешенный граф.

\begin{MyTabbing}
BFS(s)\\
\>dist[1..N] = inf\\
\>dist[s] = 0\\
\>Q.pushBack(s)\\
\>while(Q.size() > 0)\\
\>\>u = Q.popFront()\\
\>\>for (u, v) $\in$ E\\
\>\>\>if dist[v] = inf\\
\>\>\>\>dist[v] = dist[u] + 1\\
\>\>\>\>prev[v] = u\\
\>\>\>\>Q.pushBack(v)\\
\end{MyTabbing}

\section{Дейкстра}

\begin{MyTabbing}
Dijkstra(s)\\
\>dist[1..N] = inf\\
\>prev[1..N]\\
\>dist[s] = 0\\
\>while(Q.size() > 0)\\
\>\>u = Q.ExstractMin()\\
\>\>for (u, v) $\in$ E\\
\>\>\>if v $\in$ Q and dist[v] > dist[u] + w(u, v)\\
\>\>\>\>dist[v] = dist[u] + w(u, v)\\
\>\>\>\>prev[v] = u\\
\>\>\>\>меняем очередь\\
\end{MyTabbing}

\subsection{оценка времени работы}

\begin{tabular}{|c|c|c|c|}
\hline
Время работы & k-ичная куча & двоичная куча & массив \\
\hline
V*T(Insert) & $\O(v\log_k v)$ & $\O(v\log v)$ & $\O(v)$  \\ 
\hline
V*T(Extract Min) & $\O(v k \log_k v)$ & $\O(v\log v)$ & $\O(v^2)$  \\ 
\hline
E*T(Change Prio) & $\O(E \log_k v)$ & $\O(E \log v)$ & $\O(E)$  \\ 
\hline

\end{tabular}

\section{алгоритм Форда-Беллмана}

\begin{MyTabbing}
FordBelman(G, s)\\
\>инициальзация\\
\>\>повторить v - 1 раз\\
\>\>\>для всех (u, v) $\in$ E\\
\>\>\>\>update(u, v)
\end{MyTabbing}

время работы $\O(VE)$

\subsection{отрицательный цикл}

Если на V-ой итерации что-то срелаксировалось,значит есть цикл отрицательного веса. 

{\bf Доказательство}

Если что-то срелаксировалось, то цикл точно есть.

Если есть отрицательный цикл $a_1, a_2, a_3, \ldots, a_n$.

Пусть ничего не срелаксировалось, тогда 

$d[a_2] \le d[a_1] + w_1$

$d[a_3] \le d[a_2] + w_2$

$\ldots$

$d[a_1] \le d[a_n] + w_n$

$\Rightarrow 0 \le \sum w_i$ Противоречие

\section{Кратчайшие пути в ациклических ориентированных графах}

Отсортируем вершины топ сортом. 

Можем запускать динамику в данном порядке. 

\section{алгоритм Флойда}

\begin{MyTabbing}
Floyd(G)\\
\>for i = 1 to n\\
\>\>for j = 1 to n\\
\>\>\>D[i][j]= w(если есть такое ребро)\\
\>\>\>D[i][j] = inf(иначе)\\
\>for k = 1 to n\\
\>\>.for i, j\\
\>\>\>D[i][j] = min(D[i][j], D[i][k] + D[k][j])\\
\end{MyTabbing}

\section{алгоритм Джонсона}

Деикстра не работает для ребер с отрицательными весами.

Введем потенциалы, тогда $w'[u, v] = w[u, v] + Ph[u] - Ph[v]$

Тогда $dist[s, f] = dist'[s,f] - Ph[s] + Ph[f]$

Осталось придумать потенциалы так,что бы веса были положительные. 

Потенциал будет равен расстоянию от фиктивной вершины, с ребром во все вершины веса 0.

\section{Система непересекающихся множеств}
(картинка)

Хотим объединять множества и понимать, принадлежат ли вершины одному множеству.

MakeSet(x)

Find(x)

Union(x, y)

Для каждой вершины будем хранить цвет множества, где лежит вершина.

При сливание двух множеств перекрашиваем полностью меньшее множество. 

Каждая вершина, когда перекрашивается попадает в множества в два раза большее. $\Rightarrow \text{время работы} \O(n \log n)$

\section{СНМ за $log^*n$}

Будем использовать две эвристики: сжатие путей и ранговая эвристика.

Для каждой вершинки храним ссылку на представителя. 

Представитель множества - корень.

Ранговая эвристика - для каждой вершины храним высоту поддерева и меньшее поддерево привешиваем к большему.

Корневая - каждый раз, когда получаем запрос об узнавание цвета подвешиваем все вершины на пути к корню.

{\bf Теорема:} суммарное время m операций СНМ из которых n $\le$  m - это MakeSet, есть $\O(m \log^* n)$

{\bf Доказательство:}
 
Суммарное время Find $\sim$ количество переходов от вершины к родителю = количество переходов к корню + количество переходов к родителю из того же отрезка + количества переходов к родителю из другого отрезка = ($\O(m)$ - переходов к корню) + ($\O(n \log^* n)$ - переходов к родителю внутри отрезка) + ($\O(m \log^* n)$ - переходов к родителю из другого отрезка)

[1...1][2...2][3...4][5...16][17...$2^{16}$][$2^{16} + 1$ ... $2^{2^{16}}$]

[k + 1...$2^k$] В каждом отрезке $\log^*$ имеет одинаковое значение.

Переходов внутри одного отрезка [k + 1...$2^k$] - $\O(n)$

Вершин ранга $k + 1 \le \frac{n}{2^{k + 1}}$
Вершин ранга $k + 2 \le \frac{n}{2^{k + 2}}$
 $\ldots$

 $\Rightarrow$ количество вершин попавших в отрезок $\le \frac{n}{2^k}$

Для каждой вершины в отрезке мы переходим к ее предку внутри отрезка не более $2^k$ раз(после каждого перехода ранг предка увеличивается).

$\blacksquare$

\section{Алгоритм Прима}
Дан неориентированный взвешенный связный граф. Хотим выбрать остовное дерево минимального веса.

{\bf Лемма о разрезе:} $T \subseteq E$ - часть некоторого МОД $S \subseteq V$ - такой разрез, что T не пересекает разрез, e минимальное ребро графа G, пересекающее разрез.
$\Rightarrow T \cup \{e\}$ - часть некоторого(возможно другого) МОД.
  
{\bf  Доказательство:} 

Рассмотрим дерево и добавленное нами ребро. 

Если добавленное нами ребро принадлежит дереву,значит все хорошо.

Если не принадлежит, то образовался цикл. Существует ребро которое входит из V\S в S и принадлежит циклу. Это ребро не меньше ребра e(иначе мы бы выбрали его),  значит можем его выкинуть и добавить e, от этого вес остовного дерева только улучшится. 

$\blacksquare$

{Алгоритм Прима}

Изначальна у нас есть компонента из одной вершины. Пытаемся ее расширить. Для этого для данной компоненты поддерживаем вес ребер из S до V/S.

Алгоритм пишется как Деикстра с заменой суммы на минимум.

Время работы $\O(E\log V)$

\section{Алгоритм Крускала}
\begin{enumerate}
\item отсортировать ребра по весу
\item перебираем ребра в порядке увеличения веса
\item если ребро не создает цикла, добавляем его
\end{enumerate}

\begin{MyTabbing}
Kruskal(G)\\
sort()\\
T= [];
for v $\in$ V:\\
\>MakeSet()\\
for (u, v) в порядке сортировки по увеличению веса\\
\>if(Find(u) != Find(v))\\
\>\>T = $T \cup (u, v)$\\
\>\>Union(u,v)\\
\end{MyTabbing}


Для работы с Find и Union  используется СНМ.

Время работы $\O(E log E) = \O(E \log E) + \O(V) + \O(E \log^*(V))$

\section{Коды Хаффмена}

У нас  есть текст,хотим его записать в бинарном виде. 

Если для каждой буквы выделять одинаковое количество бит, результат может получится далеко не оптимальным. Например одна буква встретилась один раз, вторая повторяется очень много.

Посчитаем частоту для каждой буквы.

Построим бинарное дерево и в листьях запишем буквы.

Для каждой вершины(кроме корня) запишем сумму весов в поддереве. Тогда длина записи = сумме весов всех вершин.


Теперь поймем, как построить оптимальное дерево. 

Для этого отсортируем все частоты в порядке увеличения. 

Существует оптимальное дерево, в котором две самые редкие вершины братья. Тогда объединим их и повторим алгоритм.

Время построения дерева $\O(n \log n)$
 
\section{Выполнимость хорновской формулы}

\subsection{Задача выполнимости (SAT)}
  $x_1, x_2, \ldots, x_n \in \{0, 1\} = \{false, true\}$
  
   Формула в КНФ. Проверяется выполнимость за $\O(m 2^n)$

\subsection{Хорновская формула}

В каждом дизъюнкте не более одной положительной переменной
\begin{MyTabbing}
$x_1, x_2, \ldots, x_n = 0$\\
while (есть неверный дизъюнкт содержащий положительную переменную $x_i$)\\
\>$x_i$ = 1\\
если формула выполнима\\
\>вернуть $x_1, x_2, \ldots, x_n$\\
иначе\\
\>вернуть NO\\
\end{MyTabbing}

Время работы $\O(N)$

\section{Задача о покрытии множествами}

У нас есть набор множеств. 

Требуется выбрать минимальное количество множеств, так, чтобы покрыть все элементы.

Жадный алгоритм: на каждом шаге выбираем множество, которое покрывает максимальное количество из еще не покрытых элементов.

{\bf Лемма:} Жадный алгоритм является ln n  приближенным. (n - количество элементов, которые надо покрыть)

{\bf Доказательство:} 
$n_i$ - количество непокрытых элементов после шага i.

Хотим доказать, что $n_i$ - убывает быстро.

k - размер оптимального покрытия.

$i - 1 \to i$

$n_i \le n_{i - 1}(1 - \frac{1}{k})$ (на каждом шаге мы должны уметь покрывать хотя бы 1/k часть от оставшихся.Такой элемент существует, поскольку $n_{i - 1}$ мы можем покрыть k множествами).

 
$n_i \le n_{i - 1}(1 - \frac{1}{k})\le n_{i - 2}(1 - \frac{1}{k})^2 \le\ldots \le n(1 - \frac{1}{k})^i < 1 \Leftrightarrow (1 - \frac{1}{k})^i < \frac{1}{n}$

$1 + x < e^x$

$(1 - \frac{1}{k})^i < (e^{-\frac{1}{k}}) = e^{-\frac{i}{k}}$

$ e^{-\frac{i}{k}} = \frac{1}{n}$

$i = k \ln n$

$\blacksquare$

\section{Деревья поиска}

В левом поддереве все элементы меньше корня, в правом - больше. 

Это верно для любого поддерева.

{\bf Печать элементов:} Распечатать левое поддерево, распечатать нас, распечатать правое поддерево.

Вывод за $\O(N) \Rightarrow за линию построить нельзя$

Find/lowerBound/UpperBound $\O(h)$

Insert $\O(h)$

Min/Max $\O(h)$

Succ/Prev $\O(h)$

Delete $\O(h)$

{\bf Удаление}

легко удалить лист, вершину, у которой один ребенок.

Меняем местами нас с самым правым в левом поддереве и удаляем.


\subsection{АВЛ-дерево}

Для любой вершины высота ее поддеревьев различается не более чем на 1.

{\bf Лемма} Высота АВЛ-дерева = $\O(\log n)$

{\bf Доказательство} В дереве высоты h $\ge c^h$ элементов.

база h = 0

переход: $h - 1\to h$

количество $\ge 1 + c^{h - 1} + c^{h - 2} \ge c^h \Leftarrow c + 1 \ge c^2$ 

\noindent \underline{\hbox to 1\textwidth{{ } \hfil{ } \hfil{ } }}

\begin{center}
  \t{\Large{\bf КОНЕЦ}}
\end{center}

\end{document}
