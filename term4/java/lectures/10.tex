\chapter{Java EE}
\section{О чём это?}
Набор спецификаций, которые реализуют различные контейнеры.
Потому что программа может выполняться не только в JVM, но и в чем-то другом --
они, контейнеры, сущности, в каком-то смысле прослойка, расширяющая наши возможности. 
А контейнер выполняется на JVM. 

Обычно мы компилируем \java".class" и скармливаем JVM'не.
А контейнеру можно и артефакт \java"JAR" или \java"WAR"(для запуска вашей программы внутри веб-контейнера -- 
он как веб-сервер, написанный на джаве) скормить, чтобы тот его запустил.
\java"JAR" "--- это не только заархивированные(zip) 
\java".class"-файлы, но можно и доп. служебную информацию, например, какой класс можно запустить, если стартует весь jar целиком, 
какие-нибудь настройки и т.д.

\subsection{JCP}
Java Communication Process -- определяют, как Java будет дальше развиваться.
Запрос на новую функциональность называется JSR, для этой фигни разрабатывается спецификация,
затем пишется базовая реализация и набор тестов, которым должны соответствовать сторонние реализации,
которые хотят соответствовать этой спецификации.

Текущая версия JavaEE отстаёт от JavaSE на одну версию.

\section{DI \& CDI}
(Context) Dependency Injection.
Технологии, объединяющая в себе несколько спецификаций.

Пусть у нас есть библиотека и генератор штрих-кодов. 
Короче, приделать штрих-коды со стороны нужно в книжки в библиотеке -- 
и очень хочется не думать об этом, а написать \java"@Inject" и чтобы оно "само сделалось".
Только это "само" "--- контейнер, именно он за нас это делает.
Видя эту аннотацию, он понимает, что в данный класс нужно инжектировать что-то -- идёт, 
это что-то создаёт и вставляет. Это довольно сложно. И всё это на лету во время работы.

\java"POJO" "--- Plain Old Java Object. 
Наши вот все такие: \java"new" для создания экземпляра
(а можно заметить, при \java"@Inject" никакого \java"new" не было -- там по-другому)

Базовая реализация CDI "--- WELD (от компании JBoss).

"Доп. настройки" из артефакта -- для DI это должен обязательно иметься \java"beans.xml".

Что можно инъектировать? Не любой же.
Чтобы был не абстрактный, чтобы был публичный, чтобы конструктор по умолчанию был 
(конструктор с параметрами может быть, но эти параметры тогда тоже должны инъектироваться).

Инжект от метода -- все параметры у него надо инъектировать.

Квалификатор. Например, \java"@Default": сообщает CDI, что если вдруг кто-то захочет инжектировать, а у нас несколько реализаций -- 
показываем, какую именно, если подходит любая (недефолтную тоже можно указать, но это явно делается).

Чем \java"@Inject" вообще лучше \java"new"? Во-первых, мы ничего не переписывали, но в другое место приписали \java"@Default" "---
и вот уже поведение библиотеки изменилось без изменения её кода. Более того, мы можем этого добиться, вообще не меняя и не перекомпилируя код -- просто подправить \java"beans.xml".

\subsection{Квалификаторы}
Идёт вместе с инжектом и помогает определить конкретный класс, который надо инжектировать.
Это тоже некоторая аннотация, к которой нужно приписать аннотацию \java"@Qualifier"(пустая).
Можно писать свои, соответственно.

Говорят, что "CDI обеспечивает строгую типизацию".

Если хотим квалификатор с параметрами
\begin{javacode}
@Qualifier
@Retention(RUNTIME)
@Target({FIELD, TYPE, METHOD})
...
\end{javacode}

Множественные квалификаторы "--- инжектировать с несколькими ограничениями.

\subsection{Альтернативы}
Пусть мы хотим какие-то заглушки инжектировать весто нормальных классов -- 
нам нужна альтернатива дефолтному классу, который обычно инжектится.

Соответственно, при обычном запуске будет инъектировать нормальные классы, 
а с определёнными настройками "--- альтернативы. (делается в xml-файле)

\section{Производители данных}
Хотим, чтобы на место поля подставлялся результат работы какого-то метода.

Пусть у нас есть метод, выступающий в качестве фабрики экземпляров компонентов.
Будем искать нужное значение по результатам сущностей, помеченных \java"@Produces"
(и, может, какие-нибудь дополнительные)

Константe в JEE можно распространить на всё приложение "--- если где-то ещё напишем \java"@Inject @SameModificatorName", 
то автоматически значение туда подставится.

Если у класса будут вызываться любые методы, то на самом деле будет вызываться
тот, который помечен \java"@AroundInvoke"(он как перехватчик, все вызовы через него проходят),
а уже оттуда -- они (скармливается перехватчику, а тот уже решает, будет вызывать или нет).
Отличный способ залогировать всё, что происходит внутри класса.

\section{Декораторы}
(как раз с помощью инжектов)

