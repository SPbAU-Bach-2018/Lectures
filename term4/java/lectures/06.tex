\section{Java NIO}
New Input/Output
Начиная с Java 1.0
С $4$ версии произошло несколько улучшений: буферы, неблокирующий ввод-вывод, селекторы.

\subsection{Каналы}
Канал -- это сущность, из которой можно считывать данные в буфер/пистаь в буфер -- и только буфер, никак иначе.
От стримов отличаются двунаправленностью, буфером и наличием асинхронности.

<надо кусочек про буферы стырить у Насти>

flip() "--- используется для переключения с записи в чтение
$limit \ne capacity$ ну разве что тогда, когда там в конце у нас что-то важное записано и нам затирать не хочется.

Чтобы использовать буфр, его надо получить -- статическим методом allocate в классах буферов.
read -- записаь из канала в буфер
put -- положить в буфер руками

write -- записать в канал
get -- получаем один элемент из буфера

класс RandomAccessFile -- из Java7.

buffer.mark()
...
buffer.reset() -- вернулись (position) туда, где в последний раз оставили маячок

Как сравнить два буфера? 3 условия:
\begin{enumerate}
\item они одного типа
\item в них должно оставаться одинаковое количество элементов (от position до limit)
\item эти оставшиеся элементы должны быть одинаковыми
\end{enumerate}

\subsection{Scatter / Gather}
Чтение из канала не в один буфер, а в несколько; и читать не из одного буфера, а из нескольких.

\subsection{Селекторы}
Для чего всё это делалось? Пусть хотим приложение на большое число клиентов. Если мы позаводили потоков на клиентов, то они 99\% времени будет 
ждать
У нас на каждого пользователя канал заведён. 
Давайте заведём сущности -- селекторы -- которые будут обслуживать эти каналы (типа клиентов) и говорить, кого уже можно пообрабатывать. 
И они будут нам находить каналы, которые к чему-то готовы.

Создаём селектор, опять же, статическим методом.
Неблокирующий режим -- вернётся сразу, независимо от того, удалось ли сделать, что хотели, или не удалось.

Селектор умеет работать только с каналами в неблокирующем режиме.
Подключаемся с помощью метода register, вызванного на канале, которому передаётся селектор и bit of interest.
\java"OP\_READ" -- готов, если из него моэно читать.
\java"OP\_WRITE" -- готов, если в него можно писать.
Если хотим сразу несоклько, то через 'или'.
Возвращает объект SelectionKey
interest set -- чем мы интересуемся
ready set -- набор того, к чему канал готов в данный момент
сам канал, сам селектор
attached object (optional)

.readyOps() -- к чему канал сейчас готов
или .isAcceptable \& $C^o$

Attached object -- что обычно прицепляют? То, что позхволить как-то идентифицировать канал (имя, id, socket)

выбор канала с помощью 
\begin{itemize}
	\item .select() -- блокирует
	\item .selsct(timeout) -- до таймаута
	\item .selectNow() -- отдаёт результат сразу, но, возможно, NULL.
\end{itemize}

Возвращает число интересных каналов(когда возвращается? кому возвращается?)

selectedKeys

после вызова select формируется set из готовых каналов

\section{Сетевые каналы}
Три типа:
\begin{enumerate}
\item SocketChannel (на клиенте просто для себя ручками, на сервере -- для клиентского сокета создания)
Всё, как обычно
Только с селекторами-то работаем в неблокирующем режиме, поэтому немножко по-другому: после .connect() нужно в цикле вручную ожидать, пока не произойдёт finishConnect, то есть мы не поймаем клиента
write() -- её надо вызывать в цикле, ничего необычного
read() -- должна что-то прочитать и завершиться сразу, чтобы не\_блокировать, поэтому надо внимательно следить за тем, сколько она считала.

\item ServerSocketChannel
В неблокирующем режиме снова фигня какая-то.
.accept() должна завершиться сразу, поэтому если в этот конкретный момент к нам никто не стучится, то она вернёт NULL и всё

\item DatagramChannel -- для UDP-пакетиков канал
\end{enumerate}


О следующем разе: как написать неблокирующий сервер, используя это всё.
То есть обработка всех клиентов будет в одном потоке.
На каждого будет один канал, подвешенный к серверу.
Будем из них читать данные, но не будем сразу их куда-то записывать, а будем ждать, пока можно начать записывать (для каждого)
Основная проблема неблокирующего сервера в том, что считать 
весь пришедший сетевой пакет нормально не моэем -- 
могло прийти нецелое число пакетов и т.п., притом что мы ограничены в размерах буфера.

Вообще написать неблокирующий сервер сложно, потому что надо одновременно думать о многих вещах.
Обычно высоконагруженные вещи пишутся на чем-то смешенном, когда селекторы формируют задачки в пул потоков.

Будет половина занятия на архитектуру неблокирующего сервера, а дальше будет про Java UI.
