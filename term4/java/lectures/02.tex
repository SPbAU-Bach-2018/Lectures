Суббота:
Экономика
Java
ОС
ОС

В среду, после двух пар по формальным языкам -- медосмотр.

\section{Fork/Join}
Fork -- вилка, Join -- присоединение.
Идея "Разделяй и властвуй": решать маленькие подзадачи, из этих двух решений получить полное.
И это хорошо работает, пока подзадачи не зависят друг от друга. Иначе мы будем тратить много времени и сил на разрешение зависимостей.
Задача -> split на несколько -> fork[начались разные потоки] -> join[кончились раздельные потоки] -> merge обратно.
Но это упрощённо: никто не говорил, что не бывает задач, которые надо делить не один раз, а больше. 
До какого момента делить? Пока подзадачи не становятся такого размера, чтобы их можно было быстро решить.
\begin{javacode}
if(problem is small) {
	directly solve problem
} else {
	split problem into independent tasks
	fork new subtasks to solve each part
	join all subtasks
	compose result from subtasks
}
\end{javacode} 
проект написан одним человеком $\ra$ много претензий
fork: был один процесс, мы его расклонировали на два(прям с копированием стека, у них идентичная(по содержанию) в начальный момент, но раздельная память).
Здесь слово fork значит, что мы должны отпочковать нашу подзадачу, то есть разрешить ей выполняться в другом потоке.
Здесь join ждет, пока задачка закончится, а потом возвращает нам результаты её выполнения.

Почему нельзя сделать так, чтобы каждая новая задача выполнялась в своём новом потоке?
Представим себе двоичное дерево, в каждой ноде -- число, хотим посчитать сумму чисел во всех вершинах.
Поддерево задаётся корнем, подзадача -- посчитать сумму в левом и правом поддереве.
Когда мы будем стоять в листе, у нас будет куча потоков будет также запущено.
То есть в худшем случае у нас будет столько потоков, сколько всего маленьких подзадач. 
Для n-ичного дерева получится $\frac{N^{L + 1} - 1}{N - 1}$. 
Переключаться между ними будет долго, особенно если листьев много -- в общем, работает "отвратительно"(с).
Причём все потоки, соответствующие вершинам на пути от корня до данной ершине просто ожидают. ЭТо неэжффективно.
Так вот идея состоит в том, чтобы join не занимала поток.
Когда наш поток вызвал join у подзадачи, он не стоит, а выполняет другие подзадачи.
Для этого мы и делали fork таким, чтобы задачи вычислялись независимо.

\subsection{Классы}
\begin{itemize}
\item
	ForkJoinClass: задачка должна уметь делиться и уметь обрабатываться нашей системой
	work-stealing -- вместо ожидания тащим в рот всякую... утаскиваем себе несделанную задачку и сами делаем
\item
	RecursiveAction -- no returning value
	RecursiveTask -- there is a returning value
	Аналогичны Runnable и Callable
	(пользуемся ими)
\item
	ForkJoinPool -- в нём вся логика распределения задач между потоками.
	execute не возвращает результат, invoke -- возвращает
\end{itemize}

\subsection{Балансировка задач} -- какому потоку задавать решать какую задачку.
Подвид задачи о расписании.
Три подхода:
\begin{itemize}
\item
	арбитраж задач
	fork -- добавлдение адач в очередь
	join 
	потом берёт себе задачку из очереди
	У каждого потока есть ещё своя маленькая очередь, %c блекджеком и своими задачками
	если там место кончается, он выкидывает задачку в общую очередь	
	(это решает проблему, чтобы поток не лазил своими лапками в чужие задачки)

	Такой подход не гарантирует, что порядок выполнения будет наиболее правильным.
	В чем узкое место? Вариант с общей очередью требует от нас синхронизации у потоков, чтобы операции добавления
	и забирания задач были синхзронизованными -- это узкое место

\item
	work-dealing
	своя собственная очередь задач, но если она вдруг кончилась, то он отдаёт эту задачу другому потоку.
	Плох тем, что легко могут получиться перегруженные(почти полная очередь, но не переполнилась) и недогруженные потоки

	Это тупой варианит, его можно улучшить, чтобы нагшрузка была равномерной

\item
	work-stealing
	У каждого своя очередь, но если он освободился, то тырит чужие задачки
\end{itemize}
в FJPool'e используется именно stealing. 
Ограничения:
\begin{itemize}
\item
- с головой очереди может работать  только владелец
\item
- из хвоста могут брать другие потоки

задачи, положенные недавно, маленькие, поэтому их разумно скармливать другим потокам, 
чтобы они их щёлкали и дальше шли, поэтому они и берут из хвоста.
\item
- владелей всё равно может брать из хвоста
Когда это может быть осмысленно?
Асинхронный режим
\end{itemize}

Куда происходит submit внешних задач? 
Хочется поближе к началу очереди, потому что чем раньше мы разобьём, тем раньше у нас появится большее количество маленьких подзадач
В общем, чтобы это делать, для внешних задач заводится отдельная очередь, у неё приоритет чуть выше, чем у старой очереди
(но у подзадач всё авно есть свои приоритеты, чтобы мы не забивали на старые совсем)

Другое решение: случайным образом достаём/добавляем задачи в ту или иную очередь(одна -- исключительно для внешних задач).

\subsection{Демонстраци и сеанс чёрной магии}

\begin{javacode}
public interface Node {
	List<Node> getChildren();

	long 
}
//базовая реализация строит дерево глуюбины 22
//первое, что можэно менять для ускорения: 
то, с какого момента задачку считать маленькой;
форк и join задачек;
порядок создания и собирания результатов задач.
Цель: сделать так, чтобы работало быстрее, чем однопоточная версия 
\end{javacode}

\section{Parallel Streams}
%простите, пример в слайдах
%надо обратить внимание, что при добавлении параллельности стало стабильно быстрее
%"узнаем точнее" -- это с именами потоков
The awful true is that parallel streams works as frok-join pools.
Все операции над параллельными стримами выполняются в этом FJP.
И он один вообще один, на все параллельные стримы -- то есть если у нас есть два, то они юзают один пул.
Это плохо.
Чтобы изюавиться от этой проблемы, пошли на хитрость: мы просили 4 потока, а они хадействовали пять.
Это для тогоЮ, чтобы наш вызвавший поток -- тоже вполне хороший и рабочий для этого FJP.
Чтобы для каждой задачи был хотя бы один швой собштвенный поток.

Следствие: все операции над параллельными потоками -- синхронные.

Проблема: при одновременной работе нескльких параллел стримов может категорически проседать производительность.
Мы хотим, чтобы задачи с параллельным стримом использовали свой FJP

%хак: 
% ps1 [_поток1_]	[_fjp1_]		ps1, его fjp на 4 потока	[только один общий поток]
%			[_fjp2_]	=>	ps2, его fjp на 4 потока
% 			[_fjp3_]
% ps2 [_поток2_]	[_fjp4_]

Проблемы общего FJP:
\begin{itemize}
\item
	не дай боже ввод-вывод -- это не join, оно стоит и ничего не работает
\item
	вложенные параллельные потоки -- это %больно
	долго
\item
	boxing/unboxing -- с ним примерно в два раза медленнее%(на слайдах численные измерения)
\end{itemize}

%параллельные потоки дадут нам выигрыш в производительноститолько в том случае, если вы сначала подумали перед тем, как их написать
