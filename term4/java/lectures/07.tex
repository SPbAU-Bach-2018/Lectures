\chapter{Графический интерфейс}
Раньше было три графических библиотеки, теперь "--- четыре.
AWT, Swing, SWT, JavaFX
\begin{itemize}
\item
	\textbf{AWT} "--- была платформозависимой.
	Все рисовашки делались средствами операционной системы.
	С одной стороны, всё выглядело очень привычно пользователю.
	Но были проблемы: на кнопочку на некоторых платформах можно повесить картинку, а на других "--- приложение упадёт.
	Компоненты, задействующие операционную систему "--- тяжеловесные.
\item
	\textbf{Swing} "--- платформонезависимая, основана на легковесных компонентах (всё отрисовывается джавой).
	Вам как пользователю ОС выглядит инородно, зато на всех платформах одинаково.
	Но если всё-таки хочется привычного, то были введены стили "--- похожие на ОС'ные стили.
\item
	Легковесные компоненты в виде Swing'a "--- это, конечно, хорошо, но долго, тяжеловесные ОС-компоненты быстрее.
	\textbf{SWT}. Swing завязан на AWT, а SWT полностью была переписана.
	Но интерфейс оказался не очень удобным, поэтому все больше Swing'ом пользуются.
\end{itemize}

В реальности больших графических проектов на Java написано всего пара: IDEA да Eclipse.
Потому что графика "--- это ресурсоёмко и тяжело, лучше что-нибудь пошустрее, чем Java, использовать.

\textbf{JavaFX} позиционировалась как замена Swing'у.
Имеется в виду, что она делает то же самое, но лучше и удобнее.
Входит в стандартный пакет, начиная с седьмой Java'ы. 
То есть изучать осмысленно, но со Swing'a начнём.

\section{Swing}
Создавался давным-давно%in a galaxy far, far away
, когда IDE не были такими клёвыми, как сейчас, когда в них нельзя было ручками элементы таскать "--- всё programmatically.
Окна верхнего уровня:
\begin{itemize}
\item
	Окно приложения "--- класс JFrame
\item
	Диалоговое окно "--- класс JDialog
\item
	Окно апплета "--- JApplet (Это кто-то в браузере О\_о)
\item
	Вложенное окно, которые внутри другого двигать можно "--- InternalFrame
\end{itemize}

\begin{javacode}
import javax.swing.*;

public class testFrame {
	public static void main(String[] args) {
		// это можно и в конструкторе класса делать
		/* конструктор какой-нибудь */
		myWindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		myWindow.setSize(300, 400);
		myWindow.setVisible(true); // потому что иначе пользователю будет виден весь процесс построения
	}
}

SwingUtilities.invokeLater 
               // принимает на вход задачу. которую надо будет выполнить потом в другом потоке
			   // отрисовка происходит в отдельном потоке, потому что может быть долго
			(  // лямбда с задачей
		   ()-> {JFrame myWindow = new SimpleWindow2(); myWindow.setVisible(true);}
		)
\end{javacode}

Создание окна == наполнение компонентами + отображение

Программа не закончит выполняться, если мы закрыли окно.
Если мы всё-таки так хотим, то надо использовать \java"EXIT\_ON\_CLOSE"(JFrame).
DISPOSE\_ON\_CLOSE
HIDE\_ON\_CLOSE

Стандартные диалоги
Есть некоторый предустановленный набор диалогов, которые можно использовать (типа стандартных "да/нет/отмена" и т.п.)

Из чего сотстоит окно верхнего уровня: (пять слоёв, поговорим про четыре)
\begin{enumerate}
\item
	ContentPane -- все графические компоненты
\item 
	LayeredPane -- чтобы задавать z-координату (глубину) компоненту
\item
	GlassPane -- чтобы реагировать на события мышки для всего окна (а не над каким-то конкретным компонентом);
	или "лоадинг" делать, чтобы скрыть, пока не готово
\item
	RootPane -- на нём всё это живёт; чтобы все три слоя разом на какую-то другую тройку заменить
\end{enumerate}

ContentPane можно весь целиком на другой заменить.

КНопочка -- класс JButton. 2 способа добавить:
\begin{javacode}
JButton newButton = new JButton(...);
getContentPane().add(newButton);

vs

//синт сахар над ^^^
add(newButton);
\end{javacode}

Контейнеры, в которые можно добавлять другие компоненты:
\begin{itemize}
\item
	JPanel
\item
	JFrame
\item
	JDialog
\item
	JScrollPane
\end{itemize}


\section{Компоновщики}
Задают правила, по которым компоненты будут отображаться на нашей панельке.

Все компоновщики "--- реализации интерфейса "LAyoutManager", досталось Swing'y от AWT (равно как и JFrame, то есть само окошко -- не его содержимое -- отрисовывается не средствами джавы, а ОС"ными)

\begin{itemize}
\item
	\textbf{FlowLayout}
	Всё в строчечку выкладывает
	\java"alignment" -- горизонтальное выравнивание

\item
	\textbf{BorderLayout}
	Стоит по умолчанию
	Можно расположить в центре, на севере, на юге, западе, востоке.
\item
	\textbf{GridLayout}
	Имеет определённое количество столюцов и строк, которые мы последовательно заполняем
\item
	\textbf{BoxLayout}
	\java".createHorizontal//VerticalBox" "--- создаются статическими методами, два типа, как видно.
	Компоненты набиваются, как в стек.
	Есть Strut(распорка) и Glue(клей).
	%картинка с палочками и пружинками
\end{itemize}

\java"getContentPane().add(new JButton("WEST"), BorderLayout.WEST);"
Если несколько кнопочек в центре создать, то они друг на друга наложатся.

PreferredSize -- кнопка умеет сама рассчитывать свой размер (исзодя, в основном, из размеров текста).

\java"new GridLayout(# солбцов, # строк, зазор по горизонтали между компонентами, зазор по вертикали)"

%"если поставить себя на место кнопочки" (с) Ксюша ^^

\java"panel.setLayout(null);" -- тогда позиции всех компонентов надо задавать самостоятельно.

Давайте теперь ещё и красиво научимся делать, а не только как-нибудь.
\subsection{Обрамления}
Класс \java{Border}. \java"EmptyBorder", \java"LineBorder", \java"EtchedBorder", \java"BevelBorder", \java"MatteBorder".

JToggleButton
JCheckBox, JRadioButton
Это всё кнопки

\subsection{Компоненты ввода текста}
JTextField
JPasswordField
JTextArea

\subsection{Панель прокрутки JScrollPane}
\java"JScrollPane(Component?, политика горизонтальной строки прокрутки, п~ вепртикальной с.п.)"
%Nhb gjkbnbrb/

\subsection{Ещё есть}
JToolBar % А Дима сказал, что это немодно-о!
, JComboBox выпадающий список, JSlider ползунок, JTabbedPane вкладочки, JList можно выбрать какое-то количество позиций, JProgressBar

Можно вставлять кусочки html'я.

\section{Слушатели}
Вешаются на кнопку, по какому-то событию реагируют
и выполняют какие-то действия

\java".addMouseListener(...)" или \java"MouseAdapter" "--- у него заглушки на все основные методы реализованы.

\java"ComponentListener" "--- смена положения/размера
\java"ActionListener" "--- универсальный, он слушает ровно одно "--- главное "--- событие (для каждого компонента оно своё).
То, что ровно одно событие, позволяет нам использовать лямбду для описания обработчика.
При этом туда будет передан параметр \java"ActionEvent", который позволит нам немножко лучше понять, 
по какому конкретно поводу нас вызвали.

\section{Action}
Действие "--- абстракция действия, которое можно произвести. (чтобы написать один раз и пихать потом везде)
Интерфейс Action.
Единственное, что реально надо переопределять "--- \java"actionPerformed(ActionEvent)" (совершить действие).
Если к кнопке привязан \java"Action", то на ней будет показан \java"LONG_FDESCRIPTION", если к менюшке "--- то \java"SHORT_DESCRIPTION".

%"я создаю toolbar и кладу на него два action'a" (c) АМ

То, что на несколько элементов наложен один и тот же \java"Action", означает, что эффекты для них для всех общие (как и всякие ресурсы, типа текстов и картинок)


\section{Swing и потоки}
Если наш Listener делает какое-то очень долгое действие, то графический интерфейс зависнет 
"--- поэтому его надо вынести в отдельный поток, чтобы всё не вешать.

invokeLater
invokeAndWait

%пример не работает хорошо, потому что Джаву оптимизировали: раньше у него при щёлкании по кнопкам progress bar начинал двигаться урывками,
%а теперь нормально ползёт
Так что изменения в визуальной части компонентов пишите, пожалуйста, через \java"SwingUtilities" 
(откуда, собственно, это \java"invoke"'и родом).


