\section{Презентации на следующей неделе}
\begin{itemize}
\item
Что делали -- описание проекта (идеального), постановка задачи, 
\item
мотивация(зачем делали и что хотелись решать)
\item
как сделано -- про модули, которые есть в приложении, и то, как оно взаимодействует; здесь же про интересные моменты, 
которые встретились при решении
\item
продемонстрировать -- реальная демонстрация/скриншоты/ролик
\item
выводы: что хотели, что получилось, что не получилось, что нового узнали в рамках этого проекта
\item
не забывать ссылки на репозиторий и собранный apk
\end{itemize}

жестко 7 минут
вопросы после 7 минут

Раньше были проблемы:
\begin{enumerate}
\item
не укладывались во время (надо порепетировать)
\item
порепетировать перед незнающим человеком -- чтобы понятно рассказывать
\item
не рекламная презентация (не продать проект), а техническая: 
то есть не без доли саморекламы, но надо технически описать задачу, проблемы, их решения, что получилось и что не получилось
\item
Александр Владимирович плохо относится к котикам %ну и бе-бе-бе
\item
лучше следовать этой схеме (данной выше)
\end{enumerate}

Это бонус, то есть можно дополнительно получить $[0 .. 1]$


\section{Ответы на тест}
\begin{enumerate}
\item
	(Для чего используется протокол ICMP? Назовите побольше примеров использования?)
	Отправляются маршрутизатором, который по какой-то причине не может передать дальше пакет.
	А ещё ping, trace-rout, синхронизация времени.
\item
	(Что такое ARP? Как работает?)
	ARP -- resolution. Какой mac-адрес по данному ip-адеусу. Широкоыещательный пакет,отвечет только комп с нужным ipc-адресом
\item
	(Что делают 13 корневых DNS-серверов?)
	перенаправляют на dns-сервера, отвеч за соотв домен первого уровня
\item
	(Что такое TTL? Для чего нужен?)
	TTL -- число от 0 до 255, обознач время жизни покате. 0 -- уничтожается. 
	При проходе через маршрутизатор уменьшается на единичку
	Чтобы не ходили по кругу.
\item
	(Что такое порт? Зачем нужен? Как выбирается?)
	Порт -- число от 0 до 65***, идентификатор сетевого соединения, чтобы пришедшие данные нужному приложению отправлять.
	Выбирается одним из трех вариантов: либо случайно, либо 
	Порт 80 соответствует протоколу http.
	В линуксе есть специальный файлик
	Третий вариант: если мы пишем веб-сервер(отвечающий на http-запросы), 
	то он может ручками выбрать (но это обычно только у серверных приложений так).
	Клиенту обычно не нужно, потому что ему редко что шлют извне. 
	
	до 1024 порта в линуксе -- для служебных приложений (надо запускать с правами root'a)
\end{enumerate}

\section{Опять какие-то уровни}
\subsection{}
Можно писать приложения, которые общаются примерно на любом уровне
%картинка1
Поэтому дальнейший рассказ будет про уровень app.

\subsection{}
Значит, если мы хотим писать приложение для работы по сети, нам надо выбрать протокол.
Посмотрим на TCP.

Пусть наше приложение работает на порте 2078, а там (\_там\_!) есть порт 80.
Оба шлют на один и тот же порт данные.
%картинка2

\subsection{UDP}
Сокет -- это просто некоторый API для передачи сообщений. Бывают не только сетевые, но и межпроцессные (на одном компе),
есть связанные с файлами -- а мы сегодня говорим всё-таки про сетевые.
В нашем, то есть са
Программная абстракция, представляющая собой сетевое соединение (а оно задаётся IP-адресом и портом клиента и IP-адресом и портом сервера).
В Java8 есть TCP и UDP сокеты, а также поддерживающие IPv4/6
\begin{javacode}
//это по UDP -- самое простое ghjot dctuj? endth;lftncz
try (DatagramSocket s = new DatagramSocket()) {
	DatagramPacket //один пакет, который хотим передатьЮ надо указать данные, их длину и удалённый порт
	s.send()
//тут порт клинета за нас выбрала ОС случайно
//ОС привязала нас автоматически ко всем сетевым интерфейсам имеющимся
//при отправке будет указан IP адрес того сетевого интерфейса, по которому пакет де-факто ушёл

//если мы сказали "отправь", то сначала пытаемся отправить по сетевому интерфейсу, в одной локальной сети с адресом назначения, если есть
//такой. Если нет, то по приоритету оставшихся.
//у интерфейсов есть приоритеты (выше у тех, кто подключён к интернету)
}
//мы не задаём свой порт, так как мы не сервер
//мы не задаём свой IP, потому что система должна знать + у нас, имеется в виду, только одно сетевое устройство на компе
//
\end{javacode}

\begin{javacode}
DatagramSocket(port) -- сервер будет ждать на этом порте
создали буфер
создали пакет, в котором мы ща один receive прочитаем не больше, чем сказали длины (оставшееся прочитаем, если сделаем ещё один receive -- оно возвращает, сколько прочитало)
receive -- блокирующая команда (программа останавливается и ждёт, пока кто-нибудь не пришлёт данные)(есть timeout? gjckt ytuj jndfkbvcz)
\end{javacode}

Как сервер узнаёт, от кого пакет? У пакета есть метод, возвращающий адрес клиента-отправителя.

обычно сервер -- пассивен, то есть для него нормально сидеть на команде receive B ничего не делать.


\subsection{TCP}
Socket -- это TCP сокет в джаве
\begin{javacode}
Socket socket = new Socket("localhost", 11111); 
//хост и номер порта: хост можно писать строчкой, 
//можно прямо IP-адресом, можно свлй адрес и  порт прописать -- 
//если у нас несколько сетевых соединений (и вряд ли мы клиент в таком случае); 
//можно вообще ничего не указывать, а привязать потoм
\end}javacode{
При создании сокета сразу устанавливается соединение, и если это не удалось, то конструктор кидает исключение.
В чём отличие от UDP -- у нас есть соединение, по которому мы можем передавать данные. Зато нет отдельно взятых пакетов.
Поэтому здесь мы используем стримы.
Надо помнить, что чтобы быть уверенным, что данные по output-stream'у точно отправились, надо делать flush().
Правда, не очень хорошо всё время делать flush() -- ну, головой думать надо.
Также есть и InputStream'ы. Это было про клиента. У сервера это сложнее.
Оборачивать InputStream  в BufferedStreamReader -- это хороший тон, быстрее будет.

\begin{javacode}
ServerSocket server = new ServerSocket(11111);//не обычный, потому что новые порты делает
Socket socket = server.accept();//принимает клиента, создаёт ему новый порт, а нма даёт обычный сокет, чтобы общаться с этим клиентом.

InpurStream is = socket.getInputStream();
is.read(requestBytes);

OutputStream os = socket,getOutputStream();
os.write(responseBytes);
os.flush();
//но этот код обработает только одного клиента -- мало

while(true) {
	accept a connection;
	deal with it;
}

//тоже плохо -- однопоточно, только один клиент за раз
//что делать?

while(true) {
	accept a connection;
	create a thread to deal with the client;
}
//тут создаётся можно потоков, поэтому их лучше переиспользовать
//хотя Apache работает так, он на каждого клиента новый процесс создаёт
//но правильнее всео работать так

while(true) {
	accept a connection;
	create task which will deal with the client;
}
//лучше всего тут будет cached thread pool (может создавать дополнительные и убивать лишние потоки)
\end{javacode}

Существует ещё принципиально другая идеалогия -- на callback'ах
