\section{Аннотации в compile-time'e}
Проыессор "--- сущность, которая будет занимаьтя обработкой аннотаций в процессе компиляции.

Чтобы его написать, надо отнаследоваться от \java"AbstractProcessor"'a 
и переопределить в нём четыре метода.

\begin{enumerate}
\item
\java"init()"
Конструктор должен быть пустым, вся инициализация "--- здесь.
\item
\java"process()"
\java"environment"'ы в них дают доступ к некоторым утилитарным классам.
Предоставляет некоторый сет из аннотаций.
\item
\java"getSupportedAnnotationTypes()"
Возвращает список строк "--- названий аннотаций, которые мы хотим обрабатывать.
\item
\java"getSupportedSourceVersion()"
Мы можем наш процессор использовать в разных проектах, и чтобы описать,
начиная с каких версий джавы с ним можно работать.
Можно возвращать \java"SourceVersion.latestSupported()"(при вызове возвращает текущую версию джавы, в которой мы сейчас компилируемся), 
можно "--- \java"SourceVersion.RELEASE_6".
\end{enumerate}
В Java8 вместо последних двух методов принято писать две аннотации
\begin{javacode}
@SupportedSourceVersion(SourceVersion.latestSupported())
@SupportedAnnotationTypes({
	// Set of full qullified annotation type names
})
\end{javacode}

\subsection{jar-ник}
В него надо записать содержимое MyProcessor.class и javax.annotation.processing.Processor.
Передать компилятору со специальном ключиком и всё сделается за нас 
(а в какой-нибудь среде разработки так и подавно).

\subsection{Пример: пицца и тирамису}
% Представим себя человеком, который хочет заказать пиццу
[Магазин пиццы]
Это ужасный код, но мы на него сейчас посмотрим, потому что нам всё равно его сейчас генерировать.
Ужасно здесь то, что если у нас, паче всякого чаяния,
 добавился ещё один вид еды, то нам придётся дописывать ещё один \java"if". % всем уже страшно?)

[Вынесем фабрику в отдельный класс]
И вот эту фабрику еды мы сейчас и будем генерировать.

[MealFactory]
Давайте подумаем, что мы вообще должны делать?
Нам надо найти все классы еды.
Для этого надо знать, как класс зовут.
Чтобы это делать, мы создадим собственную аннотацию \java"@Factory".

[@Factory]
Без type можно было и обойтись, но тогда мы сможем безболезненно ещё и чайниковые фабрики генерировать.
Мы хотим, чтобы наш процессор нашёл все классы с аннотациями \java"@Factory" и типом \java"Meal.class" и генерировал нужный код.

Чтобы мы могли это делать, в классе должен быть публичный конструктор без параметров, не кидающий exception'ов, он должен быть отнаследован от своего type (Meal.class). 
\begin{enumerate}
\item
Нельзя интерфейсы и абстрактные классы
\item
Публичный конструктор безх параметров и исключений
\item
Нужна возможность привести аннотированный класс к ''типу'' из параметров
\item
Классы с одним ''типом'' будут объединены в одну фабрику
\item
\java"id" "--- это строка, должна быть уникальной для классов с одним *типом*
\end{enumerate}

[Приступаем]
Почему сет, а не коллекция? Потому что чтобы уникальные элементы были.

\java"@AutoService(Processor.class)" "--- автоматически генерирует манифест-файл. 
Да-да, и у неё есть свой процессор.

[Приступаем]
В \java"init"'e сохраняем экземпляры всех четырех утилитарных классов в приватные поля.

[Init]
\begin{itemize}
\item
Elements "--- Element.
Это о чём вообще?
AnnotationProcessor сканирует весь код и разбивает на некоторые части "--- называются *элементами*.
Каждому элементу можно сопоставить некоторую сущность языка.

Как элементы обходить? 
[Как обходить элементы]
\java"TypeElement.getEnclosedElements()" "--- получить детей.
\java"~Enclosing~" "--- получить родителя.

НО это всё есть всего лишь описание элемента исходного кода, 
%синтаксически 
поэтому родительский класс,
например, мы узнать не можем. \java"TypeMirror" "--- может.
\item
Type "--- для работы с TypeMirror.
Позволяет получать класс \java"TypeElement"'a, прямо тот, который с точки зрения языка Java. Делается методом \java"element.asType()".
\item
Filer "--- автоматически создаёт файлы в нужных папках (по конвенции, всё строго)
\end{itemize}

[Поиск аннотации @Factory]
Код, который пробежится по всем классам, проаннотированным аннотацией @Factory.

\java".getElementsAnnotatedWith(Factory.class)" "--- вернёт любые элементы, к которым приписана данная аннотация.
Но мы должны проверить, что пользователь % не дурак
сделал всё правильго и приписал аннотацию к классу.
[Проверим]

%\end{enumerate}
TypeElement "--- слишком широкое понятие (нам интерфейсы и абстрактные классы не подходят.)
Поэтому так.

Если мы обнаружили, что пользователь всё-таки приписал аннотацию не туда,
то джава, конечно, предлагает нам кинуть \java"Exception" "--- но нам нужна ошибка компиляции,а не исключение, чтобы некорректно завершать компилятор и только среду разработки смущать.
Что делать? Как генерировать сообщение об ошибке компиляции?
Используем четвёртую сущность "--- \java"messager".
(функция \java"error()" в нашем коде)
Компилятор всё поймёт, место "--- засчёт параметра \java"e", имеющего тип \java"Element" (то есть ''строчка кода'')

Вообще, метод \java"process()" должен возвращать \java"Boolean". 
Если он вернул \java"false", то компиляция завершится.
Но \java"AnnotationProcessor"'ам \textit{крайне} не рекомендуется возвращать \java"false", потому что кроме нас есть и другие процессоры, надо дать им тоже нормально отработать.

[Лирическое отсутупление]
Чтобы нам дальше было удобно всё это обрабатывать, введём ещё две сущности "--- напишем ещё два класса для работы с классами, проаннотированными нашей аннотацией: куча\_классов\_сгруппированных\_по\_типу и один\_класс\_из\_этой\_кучи

[Монструозный слайдик О\_о]
Первая часть кода получает \java"id" (\java"TypeElement" $\ra$ \java"getAnnotation" $\ra$ \java"id").

Вторая часть: просим у аннотации \java"type". 
Но класс, который мы получили, мог быть ещё не откомпилирован, то что делать?
Тогда строчка \java"annotation.type" выдаст нам \java"MirroredTypeException" (то есть класс ещё не откомипилирован) "--- в ответ на это мы берём у него \java"declaredTypeMirror" (типа ''описание описания класса'')
(плохо пользоваться \java"TypeMirror"'ом, долго это, поэтому чтараемся избегать, по возможности). 
Точнее, это ещё не самое долгое "--- его мажорирует \java"asElement()", потому что он идёт в файлы с кучей неоткомпилированного кода и среди него находит нужный нам класс.

\java"FactoryGroupedClasses" "--- кучка классов с одинаковым \java"type"'ом.

[Возвращаемся к Processor]
Ntgthm? rjulf vs ghjdthbkb? xnj fyyjnfwbz приписал аннотацию именно к классу, мы можем безбоязненно кастовать
\java"(TypeElement) annotatedElement"

[Что мы проверяем]
Метод \java"isValid()" проверяет наши тербования.

Reminder: \java"factoryClasses" "--- мапа из типа в кучки.

Всё, мы все кучки разложили, теперь можно генерировать.
Надо пробежаться по всем кучкам и сказать ''сгенерь код''.

[Code generation]
[Как сгенерировать код?]
Хоть строчки конкатенировать, хоть утилитки использовать "--- например, здесь используется библиотека \java"JavaWriter" (пристально смотрим на переменную \java"jw").

[Processing Rounds]
Мы молодцы, конечно. Но компилировать-то это кто будет? 
Поэтому говорят, что компиляция происходит в несколько раундов.
Помимо новых файлов на втором этапе компиляции мы будем компилировать 
те файлы, которые не смогли скомпилировать на первом этапе.
Новые раунды будут до тех пор, пока набор файлов меняется.
Для нашего процессора каждый раунд "--- вызов метода \java"process" 
(\java"init" "--- только один раз).
Поэтому надо очищать в \java"process"'e всё, что нам не потребуется на следующем этапе "---
например, чтобы не генерировать снова \java"MealFactory" (генерировать два одинаковых файла запрещено, так что это кончится ошибкой компиляции).

\subsection{Как ещё?}
Можно изменять существующие классы на этапе компиляции.
Это сложно, но библиотечки есть, компилятор обманываем.
А ещё мы можем ещё и не исходные, а уже откомпилированные java-файлы генерировать (например, запустить джавовский компилятор отдельно; так мы наш компилятор и обманем).
