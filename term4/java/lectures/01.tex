Зачёт с оценкой
оценка = :
1. дз (0 .. 5)
2. кр (0 .. 5)
3. летучки (0 .. 5)
4. устный зачёт (2 .. 5)
5. антибонус с прошлого семестра (-1) (нечто лично-индивидуальное)
6. проект по Java (-2 .. +1)
По всем пунктам не ниже тройки


Домашки будут практически каждое занятие
Кр будут на практиках как обычно
Летучки на лекциях относительно регулярно, некоторые с предупреждением, некоторые -- без. Это намеренно, чтобы мы не спали вместо лекций.


Проект.
Для сдачи нужно:
	-- *ОЦЕНИВАЕТ АМ* доделать необходимый функционал(-1(не додел), 0(достаточно), 0.75(сделано больше, чем надо), оценивает АМ)
	-- *ОЦЕНИВАЕТ ЧЕЛОВЕК* пройти код ревью (смотреть на sewiki; -1(не пройдено), 0(удовлетворительно), 0.5(порадовать руководителя))
Оценка -- сумма оценок, каждаЯ не больше +1
Всё это надо сделать до 13 марта. 13 марта ревьюер выставляет итоговую оценку.


А в этом семестре нас ждут:
Про стримы,
Network in Java,
Java GUI(JavaFX/Swing),
Java New Input Output(- or 2),
Annotations,
JEE elements

Практики начнутся с разговоров о многопоточности. С момента сети уже состыкуются с лекциями.

Курс про сети будет отдельный, курс по JavaEE будет отдельный на 5 курсе, поэтому про них обзорно.

\section{Collectors (Java8)}
В стримах: куча объектов, обрабатываются потоковым образом, они ленивые; конвейер, по которому ползут элементы, операции бывают промежуточные(взяли элемент, обработали, вернули что-то, возможно другое) и терминальные(после них конфейер заканчивается). самые интересные операции: filter, map, flatMap.

\begin{itemize}
\item\textbf{Редукция}
	Пример -- сумма. Результат -- число. Начальное значение -- ноль.
	При получении  new элемента его н. прибавить к результату.
	Правило объединения двух частичных результатов в один.(нужно при распараллеливании)
	
3 операции-правила надо задавать: определение контецнера, к-ый б. содержать итоговый результат; добавление элемента к контейнеру; совмещение двух частично наполненных контейнеров.

Редукция основана на трёх операциях: 
\item Constructor: Supplier. Пример: \java"() -> new StringBuffer();" \java"StringBuffer::new;"
\item Accumulator: Fuction. \java"(StringBuffer sb, String s) -> sb.append(s);" \java"StringBuffer::append;" 2 аргумента, 1 функция: от первого параметра вызывается функция, все остальные параметры передаются ей в качестве аргументов
\item Combiner: Function. \java"(StringBuffer sb1, StringBuffer sb2) -> sb1.append(sb2);" \java"StringBuffer::append;"
\end{itemize}
\begin{exmp}
Person.
\begin{javacode}
//Collectors.joining(); -- синтаксический сахар, чтобы не писать вездесущий "new-append-append ><".
\end{javacode}
joining склеит все имеющееся без пробелов, с одним аргументом -- разделитель, второй -- приделывается в начало, третий -- приделывается в конец.
\end{exmp}
Интерфейссс \java"Collector<T, A, R>" параметризуется тремя типами
\java"Supplier<A> supplier"
\java"BiConsumer<A, T> accumulator"
\java"BinaryOperator<A> combiner"
\java"Function<A, R> finisher"
стрим типа Т, хотим результат типа R, для этого заводим контейнер типа А и с помощью финишёра преобразуем его в R как-то
Часто вместо А ставят ?, потому что он невидим пользователю, например. Наприемр, метод getCollector. Возвращаемый тип -- Collector<тип начала, пользователю\_неважно\_что, тип конечного результата>.


<Пример2>
Constructor: () -> new ArrayList(); \java"ArrayList::new;"
Acc: (list, el) -> list.add(el); \java"Collection::add;"
Comb: (list1, list2) -> list1.addAll(list2); \java"Collection::addAll;"
Это Collectors.toList();
Можно ArrayList заменить на HashSet -- получим список уникальных фамилий
Приветствуем Collectors.toSet();
А что-то они одинаковые -- Collectors.toCollection(TreeSet::new);
TreeSet -- отсортированы.
В Collectors есть 33 статических метода для всего, что обычно нужно. Познакомимся с groupingBy
Collectors.groupingBy(Person::getAge); Определяет, что из чего отображается во что.
\begin{javacode}
public static <T, K> //парам 2мя типами
Collector<T, ?, Map<K, List<T>>> groupingBy (
	Function<? super T, ? extends K> classifier
)
//по объекту получаем ключик джля него и под этим ключиком кладём в мапу
\end{javacode}

Но groupingBy умеет принимать больше, чем один параметр -- два параметра.%несущественно больше
Мы же можем хотеть не список, а что-то другое -- вот и второй параметр. Мап из возраста в, например, кол-во людей с таким возрастом.
Так что давайте передадим вторым параметром ещё одному коллектор. В ашем конкретном примере -- Collectors.counting(). Он превратит наши объекты ещё раз в стрим и из редуцирует во тчо-то новое.
Коллектор обрабатывает список элементов, соответствующих конкретному ключу.
%тыгыдык-тыгыдык-тыгыдам

Из-за .counting() у нас результат в лонге -- а если мы хотим int? Напишем Collectors.summingInt(e -> 1);//здесь 'e' -- это person[для колектора, обрабатывающего объекты с одинаковым ключом].

Если хотим не список Person'ов, а список только их имён
Collectors.mapping(Person::getLastName)

А теперь склеим все эти имена
Collectors.mapping(//1st downstream collector
Person::getLastName, 
Collectos.joining(", ") //2nd collector(ну, третий)
)

И самое главное: \textbf{всё это нагромождение работает ленивым образом, то есть каждый элемент пропускается через все возможные коллекторы сразу}.

В список фамилий, отсортированных по алфавиту.

\subsection{Задачка}
И-и-иии.. снова здравствуйте! Файл. Из него выдат 10 самых часто встречающихся там слов, отсортированных в порядке частоты встречаемости. Одной строчкой.
\begin{javacode}
Files.lines(Paths.get("input.txt")).
map(s -> s.split("\\s+")). //стрим массивов слов
flatMap(Arrays::stream). //стрим слов
filter(s -> !s.isEmpty). //отсеили пустые слова-строчки
collect(Collectors.groupingBy(Function.identity()), Collectors.counting()). //мапа из слов в частоту встреч. Надо теперь отсортировать
entrySet(). //сет из пар...
stream(). //... из которых мы сделали стрим
sorted((e2, e1) -> Long.compare(e1.getValue(), e2.getValue())). //отсортировали
limit(10). //оставили 10
//forEach(System.out::println) -- вывели и слова, и встречаемость
forEach(0 -> System.out.println(o.getKey()));//вывели только слова
\end{javacode}
Без стримов занимает не то чтобы меньше места. %Там фу-фу-фу, имхо.
А работает если и быстрее, то только чуть-чуть. Стримы не сильно быстрее, потому что много обёрток -- раз, наш пример довольно большой и существенное время на чтение уходит -- два, и -- три -- при добавлении параллельных стримов всем станет хорошо.
Основное преимущество стримов в том, что их проще осмыслить -- это раз. А два -- вот как раз параллельные стримы.
