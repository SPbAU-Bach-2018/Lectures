\chapter{Занятие 26.02.2016}
\section{Разбор задач}

\problem{10}
	Разбирал Игорь Лабутин.

	Мы умеем сводить NFA к детерминированному автомату "--- в новом
	автомате состояниями будут подмножества состояний исходного.
	Переход из подмножества "--- это мы из каждой вершины из подмножества
	делаем все переходы по соответствующей букве.
	Принимающими состояниями нового DFA будут те, в которых хотя бы одна вершина принимающая.

	Для co-NFA можно сделать то же самое, но принимающими состояниями нового DFA
	будут лишь те, что содержат только принимающие вершины.

	Таким образом, NFA, co-NFA и DFA описывают один и тот же класс языков.

\subsection{Задача 11 (простое условие)}\index{11@Задача 11!a@Простое условие}\label{prob11easy}
	Разбирал Дима Лапшин.

	Давайте рассмотрим стоки \t{1} и \t{10}.
	Заметим, что для первой строки FST должен выписать \t{1},
	а для второй должен выписать \t{01}.
	То есть после прочтения первой буквы \t{1} в одном случае FST
	должен выписать символ \t{0}, а в другом "--- символ \t{1}.
	FST детерминирован, получаем противоречие.

	Решение получилось слишком простым, возможно, в определении на каждом
	ребре должна быть написана не буква, а некоторое слово (возможно, пустое).
	На самом деле, это неважно: если у нас FST разворачивает все слова,
	то получается, что он на любом ребре должен выписывать ровно одну букву,
	иначе для какого-нибудь слова он выведет слово другой длины.
	В следующей серии планируется дать правильное определение, в котором задача будет сложнее.

\problem{12}
	Разбирала Оля Черникова.

	Требуемое семейство упоминали на лекции.
	Давайте скажем, что $E_n$ "--- это язык из слов длины хотя бы $n$,
	в котором $n$-й с конца символ есть \t{0}.
	Давайте построим NFA из $n+1$ состояния, который распознает $E_n$.
	Начальным будет состояние с номером $1$, терминальным "--- состояние $n+1$.
	Дальше добавляем следующие рёбра:
	\begin{itemize}
		\item Из вершины $i$ ($1 < i \le n$) добавляем ребро в вершину $(i+1)$ по символам \t{0}, \t{1}
		\item Из всех вершин добавляем ребро в вершину 2 по символу \t{0}
		\item Из вершин 1 и $n+1$ добавляем ребро в вершину 1 по символу \t{1}
	\end{itemize}
	Заметим, что этот автомат распознаёт все слова из языка $E_n$: действительно,
	если мы читаем слово длины $k$, то после прочтения первых $n-k$ символов мы оказались в каком-то состоянии.
	Прочитав следующий символ (\t{0}) мы окажемся в вершине 2.
	После этого прочитаем $n-1$ оставшийся символ, спускаясь в вершины $3, 4, \dots, n+1$.
	Также можно заметить, что этот автомат не распознаёт никакие другие слова.
	В самом деле: в состояние $n+1$ мы можем попасть единственным способом "--- из состояния $n$
	по произвольному символу.
	Аналогично для состояний $n, n-1, \dots, 3$.
	То есть последний $n-1$ переход был сделан по произвольному символу, начиная с состояния 2.
	А в состояние 2 все переходы ведут по нулю, что и требовалось.

	\begin{Rem}
		Замечание от семинариста: можно построить автомат попроще: у него $(n+1)$
		состояние, есть такие рёбра:
		\begin{itemize}
			\item Есть петля в вершине 1 по символам \t{0} и \t{1},
			\item Есть переход из 1 в вершину 2 по символу \t{0}
			\item Есть переход из вершины $i$ ($1 < i \le n$) в вершину $i+1$ по символам \t{0}, \t{1}.
		\end{itemize}
		Тогда у нас единственный способо принять строку "--- сделать сначала сколько-то ходов по петле,
		потом получить \t{0}, потом сделать $n-1$ переход по произвольному символу.
	\end{Rem}

	Теперь строим DFA.
	Скажем, что у него есть как минимум $2^n$ состояний "--- по числу возможных окончаний прочитанной строки
	(т.е. автомат помнит последние $n$ символов).
	Покажем, что все состояния различимы, тогда по теореме с лекции в любом DFA не меньше, чем $2^n$ состояний.
	Возьмём какие-нибудь два состояния: \t{a0b} и \t{a1c} (начинаются одинаково, потом отличаются в одном бите,
	а потом "--- какие угодно).
	Давайте заметим, что если мы возьмём строки \t{a0ba} и \t{a1ca}, то для них ответы разные,
	соответственно, исходные состояния были различимы.

\subproblem{13}{a}
	Разбирал Дима Розплохас и завалился.
	Потом подумал, пока разбирали задачу 4b и начал разбирать.

	Давайте рассмотрим следующее расширение DFA: на рёбрах теперь можно писать не только
	символы, но и пустые строки ($\epsilon$-переходы).
	Любой такой переделывается в нормальный DFA тем же способом, что и NFA "--- мы говорим,
	что состояние "--- это подмножество исходных состояний, и так далее.

	Пусть $L$ распознаётся DFA (мы имеем право считать, что это именно DFA, так как NFA, DFA, co-NFA эквивалентны).
	Тогда покажем, что $SUBSEQ(L)$ распознаётся DFA.
	Давайте возьмём исходный DFA и добавим следующие $\epsilon$-переходы:
	берём каждую вершину $v$ и добавляем из неё $\epsilon$-переходы во все достижимые вершины.
	Покажем, что наш новый автомат принимает все слова из $SUBSEQ(L)$
	(т.е. слова, являющиеся подпоследовательностями каких-то слов из $L$).
	В самом деле, пусть есть слово $x=u_0a_1u_2a_2\dots a_nu_n \in L$ и соответствующее
	ему $y = a_1\dots a_n \in SUBSEQ(L)$.
	Тогда $y$ распознается нашим автоматом.
	В самом деле, $x$ распознавался исходным автоматом.
	Тогда заметим, что $y$ распознаётся новым автоматом: при встрече $a_i$ он пройдёт по соответствующей букве,
	а между $a_i$ и $a_{i+1}$ он будет ходить по $\epsilon$-переходу, соответствующему пути $u_{i+1}$
	в старом автомате.

	Осталось показать, что никакие другие слова автомат не принимает.
	В самом деле, пусть автомат принял некоторое слово $y$.
	Тогда есть некоторый путь из начального состояния в терминальное, иногда мы идём по букве
	из $y$, а иногда <<срезаем>> путь по $\epsilon$-переходу.
	Давайте заменим каждый $\epsilon$-переход на честный путь из исходного автомата (соответствующий $\epsilon$-переходу),
	получим	слово $x$, оно принимается без $\epsilon$-переходов, т.е. оно принималось исходным автоматом, т.е. $x \in L$.
	А $y$ "--- подпоследовательность $x$, т.е. $y \in SUBSEQ(L)$, что и требовалось.

	\begin{Rem}
		Альтернативный автомат (без $\epsilon$-переходов): состояния те же,
		а ребро $a\to b$ по букве $c$ ставится, если в исходном был путь $a \to b$,
		заканчивающийся на букве $c$.
	\end{Rem}

\subproblem{13}{b}
	Разбирал Петя Смирнов и ответ "--- <<нет>>.
	Возьмём следующий язык $L$: $\epsilon$, \t{01}, \t{0101}, \t{010101} (т.е. $(\t{01})^*$).
	Теперь рассмотрим $PERMUTE(L)$, предположим, что есть распознающий автомат.
	Заметим, что в нём содержатся следующие слова $A_n$: $\t{\underbrace{00\dots00}_{n}\underbrace{11\dots11}_{n}}$.
	Давайте обозначим состояние, в которое попадает автомат после прочтения $n$ нулей за $S_n$.
	Так как автомат конечный, то для некоторых $n \neq m$ верно $S_n=S_m$.
	Тогда заметим, что слова $0^n1^n$ и $1^m1^n$ автомат не отличает, однако же первое лежит в $PERMUTE(L)$,
	а второе не лежит.

\subproblem{13}{c}
	Разбирал Никита Подгузов.
	Ответ "--- <<да>>.
	Пусть был исходный автомат $A$ и он принимал строчку $w_1w_2$ проходом
	из состояния $q_0$ в $t_i$, при этом строчка $w_1$ заканчивалась в состояни $q'$.
	Тогда мы хотим научиться принимать строки $w_2w_1$, т.е. в каком-то смысле добавить
	путь $q' \to t_i \to q_0 \to q'$.

	Давайте построим автомат $A'$ с квадратичным число состояний.
	Сначала раздвоим каждое терминальное состояние $A$ на два "--- $t_i'$ и $t_i''$.
	Каждое новое состояние "--- пара из двух состояний автомата $A$.
	Если в $A$ был переход $v \xrightarrow{c} v'$, то мы добавляем в $A'$ следующие рёбра:
	\begin{itemize}
		\item $(v, t'') \xrightarrow{c} (v', t_i'')$
		\item $(q_0, v) \xrightarrow{c} (q_0, v')$
	\end{itemize}
	Также добавим все рёбра следующего вида: $(v, t_i') \to (v, t_i'')$ по пустым строкам ($\epsilon$-переходы).
	Теперь давайте зафиксируем состояние $q'$.
	Скажем, что начальное состояние в автомате есть $(q_0, q')$, а терминальное "--- $(q', t_i'')$.
	Путь в автомате будет иметь следующий вид:
	\begin{itemize}
		\item
			Мы сначала сколько-то раз переходим только по рёбрам второго типа, меняя только второй элемент, набирем суффикс $w_2$.
		\item
			Потом переходим по ребру третьего типа (такой переход происходит максимум один раз), это $\epsilon$-переход.
		\item
			Потом сколько-то раз переходим по рёбрам первого типа, меняя только первый элемент, набирая префикс $w_1$.
	\end{itemize}
	Таким образом мы набрали слово $w_2w_1$.
	Но заметим, что в исходном автомате тогда принималось слово $w_1w_2$, что и требовалось.

	Т.о. мы построили автомат при фиксированном $q'$.
	Теперь давайте построим автоматы для каждого фиксированного $q'$ и потом объединим их все.

\section{Подсказки}
	В задаче 13 в пунктах e и i ответ "--- <<да>> (можно построить автомат), в пункт d ответ "--- <<нет>> (не всегда).
