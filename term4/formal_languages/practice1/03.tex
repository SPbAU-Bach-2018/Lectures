\chapter{Занятие 04.03.2016}
\section{Разбор задач}

Егора на этом занятии не было, все решения записаны со слов Пети Смирнова.

\subsection{Задача 11}
	\begin{Rem}
		Условие можно понимать несколькими способами: например, что FST может потенциально выписать 
		несколько строк, но они все равны между собой, и равны $w^R$.
		Предполагалось, что FST выписывает ровно одну строку, которая равна $w^R$.

		Понимание, при котором среди выписанных строк имеется хотя бы одна $w^R$ довольно бессмысленно:
		в таком случае можно построить FST, который выписывает вообще все строки.
	\end{Rem}

	\subsubsection{Решение от Оли}
		Разбирала Оля Черникова.

		Возьмём какое-нибудь большое $n$ такое, что существуют две различные строки $s$ и $t$ длины $n$ такие,
		что они переводят автомат в одно и то же множество текущих состояний (FST недетерминирован, поэтому надо смотреть именно на множество состояний).
		Такое $n$ существует, так как множеств состояний конечно, а с ростом $n$ строк становится сколь угодно много.

		FST эти строки не различает, давайте допишем к ним $\t{0}^n$ и запустим FST на получившихся строках.
		Заметим, что последние $n$ символов, выписанных FST, будут одинаковые, так как после прочтения $s$ и $t$
		мы оказались в одном и том же состоянии.
		Следовательно, FST ошибся при выписывании развёрнутых строк: так как у исходных было отличие в первых $n$
		символах, у получившихся должно быть отличие в последних $n$ символов.
		Тут мы пользуемся тем, что FST выписывает ровно одну строку.

	\subsubsection{Решение от семинариста}
		Краткая идея (\TODO):
		была сформулирована и использована лемма о накачке в частном виде для FST, потом в общем, потом она была на лекции.
		Применять можно так: возьмём строку $\t{0}^n\t{1}^n$.
		Мы в какой-то момент в начале из нулей попали в цикл из состояний FST, тогда его можно повторить, размножив нули.
		В строке станет больше нулей, чем единиц.
		А в выводе FST наоборот "--- размножатся единицы в начале вывода, то есть единиц станет больше.
		Противоречие.

\subsection{Задача 13e}\label{prob13e}
	Разбирала Оля Черникова.

	Нам требуется сделать автомат, который первые половинки всех слов из языка $L$.
	Пусть язык $L$ принимался автоматом $A$.
	Тогда в автомате для нового языка после прочтения слова $s$ состояние будет хранить следующее:
	\begin{enumerate}
		\item Текущее состояние в $A$, если бы мы скормили ему $s$
		\item Множество состояний $A$, из которых можно перейти в какое-нибудь терминальное состояние $A$, сделав ровно $|s|$ шагов.
	\end{enumerate}
	Терминальные состояния нового автомата "--- те, в которых маска содержит текущее состояние.

	Другими словами, идея такая: автомат читает начало слова из $L$ детерминированно (потому что ему явно приходят символы),
	а вторую половинку читает с конца, недетерминированно (не знает, какая она, но знает, где должна закончится).
	Терминальном становится то состояние, где половинки могут <<встретиться>>.

\subsection{Задача 13f}
	Разбирал Юра Ребрик.
	
	\begin{Def}
		Отображение $h \colon \Sigma^* \to \Sigma^* $ является гомоморфизмом, если для любых двух строк верно,
		что $h(ab)=h(a)h(b)$ (конкатенация строк).
	\end{Def}
	\begin{Rem}
		Вообще говоря, можно считать, что гомоморфизм задан лишь на буквах, а на всех остальных строчках продолжается по определению.
		То есть мы для каждой буквы знаем, в какую строчку (возможно, пустую) она перейдёт.
	\end{Rem}

	Идея такая: давайте возьмём автомат для $L$ и на каждом ребре напишем не буквы, а слова.
	Формально делаем так: берём ребро и, чтобы написать на нём слово $a_1a_2\dots a_k$, делим его на $k$ рёбер
	(добавив $k-1$ вспомогательную вершину), на каждом ребре уже написана буква.
	Если буква переходит в $\epsilon$, то делаем $\epsilon$-ребро.
	Получим какой-то недетерминированный автомат, его можно детерминизировать.

\subsection{Задача 13g}
	Разбирала Лиза Третьякова.
	
	Пусть был автомат $A$ для языка $L$.
	Тогда построим автомат для языка $h^{-1}(L)$ на тех же состояниях (и таких же терминальных), но с другими переходами.
	Из состояния $x$ по букве $c$ будет переход в то состояние, в которое перешёл бы автомат $A$, скорми
	мы ему строчку $h(c)$, начиная с состояния $x$.
	Если бы автомат не принял $h(c)$, то перехода из $x$ по $c$ нет.

\subsection{Задача 13h}
	Разбирал Петя Смирнов.

	По сути нам требуется построить автомат, принимающий все слова, к которым можно дописать что-то из $A$ так, чтобы
	получилось слово из $L$.
	Давайте возьмём автомат для $L$ и чисто формально изменим у него множество терминальных вершин:
	вершина $v$ станет терминальной тогда и только тогда, когда из неё существует путь по некоторому слову из $A$,
	заканчивающийся в вершине, которая раньше была терминальной.
	Нам не надо никаких явных алгоритмов: для каждой вершины есть свойство, которое либо истинно, либо ложно, из него сразу
	следует, будет ли она терминалом в новом автомате.

\subsection{Задача 13i}
	Разбирал Дима Розплохас.

	Решение чем-то похоже на решение задачи \hyperref[prob13e]{13e}.
	Мы явно построим автомат для нового языка через автомат $A$ для языка $L$.
	Для этого нам потребуется семейство таблиц $T_k$, которые мы будем определять так:
	таблица $T_k$ для каждого состояния $v$ автомата $A$ перечисляет все состояния,
	в которые можно попасть, пройдя из состояния $v$ по некоторой строке длины ровно $2^k$.
	Соответственно, $T_0$ просто хранит для каждого состояния $A$ все достижимые из него за один шаг,
	$T_1$ "--- за два шага, $T_2$ "--- за четыре шага и так далее.
	Мы можем начать строить эти таблицы и, так как их конечное число, то мы можем их всех явно выписать и как-нибудь
	занумеровать.
	Также каждая таблица $T_{k+1}$ однозначно строится по предыдущей $T_k$: надо просто из каждого состояния
	$v$ пройти по таблице $T_k$ один раз, получить множество, а дальше еще раз пройти по этой же таблице из каждого элемента этого множества.
	Так что если у нас была некоторая таблица $T_k$, от которой мы знаем лишь её структуру (но не номер $k$), то получить $T_{k+1}$ можно ровно одним способом.

	Теперь строим автомат для языка из условия задачи.
	Пусть мы прочитали строчку $s$, тогда автомат будет хранить внутри себя две вещи:
	\begin{enumerate}
		\item Где бы оказался автомат $A$, считай он строчку $s$
		\item Таблицу $T_{|s|}$, а на самом деле "--- её конечный номер.
	\end{enumerate}
	Когда автомат считывает очередной символ, он делает переход в автомате $A$ и пересчитывает таблицу.
	Терминальным состояние будет тогда и только тогда, когда из текущего состояния в $A$ можно достичь за $2^{|s|}$ шагов
	какое-нибудь терминальное в $A$.
	Итого, построили конечный (но очень большой) автомат для языка из задачи.
