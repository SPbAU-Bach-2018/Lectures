\chapter{Занятие 18.03.2016}
\section{Разбор задач}

\subproblem{22}{a}
	Этот пункт считается очевидным "--- его разбирали на лекции.
	Мы описываем палиндромы рекурсивно, наращивая палиндром с двух концов, начиная либо с пустой
	строки (для чётных палиндромов), либо с символа (для нечётных).
	\begin{align*}
		S &\to \epsilon \mid \t{a} \mid \t{b} \mid \t{a}\,S\,\t{a} \mid \t{b}\,S\,\t{b}
	\end{align*}

\subproblem{22}{b}
	Тоже считается очевидным.
	Его почти разобрали на лекции.
	Один вариант:
	\begin{align*}
		S &\to \epsilon \mid \t{(}\,S\,\t{)} \mid S\,S
	\end{align*}
	Другой вариант (однозначный):
	\begin{align*}
		S &\to \epsilon \mid \t{(}\,S\,\t{)}\,S
	\end{align*}

\subproblem{22}{c}
	Разбирала Надя Бугакова.

	Давайте назовём величину $|w|_a-|w|_b$ \textit{балансом} строки.
	В задаче требуется описать все строки с балансом ноль.
	Сюда точно относится пустая строка, а если строка непустая "--- разберём два случая,
	показав интересную структуру слов из языка:
	\begin{itemize}
		\item
			Пусть строка начинается на \t{a}, т.е. имеет вид $S=\t{a}S_1$.
			Тогда баланс $S_1$ равен $-1$.
			Давайте найдём кратчайший такой префикс $S_1$, что его баланс равен $-1$,
			такой точно найдётся (например, подходит вся $S_1$).
			Из-за минимальности он будет заканчиваться на \t{b},
			потому что иначе у более короткого префикса получится баланс $-2$, а из-за
			непрерывности баланса на префиксах будет существовать ещё более короткий префикс с балансом $-1$.

			Значит, $S_1=S_2\t{b}S_3$, причём баланс $S_2\t{b}$ равен $-1$.
			Значит, баланс $S_2$ равен нулю, т.е. $S_2$ лежит в нашем языке.
			Но тогда баланс $S_3$ тоже должен быть равен нулю, чтобы сошёлся суммарный баланс $S$.
			Итого, если $S$ начинается на \t{a}, то его можно представить в таком виде:
			\[ S = \t{a}S_2\t{b}S_3 \]
			При этом балансы строк $S_2$ и $S_3$ равны нулю.
		\item
			Аналогично, если строка начинается на \t{b}.
	\end{itemize}
	Получили рекурсивное определение, можно записать грамматику:
	\begin{align*}
		S &\to \epsilon \mid \t{a}\,S\,\t{b}\,S \mid \t{b}\,S\,\t{a}\,S
	\end{align*}

\subproblem{22}{d}
	Разбирал Егор Суворов.

	Разобьём наш язык на три, в каждом из которых требования $i \neq j$, $i \neq 2j$ будут заменены на более слабые.
	Потом просто объединим эти языки.
	\begin{enumerate}
		\item $L_1$: $i < j$
		\item $L_2$: $2j < i$
		\item $L_3$: $j < i < 2j$
	\end{enumerate}
	Каждый язык будем строить через рекурсивное определение слов из языка.
	Основная идея построения: на каждый символ \t{b} должно приходиться от нуля до двух символов \t{a},
	а сколько именно "--- зависит от языка, который мы строим.

	Строим язык $L_1$.
	Идеологически в этом языке на каждый символ \t{b} приходится не более одного символа \t{a},
	причём какому-то \t{b} должно не хватить \t{a}.
	Грамматика $G_1$:
	\begin{align*}
		L_1 &\to L_1'\, \t{b} \mid L_1 \, \t{b} \\
		L_1' &\to \epsilon \mid \t{a}\,L_1'\,\t{b}
	\end{align*}
	Дальше надо показать, что эта грамматика задаёт в точности $L_1$.
	Два включения:
	\begin{description}
		\item[$L(G_1) \subseteq L_1$:]
			Заметим, что все слова из $L_1$ гарантированно имеют вид $\t{a}^i\t{b}^j$.
			Также заметим, что нетерминал $L_1'$ задаёт слова вида $\t{a}^i\t{b}^i$, а потом
			нетерминал $L_1$ дописывает к таким словам положительное число $\t{b}$, то
			есть получаем слово, в котором $\t{b}$ больше чем $\t{a}$, что и надо.
		\item[$L_1 \subseteq L(G_1)$:]
			Возьмём произвольное слово из $L_1$.
			Так как в нём \t{b} больше, чем \t{a}, представим его в виде $\t{a}^i\t{b}^i\t{b}^k$ ($i, j \ge 0$, $k > 0$).
			Тогда очевидно, что он принимается грамматикой.
	\end{description}

	Строим язык $L_2$.
	Идеологически похоже: на каждый символ \t{b} должно приходиться ровно два символа \t{a},
	причём еще должны остаться незанятые \t{a}.
	Грамматика $G_2$:
	\begin{align*}
		L_2 &\to \t{a}\,L_2' \mid \t{a}\,L_2 \\
		L_2' &\to \epsilon \mid \t{a}\,\t{a}\,L_2'\,\t{b}
	\end{align*}
	\begin{description}
		\item[$L(G_2) \subseteq L_2$:]
			Нетерминал $L_2'$ задаёт слова, в которых $i = 2j$, а нетерминал $L_2$
			увеличивает $i$ на что-то положительное, так что всё хорошо.
		\item[$L_2 \subseteq L(G_2)$:]
			Возьмём произвольное слово из $L_2$.
			Теперь срежем у него с начала несколько букв \t{a} так, чтобы $i=2j$, скажем, что это сделал нетерминал $L_2$.
			Останемся со словом, в котором $i=2j$, а оно уже выводится из нетерминала $L_2'$.
	\end{description}

	Строим язык $L_3$.
	Тут условие посложнее: на каждый символ \t{b} приходится либо один символ \t{a}, либо два.
	При этом на какой-то символ \t{b} должна прийтись одна \t{a}, а на какой-то "--- два.
	Будем считать, что на самый правый \t{b} должно прийтись две \t{a}, а на самый левый "--- одна.
	\begin{align*}
		L_3 &\to \t{a}\,\t{a}\,L_3'\,\t{b} \\
		L_3' &\to \t{a}\,L_3'\,\t{b} \mid \t{a}\,\t{a}\,L_3'\,\t{b} \mid \t{a}\,\t{b}
	\end{align*}
	\begin{description}
		\item[$L(G_3) \subseteq L_3$:]
			$L_3'$ инциализируется со слова, в котором $i=j$, а дальше на каждом шаге увеличивает $i$
			на единицу или двойку, а $j$ "--- на единицу.
			Поэтому в словах $L_3'$ будет точно выполнено $j \le i \le 2j$, однако $i=2j$ достигнуться
			не может (так как внутренней \t{b} соответствует лишь одна \t{a}).

			А нетерминал $L_3$ форсирует, что $j < i$ "--- хотя бы одной \t{b} соответствует две \t{a}, а не одна.
		\item[$L_3 \subseteq L(G_3)$:]
			Возьмём произвольное слово из $L_3$.
			Так как $j < i < 2j$, то:
			\[ j \ge 0 \Ra i \ge 1 \Ra 2j \ge 2 \Ra j \ge 1 \Ra i \ge 2 \Ra 2j \ge 3 \Ra j \ge 2 \]
			Таким образом имеется хотя бы две \t{a} и хотя бы одна \t{b}, их нетерминал $L_3$ может смело откусить.
			Посмотрим, что получили:
			\begin{gather*}
				j < i < 2j \\
				j \le i - 1 \le 2j - 2 \\
				j - 1 < i - 1 \le 2(j - 1) \\
				j - 1 \le i - 2 < 2(j - 1)
			\end{gather*}
			То есть в получившемся слове верно $j \le i < 2j$.
			Отлично, давайте теперь покажем, что $L_3'$ его примет: пусть пока $j < i$ он откусывает слева \t{aa}, а справа "--- \t{b}.
			Тогда, так как $i < 2j$, в какой-то момент станет верно $j=i$, причём оставшееся слово будет непустое.
			Но тогда оно будет состоять из одинакового количества \t{a} и \t{b}, то есть его нетерминал $L_3'$ тоже прекрасно примет.
	\end{description}

\subproblem{22}{e}
	Разбирал Егор Суворов.

	Сначала "--- рассказ о том, как получить решение.
	Рассмотрим какое-нибудь слово из языка с некоторым $k_i=l$.
	Давайте его распилим на две части:
	\begin{align*}
		S &= \t{a}^{k_1}\t{b}\dots \t{a}^{k_i=l} \t{b} \dots \t{a}^{k_l} \t{b} \\
		S &= \underbrace{\t{a}^{k_1}\t{b}\dots \t{a}^{i-1}}_{S_1} \underbrace{\t{a}^{l-i+1} \t{b} \dots \t{a}^{k_l} \t{b}}_{S_2}
	\end{align*}
	Заметим, что в $S_1$ имеется ровно $i-1$ группа $\t{a}^*\t{b}$ (т.е. не учитывая последнюю группу \t{a}).
	А в $S_2$ имеется ровно $l-i+1$ групп $\t{a}^*\t{b}$ (включая первую группу из \t{a}).
	Значит, $S_1$ и $S_2$ в каком-то смысле независимы друг от друга и можно построить рекурсивное определение для слов такой структуры:
	\begin{align*}
		S_1 &\to \epsilon \mid \t{a}^*\,\t{b}\,S_1\t{a} \\
		S_2 &\to \t{ab} \mid \t{a}\,S_2\,\t{a}^*\t{b}
	\end{align*}

	В грамматике для $S_1$ мы начинаем с пустого слова, а дальше на каждом шаге можем слева приписать группу $\t{a}^*\t{b}$, а справа тогда
	должны показать, что у нас появилась новая группа, дописав символ \t{a}.

	В грамматике для $S_2$ аналогично: мы начинаем с единственной группы, содержащей количество групп (т.е. 1), а потом при дописывании очередной группы
	справа, должны отразить это в количестве \t{a} слева.

	Теперь осталось лишь сконкатенировать эти два слова:
	\[
		S \to S_1\, S_2
	\]
	По построению понятно, что любое слово из грамматики принадлежит языку, так как есть инварианты для $S_1$ и $S_2$, которые соблюдаются и которые
	при конкатенаици слов дают корректное слово языка.
	Но также понятно и в другую стороны: мы в начале рассуждений взяли произвольное слово $S$ из языка и показали, как его наша грамматика примет.

\subproblem{22}{f}
	\subsubsection{Неверное решение}
		Разбирала Надя Бугакова и завалилась.

		Возьмём строку $S$ из языка длины хотя бы 5.
		\begin{lemma}
			В $S$ обязательно где-то встречается подстрока \t{bb}.
		\end{lemma}
		\begin{proof}
			От противного: пусть нет подстроки \t{bb}.
			Пусть в $S$ имеется $k$ символов \t{a}.
			Тогда символов \t{b} не более $k+1$, иначе по принципу Дирихле какие-то два окажутся рядом.
			С другой стороны, их должно быть ровно $2k$ по условию, значит $k=1$.
			Получили строку длины три: \t{bab}, но мы брали $|S|\ge3$, противоречие.
		\end{proof}

		По лемме запишем строку как $X\t{bb}Y$.
		Покажем, что либо в $X\t{bb}$, либо в $\t{bb}Y$ есть подстрока из нашего языка
		(в которой \t{a} в два раза меньше, чем \t{b}).
		В этом месте захотелось сказать, что после того, как мы эту подстоку удалим,
		у нас слева и справа останутся тоже строки языка.
		Но это неправда: $\underbrace{\t{a}\textbf{\t{a}}}_{X}\textbf{\t{bb}}\underbrace{\t{bb}}_{Y}$
		(полужирным выделена удаляемая подстрока).

	\subsubsection{Верное решение}
		Разбирал Никита Подгузов.

		\begin{Def}
			Назовём величину $|w|_a - 2|w|_b$ \textit{балансом}.
		\end{Def}
		\begin{Rem}
			Символ \t{a} вносит в баланс $+1$, а символ \t{b} вносит $-2$.
		\end{Rem}
		Обозначим язык из задачи за $S \coloneq \{ |w|_a - 2|w|_b = 0 \}$, т.е. это слова с балансом ноль.
		Теперь введём два новых языка:
		\begin{itemize}
			\item $T \coloneq \{ |w|_a - 2|w|_b = 1 \}$ "--- слова с балансом $+1$
			\item $R \coloneq \{ |w|_a - 2|w|_b = -1 \}$ "--- слова с балансом $-1$.
		\end{itemize}
		Будем всё друг через друга выражать.
		
		Разбираемся с $S$:
		\begin{enumerate}
			\item
				Либо пустое слово.
			\item
				Если слово из $S$ начинается с \t{a}, то дальше должно идти что-то с балансом $-1$,
				то есть слово из $R$.
			\item
				Аналогично, если слово заканчивается на \t{a}
			\item
				Если слово и начинается, и заканчивается на \t{b}, то после первой \t{b} у нас
				баланс строго отрицателен (и равен $-2$), а перед последней "--- строго положителен
				(и равен $+2$).
				Заметим, что мы можем увеличивать баланс только на $+1$, таким образом у нас обязательно
				в середине строки найдётся место, где баланс равен нулю, там её можно распилить
				на две строки с балансом ноль.
		\end{enumerate}
		Разбираемся с $T$ (баланс всей строки равен $+1$):
		\begin{enumerate}
			\item
				Если начинается или заканчивается на \t{a}, то остаток имеет баланс ноль, т.е. слово из $S$.
			\item
				Если начинается и заканчивается на \t{b}, то после первой \t{b} у нас
				баланс равен $-2$, а перед последней равен $+3$.
				Значит, обязательно найдём точку, где баланс ноль.
				Тогда распили на две части: в левой баланс ноль, в правой баланс $+1$.
		\end{enumerate}
		Разбираемся с $R$ (баланс всей строки равен $-1$):
		\begin{enumerate}
			\item
				Если начинается или заканчивается на \t{b}, то баланс на оставшемся куске должен быть равен $+1$,
				т.е. осталось слово из $T$.
			\item
				Если начинается и заканчивается на \t{a}, то после первой \t{a} у нас
				баланс равен $+1$, а перед последней равен $-2$.
				Так как прыгать вниз мы умеем максимум на $-2$, то в какой-то момент баланс будет
				либо $0$, либо $-1$.
				Тогда можно распилить на две части: либо в одной баланс будет ноль, а в другой $-1$,
				либо наоборот.
		\end{enumerate}
		Можно формально записать грамматику:
		\begin{align*}
			S &\to \epsilon \mid \t{a}\,R \mid R\,\t{a} \mid S\,S \\
			T &\to \t{a}\,S \mid S\,\t{a} \mid S\,T \\
			R &\to \t{b}\,T \mid T\,\t{b} \mid S\,R \mid R\,S
		\end{align*}

		Доказать, что все слова, выводимые в грамматике, корректны, можно от противного: найдём слово
		минимальной длины, которое в языке лежит, а не должно.
		Посмотрим, по какому правилу оно было порождено из нескольких корректных слов меньшей длины,
		получим противоречие.

\subproblem{22}{g}
	Разбирала Надя Бугакова.

	Идея такая: мы отдельно разбёрем случай, когда одно слово является префиксом другого.
	Если же это не так, то $x$ и $y$ отличаются хотя бы в одной букве, все остальные буквы при этом произвольны.
	То есть нам необязательно искать самое левое различие.

	Начнём с интересного случая: пусть $x$ и $y$ отличаются в букве $i$, причём в $x$ на этом месте стоит \t{a}, а в $y$ "--- \t{b} (еще есть симметричный случай)
	\[
		\overbrace{\somealpha{i-1}\t{a}\somealpha{|x|-i}}^x\t{\#}\overbrace{\somealpha{i-1}\t{b}\somealpha{|y|-i}}^y \\
	\]
	Слова такого вида можно строить грамматикой в несколько этапов:
	\begin{enumerate}
		\item Сначала строим слово $\t{a}\somealpha{|x|-i}\t{\#}$ "--- это произвольная последовательность букв, завершённая \t{\#} и начинающаяся с \t{a}
		\item Потом дописываем слева и справа одинаковое количество произвольных букв: $\somealpha{i-1}$
		\item Потом дописываем справа \t{b} и произвольное число букв $\somealpha{|y|-i}$.
	\end{enumerate}
	Заметим, что такая грамматика будет строить только слова нужного вида: можно обозначить количество дописываний
	на каждом этапе переменной и убедиться, что какие бы значения переменных грамматика не выбрала, получится слово нужного вида.
	Формально можно записать такие правила вывода нетерминалов:
	\begin{align*}
		C &= \t{a} \mid \t{b} && \text{любой символ}\\
		X &= \epsilon \mid X\,C && \text{последовательность любых символов} \\
		X_{1,a} &= \t{a}\,X\,\t{\#} \\
		X_{2,a} &= X_{1,a} \mid C\,X_{2,a}\,C \\
		X_{3,ab} &= X_{2,a}\,\t{b}\,X \\
		X_{1,b} &= \t{b}\,X\,\t{\#} \\
		X_{2,b} &= X_{1,b} \mid C\,X_{2,b}\,C \\
		X_{3,ba} &= X_{2,b}\,\t{a}\,X \\
	\end{align*}

	Осталось разобраться со словами, одно из которых является префиксом другого.
	Можно построить грамматику даже для более широкого класса: $|x|\neq |y|$ "--- это сначала
	надо дописать вокруг \t{\#} одинаковое число символов с двух сторон, а потом с какой-то одной дописать
	положительное число:
	\begin{align*}
		E &= \# \mid C\,E\,C \\
		X' &= \t{a}\,X \mid \t{b}\,X && \text{это $X$ без пустой строки} \\
		NE &= X'\,E \mid E\,X'
	\end{align*}
	Завершаем грамматику:
	\[
		S = X_{3,ab} \mid X_{3,ba} \mid NE
	\]

\subproblem{15}{a}
	Разбирала Оля Черникова.

	В одну сторону мы уже доказывать умеем: если язык распознаётся DFA, то
	переделать DFA в 2DFA "--- дело нехитрое, просто строим машину Тьюринга,
	у которой внутреннее состояние "--- автомат.
	При чтении символа с ленты делает переход и всегда сдвигает головку вправо.

	Теперь возьмём какой-то конкретный 2DFA с названием $M$ (и соответствующий ему язык)
	и попробуем построить DFA, который принимает то же язык.
	В чём вообще возникает проблема?
	В том, что после чтения префикса 2DFA может захотеть уехать обратно и еще раз вглянуть
	на уже увиденные символы.
	Можно было бы попробовать зашить в состояние 2DFA все увиденные символы, но тогда оно
	будет неограничено расти, хочется хранить про прочитанный префикс не все символы,
	а лишь какую-то <<важную>> для дальнейшей работы информацию про него.

	Давайте возьмём строку $S_0$ и её префикс $S$, предположим, что $M$
	в процессе работы в какой-то момент <<выехал>> из $S$ и оказался в следующем за ним
	символе в состоянии $d$.
	Поймём, какая информация нужна $M$, чтобы обработать $S_0$.
	Если $M$ больше никогда не будет возвращаться в $S$, то только состояние $d$.
	А если же $M$ в какой-то момент вернётся в $S$ (а точнее "--- в последний символ $S$)
	в состоянии $d_1$, то дальше может произойти одно из трёх:
	\begin{enumerate}
		\item
			$M$, не выходя из $S$ второй раз, примет всю строку $S_0$
		\item
			$M$, не выходя из $S$ второй раз, отвергнет всю строку $S_0$
		\item
			$M$ выйдёт из $S$ второй раз, на этот раз "--- в состоянии $d'$.
	\end{enumerate}
	Давайте тогда заметим, что если бы $M$ знала, какой будет исход, то ей бы не потребовалось
	явно читать все символы $S$ по второму разу.

	Теперь кажется разумной идеей назвать характеристикой $S$ следующую информацию:
	если мы вернёмся в $S$ (а точнее "--- в последний символ $S$) в некотором состоянии $d_1$,
	то какое из трёх описанных выше событий произойлёт?
	Характеристика $S$ представляет собой табличку из $q$ строк, в $i$-й строке записан либо
	номер состояния (в котором $M$ выйдёт из префикса, зайдя туда в состоянии $i$), либо
	одно из двух специальных значений, сообщающих, что слово будет принято/отвергнуто.
	То есть всего возможных характеристик конечно, и их число зависит только от числа состояний в
	исходном $M$.

	Значит, теперь мы можем построить DFA "--- он будет хранить характеристику префикса и состояние 2DFA.
	Если 2DFA хочет пойти вправо "--- DFA идёт вправо и пересчитывает характеристику префикса,
	а если 2DFA хочет пойти влево "--- то, зная характеристику, DFA может мгновенно понять, что происходит:
	либо сразу принять/отвергнуть слово, либо прочитать следующий символ и сделать переход.

\problem{25}
	Разбирал Дима Розплохас.

	Давайте построим контекстно-свободную грамматику для $SUFFIX(L)$.
	В ней будут все старые терминалы, нетерминалы и правила, но мы также
	добавим для каждого нетерминала $X$ нетерминал $X'$, соответствующий $SUFFIX(X)$
	(т.е. суффиксам всех слов, которые можно получить из нетерминала $X$).
	После этого объявим нетерминал $S'$ стартовым.

	Строим правила для $X'$.
	Пусть было правило для $X$, например: $X \to c\,b\,D\,e\,F$.
	Будем стирать по одному символу, начиная слева (при этом если правая часть начала начинаться с нетерминала,
	к нему надо добавить штрих):
	\begin{center}
		\begin{tabular}{rclllll}
			\t{X} &\to& \t{c}&\t{b}&\t{D}&\t{e}&\t{F} \\
			\t{X} &\to&      &\t{b}&\t{D}&\t{e}&\t{F} \\
			\t{X} &\to&      &     &\t{D'}&\t{e}&\t{F} \\
			\t{X} &\to&      &     &      &\t{e}&\t{F} \\
			\t{X} &\to&      &     &      &     &\t{F'} \\
			\t{X} &\to&      &     &      &     &$\epsilon$ \\
		\end{tabular}
	\end{center}
	Формально это доказывается через дерево разбора: посмотрим на дерево разбора для слова,
	соответствующего $SUFFIX(L)$, а его можно легко достроить до дерева разбора для слова из $L$.

\subproblem{15}{e}
	Разбирала Оля Черникова.

	Наивное решение (заваленное в прошлый раз) могло бы работать так: мы считываем первое число на ленту,
	а потом проверяем, что каждое следующее есть предыдущее плюс один, и что в конце ничего нет.
	Это правильно, но потребляет много памяти на некорректных входах, например, когда записано только первое число.

	Поэтому будем делать умнее: наша машина Тьюринга будет не сразу пытаться проверять, что у нас идут подряд идущие числа,
	а по порядку увеличивать $k$ от единицы, пока получается.
	То есть сначала предполагаем, что $k=1$ и смотрим, является ли строка корректной для данного $k$
	(разрешая ведущие нули) "--- для этого потребуется $\O(k)$ памяти, чтобы хранить последние $k$ бит очередного числа.
	\begin{itemize}
		\item Если в какой-то момент нашли противоречие в последних $k$ битах (например, не хватает какого-то числа), то уже есть проблема.
		\item Если проблем такого рода не обнаружили, но нашли ведущие нули, то $k$ надо на единицу увеличить и запуститься заново "--- памяти точно хватит.
		\item А если всё выглядит хорошо для данного $k$, то надо еще проверить, что в конце строки нет никакого мусора.
	\end{itemize}

\section{Замечание про задачу 15}
	Мы доказали, что $DFA=DSpace[1]$.
	Если докажем 15c, то узнаем, что всё, что строго меньше $DSpace[\log \log n]$,
	схлопывается в $DFA$.
	Пример нерегулярного из $DSpace[\log \log n]$ мы привели.
	К сожалению, что происходит с языками с памятью между $\log \log n$ и $\log n$, никто не понимает.
