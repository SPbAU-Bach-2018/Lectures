\setauthor{Всеволод Степанов}

\chapter{Недетерминироавнные конечные автоматы с \texorpdfstring{$\epsilon$}{epsilon}-переходами (\texorpdfstring{$\epsilon$}{epsilon}-НКА, NFA-\texorpdfstring{$\epsilon$}{epsilon})} 
\section{Введение}
\begin{exmp}
Язык с прошлой лекции "--- все слова, на 10 месте с конца которых стоит нолик. 

Был большой детерминированный автомат из $2^{10}$ состояний, это много.

\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";

    node [shape = none] ""
    node [shape = circle] 0 1 2 3 4 5 6 7 8 9;
    node [shape = doublecircle] 10;
    "" -> 0;
    0 -> 0 [ label = "0, 1" ];
    0 -> 1 [ label = "0" ];
    1 -> 2 [ label = "0, 1" ];
    2 -> 3 [ label = "0, 1" ];
    3 -> 4 [ label = "0, 1" ];
    4 -> 5 [ label = "0, 1" ];
    5 -> 6 [ label = "0, 1" ];
    6 -> 7 [ label = "0, 1" ];
    7 -> 8 [ label = "0, 1" ];
    8 -> 9 [ label = "0, 1" ];
    9 -> 10 [ label = "0, 1" ];
}
\end{dot2tex}

Идея в том, что здесь у нас есть нулевая вершина, из которой есть два перехода по символу 0, мы будем выбирать каждый раз тот, что больше нравится.

Скажем, что слово принимается автоматом, если существует последовательность выбора переходов, приводящая нас в терминальную вершину.
Здесь мы просто первые много символов берем и пропускаям, циклясь в нулевой вершине, а хвостик из 10 символов берем и проходим, попадая в терминальную вершину.
\end{exmp}

\begin{exmp}
Чуть более сложный пример: объединим предыдущий язык со словами, длина которых делится на 3.

Тут нам, для удобства, понадобятся $\epsilon$-переходы: не переходим к следующему символу в строке, просто делаем переход из состояние в состояние.

\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";


    node [shape = none] ""
    node [shape = circle] "start" 0 1 2 3 4 5 6 7 8 9 12 13;
    node [shape = doublecircle] 10 11;
    "" -> "start";
    "start" -> 0 [label = "\\epsilon" ];
    "start" -> 11 [label = "\\epsilon" ];
    0 -> 0 [ label = "0, 1" ];
    0 -> 1 [ label = "0" ];
    1 -> 2 [ label = "0, 1" ];
    2 -> 3 [ label = "0, 1" ];
    3 -> 4 [ label = "0, 1" ];
    4 -> 5 [ label = "0, 1" ];
    5 -> 6 [ label = "0, 1" ];
    6 -> 7 [ label = "0, 1" ];
    7 -> 8 [ label = "0, 1" ];
    8 -> 9 [ label = "0, 1" ];                                      
    9 -> 10 [ label = "0, 1" ];
    11 -> 12 [ label = "0, 1" ];    
    12 -> 13 [ label = "0, 1" ];    
    13 -> 11 [ label = "0, 1" ];    
}
\end{dot2tex}

Мы заранее понимаем, будет ли длина слова в итоге делиться на три, если будет "--- идем в нижнюю часть автомата, иначе "--- в верхнюю.

Заметим, что если длина слова не делится на 3 и его 10 с конца символ не равен нулю, то, как бы мы ни пошли, в терминальное состояние мы в итоге не попадем.
\end{exmp}

Осталось это дело аккуратно формализовать, чем мы сейчас и займемся.

\begin{Def}
$\epsilon$-НКА = $(\Sigma, Q, Q_0, T, \Delta)$.

$Q$ "--- конечное множество состояний

$q_0 \in Q$ "--- стартовое состояние

$T \subset Q$ "--- множество терминальных вершин

$\Delta: Q \times (\Sigma \cup \{\epsilon\} \to 2^Q$ "--- функция переходов.
Эта функция берет и паре из состояния и текущего символа в строке (или $\epsilon$, то есть, мы его сейчас не считываем) сопоставляет множество состояний, куда мы можем по этому символу пойти.
Стоит отметить, что $\epsilon$-переходы у нас теперь обязательно есть, если же они не нарисованы, то они ведут в тупиковое состояние по договоренности, которая была у нас ранее.
\end{Def}

\begin{Def}
$E(q)$ "--- $\epsilon$-замыкание состояния $q$ "--- множество состояний, достижимых из $q$ только по $\epsilon$-переходам.
\end{Def}


\begin{Def}
Слово $a_1 \dots a_n$ приниманется $\epsilon$-НКА, если $\exists$ последовательность состояний $p_0, \dots, p_n$, такая что
$p_0 \in E(q_0)$, $p_n \in T$, $\forall i \in [1, n]: p_i \in E(\Delta(p_{i-1}, a_i))$.
\end{Def}

\section{Алгоритм приема слова \texorpdfstring{$\epsilon$}{epsilon}-НКА}
Теперь мы научились некоторые языки описывать достаточно компактными автоматами, но пока не очень понятно, как с ними работать "--- 
наивный подход дает нам экспоненциальное время работы (просто перебрать все возможные пути, соответствующие слову). Сейчас научимся это делать побыстрее.

Будем хранить $R$ "---  множество состояний, в которых может находиться $\epsilon$-НКА. 

Изначально $R = E(q_0)$ (важно, что не просто $\{q_0\}$!)

При прочтении символа $a: R' =  \bigcup\limits_{q \in R} E(\Delta(q, a))$.

Текущее слово принимается $\Lra R \cap T \neq \emptyset$.

Мы сейчас, по сути, описали алгоритм, который будет явно поддерживать это множество для текущего префикса строки (просто битсет по сути).

Попробуем оценить его время работы в худшем случае.
$|R| \leqslant |Q|$ каждую итерацию (для каждого префикса). 
Надо на каждой итерации посчитать количество переходов, которые мы совершаем.
Худший случай "--- $Q^2$ возможных переходов для каждой буквы 
(из каждого состояния можно по данной букве перейти во все остальные, и, более того, $\epsilon$-замыкание каждого состояния это все $Q$, если честно для каждого состояния каждый раз эти переходы считать, будет долго).
В итоге получилось $\O(nQ^3)$, что плохо.

Можно соптимизировать, запомнив для пары (состояние, буква) $E(\Delta(q, a))$ в виде битсета. 
Тогда мы сейчас улучшили в $Q$ раз асимптотику, так как для каждой пары (состояние, буква) нам не надо каждый раз явно по $\epsilon$ переходам проходить, мы это уже один раз сделали и используем.
А еще можно поделить на $\log |Q|$, применив четырех русских \dots

\begin{Rem}
На практике, однако, работает быстрее, так как маловероятно, что будут встречаться такие странные автоматы.
\end{Rem}

\begin{Rem}
Заметим, что подобную штуку для недетерминированной МТ уже не прокрутить, так как там нам, помимо состояния, важно еще, что написано на ленте, это уже нам даст дофига возможных конфигураций.
\end{Rem}


\section{Алгоритм детерминизации \texorpdfstring{$\epsilon$}{epsilon}-НКА}
Есть НКА $A = (\Sigma, Q, p_0, T, \Delta)$. 
Хотим взять и конструктивно построить ДКА $B = (\Sigma, Q', q_0', T', \delta)$, который будет ему эквивалентен.

$Q' = 2^Q$ "--- по сути, то же самое, что $R$ "--- кодирует подмножество состояний, в котором сейчас можем находиться.

$q_0' = E(q_0)$

$T' = \{p \subset Q: R\cap T \neq \emptyset\}$

$\delta(R, a) = \bigcup\limits_{q \in R} E(\Delta(q, a))$

По сути, мы сейчас взяли и формально перевели описанный алгоритм в соответствующий ему ДКА.

\begin{Rem}
На самом деле, далеко не все состояния нам на практике нужны, много чего можно выкинуть. Впрочем, никаких оценок на это дело давать не будут.

Можно просто явно не выписывать автомат, а просто обойти \t{dfs}-ом, получить все достижимое.

Можно еще взять и выбирать какой автомат использовать. 
НКА, конечно, хуже, чем ДКА, так как принимает слова гораздо медленнее. Но ДКА может быть большим. 
Поэтому попробуем детерминизировать НКА, если чувствуем, что слишком много вершин получается, то забиваем, и будем использовать НКА. 
Иначе "--- получили какой-то не слишком большой ДКА, который будет за $O(|w|)$ принимать слово вместо $O(|Q|^2|w|)$, что очень хорошо.
\end{Rem}


\section{Академические регулярные выражения (АРВ)}
Они появились раньше, чем обычные регулярные выражения. В обычных начинается всякий ад, когда начинаем использовать что-то в духе \textbackslash1
(это когда мы взяли, заматчили какое-то выражение, а потом хотим \textbf{его же} заматчить где-то в другом месте, в академической версии такого нет, там все очень просто.

\begin{tabular}{p{0.45\linewidth}|p{0.45\linewidth}}
$R$ & $L(R)$ "--- язык, принимаемый регулярным выражением $R$ \\
\hline
$\emptyset$ & $\emptyset$ \\
$\epsilon$ & $\{\epsilon\}$ \\
$a \in \Sigma$ & $\{a\}$ \\
$(R)$ & $L(R)$ \\
замыкание Клини: $R^*$ & $\{a_1 \dots a_n: n \in \N \cup \{0\}$, $a_i \in L(R)\} = (L(R))^*$ (то, что $n$ может быть нулем "--- важно!) \\
$R_1R_2$ & $\{ab: a \in L(R_1) \land b \in L(R_2)\}$ \\
$R_1 | R_2$ & $L(R_1) \cup L(R_2)$
\end{tabular}

Приоритет убывает сверху вниз.

\begin{Rem}
Операций не очень много (по сравнению с привычными нам регулярными выражениями), но математики любят строить что-то поменьше и покомпактнее, а потом уже на основе этого достраивать остальную функциональность.

Например, чем проще синтаксис, меньше правил, тем проще будет автомат.
\end{Rem}

\begin{exmp}
Рассмотрим пару простых примеров АРВ:

\begin{tabular}{p{0.45\linewidth} | p{0.45\linewidth}}
$R$ & $L(R)$ \\
\hline
$01$ & $\{01\}$ \\
$(0|1)^*$ & все слова из ноликов и единиц \\
$(0|11)^*$ & если есть группа подряд идущих единиц, то она четной длины
\end{tabular}
\end{exmp}

\begin{Def}
Язык $L$ называется регулярным, если $\exists \text{АРВ } R: L(R) = L$.
\end{Def}