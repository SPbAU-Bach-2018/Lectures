\setauthor{Всеволод Степанов}

\chapter{Недетерминироавнные конечные автоматы с \texorpdfstring{$\epsilon$}{epsilon}-переходами (\texorpdfstring{$\epsilon$}{epsilon}-НКА, NFA-\texorpdfstring{$\epsilon$}{epsilon})} 
\section{Введение}
Язык с прошлой лекции "--- все слова, на 10 месте с конца которых стоит нолик. Мы сказали, что можно построить большой ДКА из $2^{10}$ состояний, но это как-то много для такого, казалось бы, простого языка.
Тут к нам на помощь приходят НКА.

Идея НКА в следующем: давайте скажем, что из состояния по символу может идти не один переход, а сразу несколько, и, когда мы скармливаем слово автомату, мы будем выбирать такой переход, который хотим.
И будем говорить что слово автоматом принимается, если мы можем выбирать каждый раз переходы так, чтобы в итоге прийти в терминальное состояние. 

\begin{exmp}
Используя эту идею, для описанного выше языка можно построить следующий НКА:

\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";

    node [shape = none] ""
    node [shape = circle] 0 1 2 3 4 5 6 7 8 9;
    node [shape = doublecircle] 10;
    "" -> 0;
    0 -> 0 [ label = "0, 1" ];
    0 -> 1 [ label = "0" ];
    1 -> 2 [ label = "0, 1" ];
    2 -> 3 [ label = "0, 1" ];
    3 -> 4 [ label = "0, 1" ];
    4 -> 5 [ label = "0, 1" ];
    5 -> 6 [ label = "0, 1" ];
    6 -> 7 [ label = "0, 1" ];
    7 -> 8 [ label = "0, 1" ];
    8 -> 9 [ label = "0, 1" ];
    9 -> 10 [ label = "0, 1" ];
}
\end{dot2tex}

Посмотрим на него внимательно и покажем, что он принимает ровно этот язык. 
Пусть мы пропускали через автомат слово длины $n$ из языка.
Тогда скажем, что мы $n-10$ раз пройдем по петле из нулевого состояния в нулевое, а потом оставшиеся символы пройдем по цепочке до терминального состояния. 
Очевидно, что если слово принадлежало языку, то мы так сможем сделать.

В другую сторону: чтобы принять какое-то слово, мы должны взять и последние 10 символов пропустить через ``цепочку'' до терминального состояния, а первый переход в ней возможен только по нулю. 
Поэтому ничего лишнего мы точно принять не сможем.

Итого, мы построили автомат из всего лишь 11 вершин, что достаточно круто.
\end{exmp}

\begin{exmp}
Чуть более сложный пример: объединим предыдущий язык со словами, длина которых делится на 3.

Для того, чтобы построить автомат для этого языка, воспользуемся еще одной идеей "--- $\epsilon$-переходами.
Скажем, что на некоторых ребрах будет написан не символ из алфавита, а специальный символ $\epsilon \notin \Sigma$. 
Переход по $\epsilon$ отличается от перехода по символу тем, что его можно сделать всегда, при этом мы текущий символ в строке не считываем.

\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";


    node [shape = none] ""
    node [shape = circle] "start" 0 1 2 3 4 5 6 7 8 9 12 13;
    node [shape = doublecircle] 10 11;
    "" -> "start";
    "start" -> 0 [label = "\\epsilon" ];
    "start" -> 11 [label = "\\epsilon" ];
    0 -> 0 [ label = "0, 1" ];
    0 -> 1 [ label = "0" ];
    1 -> 2 [ label = "0, 1" ];
    2 -> 3 [ label = "0, 1" ];
    3 -> 4 [ label = "0, 1" ];
    4 -> 5 [ label = "0, 1" ];
    5 -> 6 [ label = "0, 1" ];
    6 -> 7 [ label = "0, 1" ];
    7 -> 8 [ label = "0, 1" ];
    8 -> 9 [ label = "0, 1" ];                                      
    9 -> 10 [ label = "0, 1" ];
    11 -> 12 [ label = "0, 1" ];    
    12 -> 13 [ label = "0, 1" ];    
    13 -> 11 [ label = "0, 1" ];    
}
\end{dot2tex}

Если мы хотим принять слово, длина которого делится на 3, то просто сделаем переход в состояние с номером 11, после чего будем бегать по циклу $11-12-13$. 
Иначе, пойдем в состояние с номером 0.

Несложно понять, что данный автомат примет ровно описанный язык.
\end{exmp}

Формализуем две идеи, описанные выше.
\begin{Def}
$\epsilon$-НКА = $(\Sigma, Q, Q_0, T, \Delta)$.

$Q$ "--- конечное множество состояний

$q_0 \in Q$ "--- стартовое состояние

$T \subset Q$ "--- множество терминальных вершин

$\Delta: Q \times (\Sigma \cup \{\epsilon\}) \to (2^Q \setminus \emptyset)$ "--- функция переходов.
Собственно, в этом и есть отличие $\epsilon$-НКА от ДКА: если у ДКА функция сопоставляла паре из состояния и символа ровно одно состояние, куда мы должны перейти, то здесь у нас есть множество (непустое) допустимых для перехода состояний.
А еще добавили специальный символ $\epsilon$.
\end{Def}

\begin{Def}
$E(q)$ "--- $\epsilon$-замыкание состояния $q$ "--- множество состояний, достижимых из $q$ только по $\epsilon$-переходам.
\end{Def}


\begin{Def}
Слово $a_1 \dots a_n$ приниманется $\epsilon$-НКА, если $\exists$ последовательность состояний $p_0, \dots, p_n$, такая что
$p_0 \in E(q_0)$, $p_n \in T$, $\forall i \in [1, n]: p_i \in E(\Delta(p_{i-1}, a_i))$.
\end{Def}

\section{Алгоритм приема слова \texorpdfstring{$\epsilon$}{epsilon}-НКА}
Мы научились описывать некоторые языки достатчно компактными автоматами, чего не умели делать раньше, но пока что не очень понятно как для произвольного слова понимать, принимается ли оно автоматом, или нет,
кроме как экспоненциального перебора всех возможных путей. Сейчас будет предложен хороший адекватный полиномиальный алгоритм, который обычно и используют на практике.

Будем прогонять по символу слово через автомат, в каждый момент времени поддерживаем $R$ "---  множество состояний, в которых может находиться $\epsilon$-НКА после принятия соответствующего суффикса и,
возможно, еще осуществления некоторого количества $\epsilon$-переходов. 

Изначально $R = E(q_0)$ (важно, что не просто $\{q_0\}$!)

При прочтении символа $a\colon R' =  \bigcup\limits_{q \in R} E(\Delta(q, a))$.

Текущее слово принимается $\Lra R \cap T \neq \emptyset$.

Это уже какой-то нормальный алгоритм, он работает за полином, оценим его время работы в худшем случае.
$|R| \leqslant |Q|$ каждую итерацию (для каждого префикса). 
Надо на каждой итерации посчитать количество переходов, которые мы совершаем.
Худший случай "--- $Q^2$ возможных переходов для каждой буквы 
(из каждого состояния можно по данной букве перейти во все остальные, и, более того, $\epsilon$-замыкание каждого состояния это все $Q$, если честно для каждого состояния каждый раз эти переходы считать, будет долго).
В итоге получилось $\O(nQ^3)$. Это, конечно, лучше экспоненты, но можно побыстрее.

Сейчас мы каждый раз зачем-то честно считаем переходы по символу, но их можно взять и один раз предподсчитать, запомнив для пары (состояние, буква) $E(\Delta(q, a))$ в виде битсета. 
Тем самым, мы улучшим асимптотику в $Q$ раз, так как для каждой пары (состояние, буква) нам не надо каждый раз проходить явно по $\epsilon$-переходим.

Итого, получили $\O(nQ^2)$. На самом деле, так как на практике внутри у нас будут битсеты, то получается $\O(nQ^2/w)$, где $w$ "--- длина машинного слова, например, 64.

Можно вообще поделить на $\log |Q|$, применив четырех русских, но в реальной жизни на не совсем больших автоматах это не очень то и нужно \dots

\begin{Rem}
На практике, однако, алгоритм работает быстрее, так как маловероятно, что из каждого состояния по каждой букве будет по $Q$ переходов.
\end{Rem}

\begin{Rem}
Заметим, что подобную штуку для недетерминированной МТ уже не прокрутить, так как там нам, помимо состояния, важно еще, что написано на ленте, это уже нам даст дофига возможных конфигураций.
\end{Rem}


\section{Алгоритм детерминизации \texorpdfstring{$\epsilon$}{epsilon}-НКА}
Есть НКА $A = (\Sigma, Q, p_0, T, \Delta)$. 
Хотим взять и конструктивно построить ДКА $B = (\Sigma, Q', q_0', T', \delta)$, который будет ему эквивалентен.

$Q' = 2^Q$ "--- по сути, то же самое, что $R$ "--- кодирует подмножество состояний, в котором сейчас можем находиться.

$q_0' = E(q_0)$

$T' = \{p \subset Q: R\cap T \neq \emptyset\}$

$\delta(R, a) = \bigcup\limits_{q \in R} E(\Delta(q, a))$

По сути, мы сейчас взяли и формально перевели описанный выше алгоритм в соответствующий ему ДКА.

\begin{Rem}
Заметим, что далеко не все состояния нам на практике нужны, много чего можно выкинуть. Впрочем, никаких оценок на это дело давать не будут.

Можно просто явно не выписывать автомат, а просто обойти \t{dfs}-ом, получить все достижимое.

Можно еще взять и выбирать какой автомат использовать. 
НКА, конечно, хуже, чем ДКА, так как принимает слова гораздо медленнее. Но ДКА может быть большим. 
Поэтому попробуем детерминизировать НКА, если чувствуем, что слишком много вершин получается, то забиваем, и будем использовать НКА. 
Иначе "--- получили какой-то не слишком большой ДКА, который будет за $O(|w|)$ принимать слово вместо $O(|Q|^2|w|)$, что очень хорошо.
\end{Rem}


\section{Академические регулярные выражения (АРВ)}
Они появились раньше, чем обычные регулярные выражения. В обычных начинается всякий ад, когда начинаем использовать что-то в духе \textbackslash1
(это когда мы взяли, заматчили какое-то выражение, а потом хотим \textbf{его же} заматчить где-то в другом месте, в академической версии такого нет, там все очень просто.

\begin{tabular}{p{0.45\linewidth}|p{0.45\linewidth}}
$R$ & $L(R)$ "--- язык, принимаемый регулярным выражением $R$ \\
\hline
$\emptyset$ & $\emptyset$ \\
$\epsilon$ & $\{\epsilon\}$ \\
$a \in \Sigma$ & $\{a\}$ \\
$(R)$ & $L(R)$ \\
замыкание Клини: $R^*$ & $\{a_1 \dots a_n: n \in \N \cup \{0\}$, $a_i \in L(R)\} = (L(R))^*$ (то, что $n$ может быть нулем "--- важно!) \\
$R_1R_2$ & $\{ab: a \in L(R_1) \land b \in L(R_2)\}$ \\
$R_1 | R_2$ & $L(R_1) \cup L(R_2)$
\end{tabular}

Приоритет убывает сверху вниз.

\begin{Rem}
Операций не очень много (по сравнению с привычными нам регулярными выражениями), но математики любят строить что-то поменьше и покомпактнее, а потом уже на основе этого достраивать остальную функциональность.

Например, чем проще синтаксис, меньше правил, тем проще будет автомат.
\end{Rem}

\begin{exmp}
Рассмотрим пару простых примеров АРВ:

\begin{tabular}{p{0.45\linewidth} | p{0.45\linewidth}}
$R$ & $L(R)$ \\
\hline
$01$ & $\{01\}$ \\
$(0|1)^*$ & все слова из ноликов и единиц \\
$(0|11)^*$ & если есть группа подряд идущих единиц, то она четной длины
\end{tabular}
\end{exmp}

\begin{Def}
Язык $L$ называется регулярным, если $\exists \text{АРВ } R: L(R) = L$.
\end{Def}