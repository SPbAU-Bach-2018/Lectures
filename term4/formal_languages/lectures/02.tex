\setauthor{Всеволод Степанов}

\section{Минимизация ДКА}

\begin{Def}
$C_L^R(x) = \{y \in \Sigma^*, xy \in L\}$ "--- правый контекст в языке $L$ слова $x$.
\end{Def}
\begin{exmp}
$C_{RUSSIAN}^R(``\text{сту}'') = $ \{л, лор, дент, к, \dots\} "--- множество всех возможных слов, которые можно приписать к ``сту'' так, чтобы в итоге получилось корректное слово из русского языка.
\end{exmp}
\begin{Rem}
Правые контексты могут пересекаться(например, правые контексты всех слов, принимаемых автоматом, содержат пустую строку)
\end{Rem}

Несложно понять, что $\hat \delta(q_0, x) = \hat \delta(q_0, y) \Ra C_{L(A)}^R(x) = C_{L(A)}^R(y)$: 
что бы мы не дописали к словам $x, y$, мы будем двигаться из одной и той же вершины, придем тоже в одну и ту же вершину.

Рассмотрим два слова $x, y$, посмотрим, что можно сказать в случае, когда их правые контексты не равны: $C_{L(A)}^R(x) \neq C_{L(A}^R(y) \Ra \exists z: xz \in L(A), yz \notin L(A)$.
Тогда $(\hat \delta(q_0, x), \hat \delta(q_0, y))$ "--- пара различимых вершин (просто по определению).

\begin{assertion}
$
    \begin{cases}
        C_{L(A)}^R(x) = C_{L(A)}^R(y) \\
        \hat \delta(q_0, x) \neq \hat \delta(q_0, y)
    \end{cases} \Ra $ состояния $x, y$ можно объединить в одно
\end{assertion}
\begin{proof}
Правые контексты равны следовательно, вершины являются неразличимыми. 
Тогда, по алгоритму минимизации автомата, их можно стянуть в одну вершину.
\end{proof}

\begin{theorem}
Количество вершин в минимальном ДКА будет в точности равно количеству различных правых контекстов в языке.
\end{theorem}
\begin{proof}
\begin{description}
\item[$\geqslant$]: различным правым контекстам должны сооветствовать разные состояния, так как они различимы

\item[$\leqslant$]: если есть два состояния с одинаковыми правыми контекстами, то их можно склеить.
\end{description}
\end{proof}

\begin{theorem}
Алгоритм минимизации ДКА строит минимальный автомат с точностью до изоморфизма.
\end{theorem}
\begin{proof}
Понятно, что мы построили минимальный автомат по размеру. Осталось лишь понять, что все остальные минимальные ему изоморфны.

Берем два минимальных автомата. У начальных вершин правые контексты совпадают "--- это просто множества всех принимаемых слов.

Теперь, пусть мы перешли из состояния с правым контекстом $C_L^R(x)$ по символу $c$, обязательно пришли в состояние с правым контекстом $C_L^R(xc)$, значит, изоморфизм действительно есть.
\end{proof}

\begin{theorem}
У $L$ конечное множество правых контекстов $\iff \exists$ ДКА, принимающий $L$
\end{theorem}
\begin{proof}
\begin{description}
\item[$\La$] минимизируем автомат, получили все различные правые контексты.

\item[$\Ra$] построим ДКА $A$. $\forall C_L^R(x)$ становится состоянием.

Начальное состояние $C_L^R(\epsilon)$

Состояние терминальное, если $\epsilon \in C_L^R(x)$

Переходы: $C_L^R(x)$ по $a \to C_L^R(xa)$. 
Надо понять, что получили корректный автомат, который примет ровно то, что нужно.

Корректность "--- из каждой вершины по каждому символу ровно один переход. 
Казалось бы, может получиться так, что переходов несколько: стоит понимать, что для разных слов $x, y$ может выполняться $C_L^R(x) = C_L^R(y)$, 
тогда вершины будут совпадать и мы как бы нарисуем два перехода по каждой букве.
Но если вершины совпадают, то переходы по одной и той же букве приведут нас в одну и ту же вершину, поэтому, на самом деле, эти несколько переходов "--- кратное ребро, которое можно сократить в обычное.

Несложно понять, что, перейдя из стартового состояния по слову $x$, мы попадем в состояние, соответствующее $C_L^R(x)$.
Тогда мы примем слово $x$ только в том случае, если $\epsilon \in C_L^R(x)$, что равносильно тому, что $x \in L$.                                                                                  
\end{description}
\end{proof}
\begin{exmp}
Несложно построить пример языка с бесконечным количеством правых контекстов. 

Можно взять язык ПСП. Рассмотрим $open_i = $ слово из $i$ открывающих скобочек, а $close_i$ "--- слово из $i$ закрывающих.

Рассмотрим тогда $C_L^R(open_i), i \in \{1, 2, \dots\}$. Все эти правые контексты будут различными, так как $close_i$ будет принадлежать только $C_L^R(open_i)$.
\end{exmp}


\section{Проверка эквивалентности автоматов}

\begin{Def}
Есть два ДКА $A, B$.

Рассмотрим пару состояний $(p \in A, q \in B)$. 
Будем говорить, что эта пара состояний различима, если $\exists w: (pw \in L(A) \oplus qw \in L(B))$ "---
найдется такое слово, что если по нему из этих двух состояний перейти, то ровно одно из двух итоговых состояний будет терминальным.
\end{Def}
\begin{Rem}
По сути, это определение абсолютно аналогично определению различимости состояний внутри одного автомата.
\end{Rem}

Тогда сделаем следующее:

Рассмотрим все пары состояний вида $(p \in A, q \in B)$.
Скажем, что пары вида $(p \in T(A), q \notin T(B)$ и $(p \notin T(A), q \in T(B)$, где $T(A)$ "--- терминальные состояния автомата $A$ "--- пары различимых состояний (подставим $\epsilon$ в определение).

А дальше "--- действия будут абсолютно аналогичны тому, что мы делали в алгоритме минимизации автомата, разницы никакой нет.

Эквивалентность $\iff$ пара из $(q_{0, A}, q_{0, B})$ "--- пара неразличимых состояний.

\section{Пересечение, объединение, разность автоматов}
$L_1 = L(A), L_2 = L(B)$
Рассмотрим языки $L_1 \cap L_2, L_1 \cup L_2, L_1 \setminus L_2, \Sigma^* \setminus L_1$. 
Хочется понять, что если существовали автоматы для $L_1, L_2$, то и для всех этих языков автоматы тоже будут существовать. 

По языку $L$ можно построить автомат $\Ra$ по его дополнению тоже можно (все терминальные вершины нетерминальными и наоборот).
С точки зрения правых контекстов: $C_{\overline{L}}^R(x) = \overline{C_L^R(x)}$. Конечность количества правых контекстов не изменилась, следовательно, существование автомата тоже не изменилось.

Автомат для $L_1 \cap L_2$ существует, так как $C_{L_1 \cap L_2}^R(x) = C_{L_1}^R(x) \cap C_{L_2}^R(x)$, оно тоже конечно. 
Однако, количество состояний в этом автомате может достигать $nm$, где $n, m$ "--- количества состояний в автоматах для $L_1, L_2$ соответственно.

\begin{Def}
Пусть было два ДКА: $(\Sigma, Q, q_0, T, \delta)$ и $(\Sigma, Q', q_0', T', \delta')$.

Их прямым произведением называют следующий автомат: $(\Sigma, Q \times Q', (q_0, q_0'), T \times T', \delta'')$, где $\delta''(p, q), a) = (\delta(p, a), \delta'(q, a))$.
\end{Def}
Несложно понять, что построенный таким образом автомат будет принимать ровно $L_1 \cap L_2$

Существование автомата для объединения языков тоже можно выразить через правые контексты, надо только $\cap$ заменить на $\cup$. 
А для того, чтобы построить явную конструкцию, надо взять прямое произведение автоматов, и сказать, что терминальные состояния это $(T \times Q') \cup (Q \times T')$.


Абсолютно те же слова говорим и про разность.
Конструкция такая же, терминальные состояния для $L_1 \setminus L_2$ "--- $T \times (Q' \setminus T')$


\section{Динамическое программирование по ДКА}
\begin{Rem}
Этой темы нет в книжке. Впрочем, нам все это и так должно быть знакомо, спасибо Серёже.
\end{Rem}

Общая идея следующая: у нас есть какой-то автомат, хочется на него внимательно посмотреть и понять какие-нибудь его свойства. 
Например, какие-нибудь характеристики слов, которые он принимает "--- слово минимальной длины, принимает ли он пустое слово, количество принимаемых слов длины $i$, и так далее.
Задачи могут быть какимие-то более сложными, но мы не будем сильно в это все углубляться.


Минимальное слово, которое принимает "--- \t{bfs} по состояниям.

Хотим посчитать количество слов в $L(A)$ длины $n$. Для этого нам сейчас надо будет написать динамику. 

Заведем табличку $a_{q, i}$ "--- количество слов $x: |x| = i, \hat \delta(q_0, x) = q$. 
Иными словами, сколько слов длины $i$ приводит нас в состояние $q$.

Эту штуку надо как-то считать. Начальные состояния при $i=0$ будут следующие:
$
    \begin{cases}
        a_{q, 0} = 0, q \neq q_0 \\
        a_{q_0, 0} = 1
    \end{cases} 
$

Переходы:

$a_{q, i} = \sum\limits_{p, с | \delta(p, c) = q} a_{p, i - 1}$. Важно, что суммируем еще и по символу: если из $p$ в $q$ было несколько переходов по разным буквам, то их все надо учесть.
  
Теперь это дело можно честно посчитать за $\O(n \Sigma \cdot i)$. Ответом для длины $i$ будет являться $\sum\limits_{q\in T} a_{q, i}$.

Однако, $i$ можно захотеть взять достаточно большим, тогда все будет работать достаточно долго. 

Запихнем все значения для $i - 1$ в вектор-столбец $A_{i-1}$. Хотим через него посчитать $A_i$ в терминах матриц. 
Для этого надо взять и выразить через умножение вектора на матрицу суммирование в переходе.

Несложно убедиться, что $A_i = M A_{i-1}$, где $M$ "--- матрица смежности автомата (с учетом кратности).
Тогда, $A_i = M^i A_0$, а в степень можно возводить достаточно быстро, получим итоговую асимптотику равную $\O(\log(i) \cdot n^3)$ 


Еще мы сейчас получили, что количество слов длины $n$ либо линейно, либо зависит от $n$ экспоненциально. 
\begin{Rem}
Это должно нам казаться интуитивно понятным, возможно, мы должны были это пройти (но не прошли) в курсе линейной алгебры, Миша так сходу не умеет этот факт объяснять.
\end{Rem}


Анонс следующей лекции:

Рассмотрим язык, состоящий из всех слов таких, что 10 с конца символ равен нулю, остальные "--- не важны. 
Несложно понять, что в минимальном автомате для этого языка будет около $2^10$ вершин "--- надо честно помнить все последние 10 символов, и ничего с этим не поделаешь.
Как-то многовато получается, а ведь это еще сравнительно простой язык, казалось бы.

На следующей лекции будем пытаться бороться с этим с помощью недетерминированных конечных автоматов.