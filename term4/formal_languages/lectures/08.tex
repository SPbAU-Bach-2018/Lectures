\setauthor{Всеволод Степанов}

\begin{theorem}
    Языки МП-автоматов = КС-языки
\end{theorem}
\begin{proof}
\begin{description}
    \item[МП-автомат $A$ $\to$ КС-грамматика $G$]

    Будем считать, что автомат принимал по пустому стеку (мы уже показывали, что не важно, как он принимает, но так нам будет удобнее).

    Для каждой буквы посмотрим на момент, когда мы ее положили на стек, и когда ее сняли с него. 
    Рассмотрим слово, которое нам <<помогло>> ее снять, то есть, на подстроку $w$, которую мы успели принять между этими двумя состояниями.
    Получаем какой-то язык слов, которые могут перевести автомат из одного состояния в другое, сняв ровно одну букву со стека.
    
    Зададим множество нетерминалов $N = Q \times \Gamma \times Q$.
    Будем обозначать нетерминал как $[qgp]$, это соответствует следующей тройке: (из какого состояния перешли, какой символ сняли со стека, в какое состояние перешли).
    Сделаем так, чтобы этот нетерминал выводил ровно те слова, которые могут перевести автомат $A$ из $q$ в $p$, снимая со стека $g$.

    Для каждого состояния $q$ рассмотрим все переходы из него вида $a, g/u$, где $u=u_1\dots u_n$ "--- какое-то слово, которое мы кладем на стек, в состояние $p$.
    Для каждой последовательности $r_1 \dots r_n, r_i \in Q$ создадим продукцию $[q g r_n] \to a[p u_1 r_1][r_1 u_2 r_2]\dots [r_{n-1} u_n r_n]$.

    Осталось добавить стартовый символ $S$. 
    Будут продукции вида $S \to [q_0z_0q_i] \forall q_i \in Q$ "--- $S$ соответствует ровно всем тем словам, которые берут и снимают со стека $z_0$, оставляя его пустым.

    Формально покажем, что принимаем ровно те слова, что надо. Просто индукция по построению не проходит "--- так как у нас продукции рекурсивные, могут циклиться.
    Но можно делать индукцию по количеству переходов в автомате при приеме слова, тогда все получится.
    Докажем, что любое слово, принимаемое автоматом, выводится из $S$.
    База понятна, если переход только один, то длина слова не больше единицы, при этом, каждый нетерминал гарантированно породит хотя бы один терминал. 
    Поэтому, было только применение продукции $S \to a \in \Sigma$. 

    Переход. Смотрим на самый первый переход из стартового состояния в автомате. 
    Мы перешли в строке по символу $a$, сняли $z_0$, добавили на стек какое-то слово $u=u_1\dots u_k$.
    Каждый из этих символов мы в какой-то момент со стека снимем, есть последовательность состояний $r_1 \dots r_k$, в которых это случится. 
    Тогда, по построению, есть продукция $S \to a [q_0 z_0 r_k] \to a c [q_0 u_1 r_1] \dots [r_{k-1} u_k r_k]$. 
    Рассмотрим теперь переход из $r_i$ в $r_{i+1}$, заметим, что его длина будет меньше количества переходов для приема всего слова, поэтому, по предположению индукции, 
    соответствующий ему нетерминал действительно выводит нужное слово.

    Аналогично докажем, что не принимаем ничего лишнего "--- то есть, любое слово, которое можно вывести из $S$, можно принять и автоматом $A$. 
    Только тут будет уже индукция по размеру вывода в КС-грамматике, делаем абсолютно тот же самый формализм.

    Стоит заметить, что, вообще говоря, получили экспоненциальную грамматику (от размера $u$). 
    Можно этого избежать, надо просто сказать, что у нас на стек будут добавляться короткие слова. 
    Будем класть не все слово целиком, а только две буквы "--- одну букву из слова, а другую "--- фиктивную, которую мы однозначно со стека снимем при следующем переходе.

    \item[КС-грамматика $G$ $\to$ МП-автомат $A$]
    Состояние у нас будет только одно, назовем его $q$.

    Зададим стековый алфавит: $\Gamma = N \cup \Sigma \cup \{z_0\}$, а просто алфавит будет совпадать с множеством терминалов.

    Функция перехода выглядит так: для каждой продукции $A \to \gamma \in (\Sigma \cup N)^*$ зададим следующий переход в автомате: $\delta(q, \epsilon, V) = \{q, \gamma\}$ "---
    просто взяли и положили на стек правую часть вывода (при этом его левый символ "--- вершина стека).
    И для терминалов еще добавим следующие переходы: $\delta(q, a, a) = \{q, \epsilon\}$ "--- просто снимаем терминал со стека, если именно он сейчас есть в принимаемом слове.
    Чтобы у нас хоть что-то принялось (мы будем принимать по пустому стеку) надо, чтобы можно было его опустошить "--- добавим переход $\delta(q, \epsilon, z_0) = \{q, \epsilon\}$.

    Интуитивное понимание того, что эта конструкция работает: есть какой-то левосторонний вывод (каждый раз берем и применяем продукцию к самому левому нетерминалу). 
    Скажем, что у нас в каждый момент есть какая-то строка из терминалов и нетерминалов, мы по ней идем слева направо, терминалы выкидываем, запоминая, что они лежат в слове, 
    как только доходим до нетерминала "--- применяем к нему какую-либо продукцию. 

    А это в точности то, что мы делаем со стеком "--- если мы применяем продукцию, то мы слева дописываем раскрытие нетерминала, а если мы выкидываем терминал, то мы проверяем, что этот символ
    действительно сейчас должен быть в слове.

    Можно все это дело доказать абсолютно формально так же, как и в предыдущей части, индукцией по длине левостороннего вывода и индукцией по количеству переходов в автомате.

    \TODO примерчик происходящего: $S \to 0A1 \to 00A1 \to 0011$. Стек будет выглядеть так: $S, 0A1, A1 ,0A1, A1, 11, 1, \epsilon$
\end{description}
\end{proof}          
\begin{conseq}
    Получили, что любой МП-автомат можно переделать в МП-автомат с одним состоянием (принимающией по пустому стеку).
\end{conseq}

\subsection{Детерминированные конечные автоматы с магазинной памятью (ДМП)}
Когда у нас были ДКА и НКА, то мы умели детерминизировать НКА "--- там было не очень много допустимых конфигураци., как минимум, конечное число.
А тут, к сожалению, такого нет "--- у нас конфигурация теперь представляет собой пару (состояние в автомате, строка на стеке). 
А на стеке у нас, в принципе, может быть строка абсолютно любого размера, то есть, конфигураций может быть бесконечное количество.

Поскольку ничего лучше какого-либо экспоненциального перебора не придумать, то имеет смысл рассматривать еще и детерминированные автоматы с магазинной памятью.
К сожалению, как мы покажем, они принимают несколько меньший класс языков.

\begin{Def}
МП-автомат называется детерминированным, если 
\begin{itemize}
    \item
        В $\delta$ для $(q \in Q, a \in \Sigma \cup \{\epsilon\}, g \in \Gamma$ есть переход ровно в одну пару $(p \in Q, \gamma \in \Gamma^*)$.
        $\delta\colon Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \to Q \times \Gamma^*$.
    \item
        Если есть переход $(q, a \in \Sigma, g) \to ()$, то нет перехода $(q, \epsilon, g) \to ()$ "--- либо есть переходы по обычным символам, или только по $\epsilon$.
\end{itemize}
\end{Def}

\begin{Def}
    $L$ "--- префиксный язык, если $\nexists w_1, w_2 \in L$: $w_1$ "--- префикс $w_2$.
\end{Def}

В отличие от МП-автоматов, у ДМП-автоматов прием по пустому стеку и по терминальному состоянию это не одно и то же, сейчас это покажем.

\begin{theorem}
Язык $L$ принимается ДМП автоматом по пустому стеку $\Leftrightarrow$ $L$ - префиксный и принимается ДМП-автоматом по терминальному состоянию
\end{theorem}
\begin{proof}
\begin{description}
    \item[$\Rightarrow$]

Пусть есть слово $w \in L$, при этом еще существует непустое слово $u$ такое, что $wu \in L$.
Получаем противоречие, так как, когда мы примем префикс $w$ слова $wu$, у нас будет пустой стек и мы закончим работу.
Из всех состояний нашего автомата надо добавить переход $\epsilon, z_1/z_1$ в новое, терминальное, состояние. 
Тут мы, как и на прошлой лекции, еще добавили новое стартовое состояние и новый символ $z_1$, из нового начального состояния в старое есть переход $\epsilon, z_0/z_0z_1$.

\item[$\Leftarrow$]
$A$ "--- ДМП-автомат, принимающий по терминальному состоянию префиксный язык $L(A)$.

Это значит, что при приеме любого слова мы только один раз бываем в терминальном состоянии "--- иначе можно принять еще и его префикс.
На самом деле, это не правда, можем прийти в терминальное состояние, потом сделать $\epsilon$-переход, попасть снова в терминальное состояние. 
Но для дальнейшего перехода это совсем не важно.

Все переходы, которые были из терминальных состояний, удаляем (потому что они при приеме слова из языка все равно не использовались), добавляем петли $\epsilon, \forall/\epsilon$

Есть еще следующая проблема: могли в исходном автомате слово не принять, но попасть в какое-то состояние, имея пустой стек. 
Чтобы это слово не принялось в новом автомате, нужно, как обычно, чтобы было <<двойное дно>> "--- опять новое начальное состояние, символ $z_1$ в самом низу стека, который снимется в самом конце.
\end{description}
\end{proof}

\begin{theorem}
Языки, принимаемые ДМП-автоматами по терминальным состояниям, строго вложены в КС-языки, а регулярные строго вложены в ДМП-автоматы, принимающие по терминальным состояниям.
\end{theorem}
\begin{proof}
    \begin{description}
Нестрогие вложенности очевидны: к ДКА для регулярного языка легко приделать стек "--- просто убираем $z_0$ и кладем его обратно.
Вторая нестрогая вложенность тоже очевидна "--- ДМП это частный случай МП, которые в точности равны КС-языкам.

Надо теперь доказать, что классы не равны.

\item[Регулярные $\neq$ ДМП-автоматам]

$L = \{0^n10^n\}$
Этот язык не регулярный. Для доказательства используем лемму о накачке. Зафиксировали $n \in \N$, возьмем слово $w = 0^n10^n$, для любого его подходящего разбиения на три части лемма о накачке ломается.

А вот ДМП-автомат для этого языка есть "--- просто кладем нолики на стек, пока не придет единичка, а потом достаем их обратно. 
Кончился стек "--- переходим в терминальное состояние.

\item[ДМП-автоматы $neq$ КС-языки]
Для неформального доказательства неравенства можно взять язык $ww^R, w \in \Sigma^*$.
Говорим, что сначала мы должны класть на стек, а потом доставать, чтобы сравнивать с тем, что лежит в слове.
Но при этом не очень понятно, в какой момент, собственно, прекращать все класть на стек.
И как это формализовать "--- не очень понятно.

Для формального доказательства рассмотрим язык $L = \{0^n1^n\} \cup \{0^n 1^{2n}\}$.
Покажем, что этот язык не принадлежит ДМП-автоматам, принимающим по терминальному состояню.
Делать это будем от противного, предположим, что нашелся такой автомат.

У него есть терминальные состояния, принимающие $0^n1^n$ и $0^n1^{2n}$.
Сделаем копию этого автомата (убирая начальность у начального состояния), добавим $\epsilon$-переходы из терминальных состояний исходного в соответствующие терминальные состояния копии.
Во всех тех местах, где в копии в переходах есть единички, заменим их на двойки.
\TODO картинка!

Докажем, что этот автомат будет принимать язык $\{0^n1^n\} \cup \{0^n1^{2n}\} \cup \{0^n1^n2^n\}$.
Интуитивно это кажется более-менее понятным (как только появится картинка), но формально это надо объяснить.

Пусть $w$ принимается автоматом. Если не было $\epsilon$-перехода в копию, то оно принимается исходным автоматом, то есть, лежит в $\{0^n1^n\} \cup \{0^n1^{2n}\}\}$.

Если $\epsilon$-переход был, то уберем его, перенесем все переходы из копии в исходный автомат (в смысле что если шли по копии какого-то ребра, то скажем, что пойдем по его оригиналу), 
получили какое-то слово $u$ из ноликов и единичек.
Был какой-то префикс $p$ слова, который мы приняли перед тем, как был $\epsilon$-переход в копию.
Этот префикс равен либо $0^n1^n$, или $0^n1^{2n}$ (потому что у нас переходы в копию только из терминальных состояний).
В первом случае $u$ это либо $0^n1^n$, тогда $w = 0^n1^n$, либо $u=0^n1^{2n}$, тогда $w = 0^n1^n2^n$.
Во втором случае $u = 0^n1^{2n}, w = 0^n1^2n$. 

Это мы формально показали, что принимается не более чем этот язык. Несложно понять, что каждое слово из этого языка принимается (из построения).

Заметим, что $\{0^n1^n2^n\}$ не КС-язык (а, значит, и $\{0^n1^n\} \cup \{0^n1^{2n}\} \cup \{0^n1^n2^n\}$ тоже)
Пользуемся леммой о накачке. Зафиксировали $n$, взяли слово $0^n1^n2^n$. 
Центральная часть разбиения не могла одновременно захватить все три цифры, поэтому, если мы ее повторим несколько раз, то получим слово не из языка, противоречие.

Итого, мы взяли ДМП-автомат, получили, что он принимает то, что не принимает КС-язык, при этом мы знаем, что есть вложенность.
Противоречие
    \end{description}
\end{proof}
