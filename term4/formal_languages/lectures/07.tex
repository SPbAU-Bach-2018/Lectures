\setauthor{Всеволод Степанов}

\subsection{Лемма о накачке для КС-языков}
Лемма о накачке для контекстно-свободных языков.

Это будет снова сильное утверждение, которое позволит для некоторых языков
доказеть неконтекстно-свободность.

\begin{lemma}
    Пусть $L$ "--- контекстно-свободный язык.
    Тогда есть такое натуральное $n\ge 1$, что для любого слова $w \in L$ длины хотя бы $n$
    существует его разбиение $w=uvxyz$ такое, что:
    \begin{gather*}
        |v| + |x| + |y| \le n \quad \text{<<середина>> достаточно короткая}\\
        |v| + |y| \le n \quad \text{<<середина>> отделена непустыми <<скобочками>>}\\
        \forall i \ge 0 \colon uv^ixy^iz \in L \quad \text{<<скобочки>> можно повторять много раз или убрать}
    \end{gather*}
\end{lemma}
\begin{Rem}
    Бесконечность языка неважна: если язык конечен, просто возьмём $n=1+\max_{w\in L} |w|$
    и получим квантор $\forall w$ по пустому множеству.
\end{Rem}
\begin{Rem}
    Формулировка довольно похожа на формулировку леммы для регулярных языков, но отличаются детали.
\end{Rem}
\begin{proof}
    Раз $L$ "--- контекстно-свободный, то есть контекстно-свободная грамматика $G$ в нормальной
    форме Хомского, причём $L(G) = L \setminus \{ \epsilon \}$.
    Наличие или отсутствие пустого слова никак не влияет на лемму.
    Выберем в условии леммы $n=2^{|N|}$, где $N$ "--- множество нетерминальных символов в $G$.
    Теперь зафиксируем произвольное слово $w \in L$ такое, что $|w| \ge n$.
    Рассмотрим дерево разбора $T$ слова $w$ в грамматике $G$.
    Заметим, что так как $|N|\ge 1$, то $n \ge 2$, стало быть, корень $T$ не может перейти в терминал сразу,
    он сначала перейдёт в два нетерминала.

    Нам надо выяснить, как связана высота дерева разбора (число рёбер вдоль масимального пути в дереве
    от корня к листам) с числом листьев (т.е. с длиной слова).
    \begin{assertion}
        Если высота дерева равна $h$, то листьев не более $2^{h-1}$
        (нам еще надо каждый нетерминал превратить в терминал).
    \end{assertion}
    \begin{proof}
        По индукции. База для $h = 1$ очевидна "--- мы сразу превращаем нетерминал в терминал, так как всего лишь одно ребро в дереве.

        Теперь смотрим на корень. Его либо превратили в терминал сразу же, тогда крона состоит из одной вершины, либо его заменили на два нетерминала (потому что нормальная форма Хомского). 
        При этом, этим нетерминалам соответствуют деревья высоты не более $h - 1$, применим предположение индукции, сложим, получим то, что надо.
    \end{proof}
    Так как у нас длина слова (то есть, крона), имеет размер $2^{|N|}$, то высота дерева хотя бы $|N| + 1$.
    Рассмотрим путь до самой глубокой вершины, на нем есть хотя бы $|N| + 1$ нетерминальная.
    Значит, на этом пути есть хотя бы два одинаковых нетерминала (по принципу Дирихле), из всех пар повторяющихся выберем пару с наибольшей глубиной верхнего из них (то есть, самую близкую к листу).

    Посмотрим на дерево разбора, оно естественным образом разбивается этими двумя вершинами на 5 частей, как на картинке:
    \cimg{CS_nakachka.PNG}{0.5}

    Скажем, что эти 5 частей это в точности 5 частей из леммы и поймем что все сходится.

    Мы знаем, что $A \xLongrightarrow{*} x$, $A \xLongrightarrow{*} vAy$, поэтому, можно записать
    $S \xLongrightarrow{*} uAz \xLongrightarrow{*} uvAyz \xLongrightarrow{*} \dots \xLongrightarrow{*} uv^iAy^iz \xLongrightarrow{*} uv^ixy^iz$.

    Осталось лишь понять, что $vxy \leq 2^{|N|}$. То есть, надо показать, что крона дерева с корнем в верхей вершине $A$ имеют длину не более чем $2^{|N|}$.

    Пусть это не так. Тогда есть путь от верхней $A$ вниз длины хотя бы $|N| + 1$, там есть повтор, противоречие с тем, что мы взяли пару с самой глубокой верхней вершиной.
\end{proof}

\begin{exmp}
$L = \{0^n1^n2^n\}$. Возьмем и с помощью леммы докажем, что он не КС-свободный.

Зафиксируем $n \in \N$, возьмем $w = 0^n1^n2^n$. Его как-то разбили на $u, v, x, y, z$. 
Заметим, что $vy$ не может одновременно содержать и 0 и 2, так как иначе длина будет слишком большой.
Возьмем $i = 2$. Не умаляя общности, будем считать, что 0 не вошел в $vy$. Тогда у нас нулей осталось $n$, а единичек и двоек у нас хотя бы $n + 2$, сломали.
\end{exmp}

\begin{exmp}
Язык тандемов: $L = \{ww, w \in \Sigma^*\}$. Сломаем лемму.

Зафиксировали $n \in \N$, возьмем $w = 0^n1^n0^n1^n$. Нам это слово как-то разделили на $u, v, x, y, z$. 
Хотим предъявить какое-то $i$, которое все сломает. Есть два варианта: либо $vxy$ внутри блока нулей/единиц, либо залез и туда и туда.
В первом случае понятно, что можно несколько раз продублировать и просто количество нулей не совпадет с количеством единиц.
Во втором случае тоже все хорошо: есть блок, который целиком не лежит в $vxy$, его длина не изменится, а длина остальных увеличится.
\end{exmp}
\begin{conseq}
$L_1 = \{0^n1^n2^m\}$, $L_2 = \{0^m1^n2^n\}$.

Несложно убедиться, что оба языка -- КС-языки, просто написав для них соответствующие продукции.
Для первого языка, например, можно записать: $\\
S \to A2\\
A \to A2\\
A \to B\\
B \to 0B1\\
B \to \epsilon$

Но $L = L_1 \cap L_2 = \{0^n1^n2^n\}$ не является КС-языком.

То есть, пересекать КС-языки, в отличие от регулярных, не всегда получается. А вот объединять все равно можно.
\end{conseq}

\subsection{Недетерминированные конечные автоматы с магазинной памятью}
\begin{Rem}
Аббревиатура: МП-автомат (по умолчанию считаем, что недетерминированный). МПД-автомат "--- если детерминированный.
\end{Rem}
\begin{Rem}
Недетерминированный с $\epsilon$-переходами.
\end{Rem}
Магазинная память "--- на самом деле стек. Магазин "--- имеется в виду магазин у огнестрельного оружия.

\begin{Def}
МП-автомат: $A = (\Sigma, \Gamma, Q, q_0, T, z_0, \delta)$.

$\Sigma$ "--- алфавит, $\Gamma$ "--- стековый алфавит.

$Q$ "--- множество состояний, $q_0 \in Q$ "--- стартовое состояние, $T \subset Q$ "--- множество терминальных состояний.

$z_0 \in \Gamma$ "--- нулевой символ

$\delta \colon Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \to 2^{Q \times \Gamma^*}$ "--- функция перехода. 
По состоянию, символу в строке (или $\epsilon$), а так же по вершине стека (ее мы при переходе сотрем) выдаем множество допустимых переходов.
Переход "--- пара из нового состояния и строки, которую пишем на стек. 
Строка может быть пустой "--- просто достали символ со стека, если не хотим ничего со стека стирать "--- просто делаем строку длины 1 с символом, который только что стерли.
\end{Def}
\begin{Rem}
Обычно стек записывают в виде строчки, при этом считают, что вершина стека находится слева.
\end{Rem}
\begin{Def}
Моментальное описание "--- тройка $(q, w, s)$, где $q$ -- текущее состояние, $w$ "--- непрочитанная часть входного слова, $s$ "--- содержимое стека
\end{Def}

\begin{Def}
Рассмотрим два МО, имеющих следующий вид: $(q, aw, is)$ и $(p, w, \alpha s)$, $\alpha \in \Gamma^*, a \in (\Sigma \cup \{\epsilon\}$.
Говорят, что $(q, aw, is) \vdash (p, w, \alpha s)$ (читается <<состояние переходит за один шаг в>>,  если в $\delta$ есть элемент $(q, a, i) \to (p, \alpha)$.
\end{Def}

\begin{Def}
Аналогично, определяют переход за несколько шагов. 
Пусть есть два МО $M_1, M_2$, тогда говорят, что $M_1 \letvdash{*} M_2$ если есть последовательность МО $N_1 \dots N_k$ такая что ... $M_1 \vdash N_1, N_1 \vdash N_2 \dots N_{k-1} \vdash N_k, N_k \vdash M_2$.
\end{Def}
\begin{Def}
МП-автомат $A$ принимает слово $w$ по терминальному состоянию, если $\exists q \in T, s \in \Gamma^* \colon (q_0, w, z_0) \letvdash{*} (q, \epsilon, s)$
\end{Def}

Когда рисуют такой автомат, на ребре пишут $a, i/\alpha$ "--- по символу $a$ и символу $i$ на вершине стека перешли куда-то, на стек записали $\alpha$.
\begin{exmp}
$L = \{ww^R \colon w \in \Sigma^*\}$.

$\Sigma = \{0, 1\}, \Gamma= \{0, 1, z_0\}$.

\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";

    node [shape = none] "" 
    node [shape = circle] 0 1;
    node [shape = doublecircle] 2;
    "" -> 0 [label=""];
    0 -> 0 [label="0,z_0/0z_0 ; 1,z_0/1z_0;0,0/00;1,0/10;0,1/01;1,1/11"];
    0 -> 1 [label="\\epsilon,1/1; \\epsilon,0/0 ;\\epsilon, z_0/z_0"]; 
    1 -> 1 [label="0,0/\\epsilon ; 1,1/\\epsilon"];
    1 -> 2 [label="\\epsilon,z_0/\\epsilon"];
}

\end{dot2tex}

\textit{Автор конспекта приносит извинения за ужасные метки на ребрах, он не смог за адекватное время сделать красиво. Каждое ребро "--- на самом деле мультиребро, точка с запятой разделяет переходы.
Возможно, когда-нибудь это станет красивее}

Выглядит ужасно и формально, ничего не поделаешь. 
Словами: мы хотим сначала все пихать на стек, потом доставать с него, при этом требование "--- чтобы то что достаем со стека совпадало с тем, что сейчас в строке.

Недетерминированность тут явно нужна, так как непонятно, в какой момент перестать класть на стек.
\end{exmp}

\begin{Def}
МП-автомат принимает слово $w$ по пустому магазину, если $\exists q \in Q\colon (q_0, w, z_0) \letvdash{*} (q, \epsilon, \epsilon)$.
\end{Def}
\begin{Rem}
В таком способе принятия из определения исключают $T$, так как не нужно.
\end{Rem}                                                              
\begin{exmp}
$L = \{ww^R \colon w \in \Sigma^*\}$.

$\Sigma = \{0, 1\}, \Gamma= \{0, 1, z_0\}$.

\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";

    node [shape = none] "" 
    node [shape = circle] 0 1;
    "" -> 0 [label=""];
    0 -> 0 [label="0,z_0/0z_0; 1,z_0/1z_0; 0,0/00; 1,0/10; 0,1/01; 1,1/11"];
    0 -> 1 [label="\\epsilon,1/1; \\epsilon,0/0 ;\\epsilon, z_0/z_0"]; 
    1 -> 1 [label="0,0/\\epsilon ; 1,1/\\epsilon ; \\epsilon,z_0/\\epsilon"];
}
\end{dot2tex}
Вместо перехода в терминальное состояние добавили стирание нулевого символа со стека.
\end{exmp}

\begin{assertion}
Принятие по терминальному состоянию позволяет принимать в точности те же языки, что и принятие по пустому магазину.
\end{assertion}
\begin{proof}
Возьмем МП-автомат $A$, принимающий по терминальному состоянию.

В новом автомате введем новое стартовое состояние $q_0'$ и еще один нулевой стековый символ $z_1$ и добавим переход из $q_0'$, пишем на стек $z_0z_1$. 
Это нужно потому, что, вообще говоря, мы могли случайно в исходном автомате когда-то совсем-совсем затереть стек, а сейчас мы сделали так, чтобы мы при этом не завершались "--- у нас просто нет 
переходов, на которых написано, что снимаем со стека $z_1$.

А из терминальных состояний надо добавить переход $\epsilon */\epsilon$ в новое состояние, переход ничего не будет добавлять, новое состояние зациклим на себя переходом $\epsilon */\epsilon$, чтобы стек опустошить.


В другую сторону.
Взяли МП-автомат, принимающий по пустому стеку.
Хочется просто сказать, что если стек стал пустым, то надо перейти в терминальное состояние. 
Но так делать нельзя, так как для перехода нам нужно что-то со стека прочитать.

Для этого опять добавим новое стартовое состояние и символ $z_1$, а из каждого состояния добавим переход $\epsilon,z_1/\epsilon$ в терминальное состояние.
\end{proof}

На следующей лекции докажем, что это равномощно КС-языкам.