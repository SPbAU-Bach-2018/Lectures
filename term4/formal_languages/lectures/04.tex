\setauthor{Всеволод Степанов}

\section{Теорема Клини}
\begin{theorem}
Множество языков, принимаемых ДКА совпадает с множеством языком, принимаемых АРВ
\end{theorem}
\begin{proof}
В обе стороны будут конструктивные доказательства.


$L$ "--- регулярный $\Ra$ $L$ "--- автоматный.

Будем сейчас строить соответствующий регулярному выражению $\epsilon$-НКА.

Будем брать и строить автомат ``по индукции'': вот у нас как-то строится АРВ (можно, например, его представить в виде синтаксического дерева и сказать, что строим снизу вверх), будем так же строить и соответствующий ДКА. 
При этом будем поддерживать следующие инварианты:
\begin{enumerate}
\item
В начальное состояние нет переходов.
\item
Одно терминальное состояние, из него нет переходов.
\item
Терминальное состояние не совпадает с начальным.
\end{enumerate}
\begin{itemize}
\item
$R = \emptyset$, автомат выглядит вот так:
\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";

    node [shape = doublecircle] 1;
    node [shape = none] "" 
    node [shape = circle] 0;
    "" -> 0 [label=""];
    0 -> 1 [label="",style="invisible"]; 
}
\end{dot2tex}

\item
$R = \epsilon$:
\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";

    node [shape = doublecircle] 1;
    node [shape = none] "" 
    node [shape = circle] 0;
    "" -> 0 [label=""];
    0 -> 1 [label = "\\epsilon"]; 
}
\end{dot2tex}


\item
$R = a$, $a \in \Sigma$
\begin{dot2tex}[tikz,scale=.55,options=-t math]
digraph G {
    rankdir=LR;
    ranksep="0.0";
    mindist="0";

    node [shape = doublecircle] 1;                                            
    node [shape = none] "" 
    node [shape = circle] 0;
    "" -> 0 [label=""];
    0 -> 1 [label = "a"]; 
}
\end{dot2tex}


\item
$R = (R_1)$, автомат для такого выражения в точности равен автомату для $R_1$

\item
$R = R_1^*$. Пусть у автомата для $R_1$ было стартовое состояние $s$ и терминальное $t$, у автомата для $R$ будет стартовое состояние $s'$ и терминальное $t'$.

Возьмем целиком автомат для $R_1$, добавим следующие $\epsilon$-переходы: $s' \to s$, $t \to s$, $s \to t'$.
\TODO тут должна быть красивая картинка, но у меня пока не получилось ее сделать

Полученный автомат удовлетворяет инвариантам, описаным выше и, как несложно заметить, соответствует $R$: в $t'$ мы попадаем только из $s$, 
в которое мы попадаем либо по пустой строке, либо несколько раз по строке, принимаемой $R_1$. 

\begin{Rem}
Инвариант <<в начало ничего не входит>> важен: иначе может быть так, что мы внутри $R_1$ примем слово лишь частично, а потом прыгнем в терминальное.
\end{Rem}

%\begin{dot2tex}[dot,scale=.55,options=-t math]
%digraph G {         
%    rankdir="LR";
%    subgraph cluster_1 {        
%        label="R_1";
%        "R_1 start";
%        "R_1 terminal" [shape = doublecircle];
%        "R_1 start" -> "R_1 terminal" [label = "\\epsilon"];        
%    }
%    node [shape = none] "" 
%    node [shape = circle] 0;
%    "" -> 0 [label=""];
%    0 -> "R_1 start" [label = "\\epsilon"]; 
%}
%\end{dot2tex}

\item
$R_1R_2$ "--- рисуем автоматы для $R_1$ и $R_2$, соединяем их по $\epsilon$-переходу из терминального состояния у $R_1$ в стартовое для $R_2$, у терминального состояния $R_1$ убираем терминальность.

\item
$R_1|R_2$ "--- берем стартовую вершину, делаем из нее по $\epsilon$-переходу в автоматы для $R_1$ и $R_2$, из их терминальных вершин добавляем по $\epsilon$-переходу в терминальную вершину нашего автомата, 
убираем у них терминальность.
\end{itemize}

В итоге получили автомат размера $\O(|\text{АРВ}|)$.
Этот алгоритм применим на практике, если очень хочется построить автомат по АРВ самому, то вот это вот и рекомендуется писать.


$L$-автоматный $\Ra$ $L$-регулярный.

Будем сейчас строить трехмерную таблицу регулярных выражений, $R_{ijk}$ "--- АРВ, принимающее язык слов, 
которые переводят ДКА $A$ из состояния $i$ в состояние $j$ с использованием промежуточных состояний с номерами $\leq k$.
Немного напоминает алгоритм Флойда, это не случайно, сейчас будет что-то похожее.


\begin{enumerate}
\item Слой $k=0$:

\begin{itemize}
\item $i=j$, $R_{ii0} = \epsilon$. Это не совсем правильно, так как в автомате могли быть петли из $i$ в $i$ по символу $c$, в таком случае надо писать $R_{ii0} = \epsilon|c_1|c_2\dots$.

Внимание, формализм: по петле можно пройти не более одного раза, так как иначе будут промежуточные вершины, которые мы запретили в силу того, что $k=0$, поэтому мы написали корректное АРВ.

\item $i\neq j$, $R_{ij0} = c_1|c_2|\dots$, $c_i$ "--- символы, по которым можно перейти из $i$ в $j$. Если таких символов нет, то $R_{ij0} = \emptyset$.
\end{itemize}

\item Слой $k>0$:

В алгоритме Флойда: мы хотим пройти из вершины $i$ в вершину $j$. Либо идем по пути с промежуточными вершинами с номерами $\leq k$, либо прошли по такому пути из $i$ в $k$, а потом из $k$ в $j$. 

Тут немножко не так "--- мы вершину $k$ можем иметь несколько раз на пути из $i$ в $j$, так как пройденный нами путь может быть произвольным, не обязательно кратчайшим.
Надо это аккуратно записать в виде АРВ.

$R_{i,j,k} = R_{i,j,k-1} | R_{i,k,k-1} R_{k,k,k-1}^* R_{k,j,k-1}$ "--- либо не использовали состояния с номерами $k$, 
либо наш путь делится на 3 части: часть из $i$ до первого вхождения $k$, часть из последнего вхождения $k$ в $j$, а еще несколько (возможно, ноль) раз в промежутке прошли из $k$ в $k$.
\end{enumerate}

Пусть $T = \{t_1, \dots, t_k\}$. Тогда АРВ, соответствующее ДКА, будет равно $R_{q_0,t_1,n} | R_{q_0,t_2,n} | \dots | R_{q_0,t_k,n}$, или же $\emptyset$, если $T = \emptyset$.

Время работы алгоритма будет $\O^*(4^{|Q|})$ "--- на каждом слое мы конкатенируем 4 АРВ, увеличивая длину в 4 раза.
\end{proof}
\begin{Rem}
Теперь часто будем употреблять термин ``регулярный язык'' как синоним ``автоматный язык''
\end{Rem}



\section{Лемма о накачке (Pumping lemma)}
\begin{theorem}
Пусть $L$ "--- регулярный язык. Тогда: $\exists n \in \N \colon \forall w \in L \colon |w| \geq n \Ra \exists x, y, z \colon (w=xyz) \land (|x| + |y| \leq n) \land (|y| > 0) \land (\forall i \geq 0\colon xy^iz \in L)$ 

То же самое, но словами: для любого регулярного языка верно, что для любого достаточно длинного слова можно взять небольшую середину, повторить ее кучу раз и все равно получить слово из этого же языка.

Например, этой леммой удобно доказывать что какой-то язык не регулярен.
\end{theorem}
\begin{proof}
Существует ДКА $A \colon L(A) = L$. $n = |Q|$. Рассмотрим произвольное слово $w \in L, |w| \geq n$.
Будем скармливать автомату префиксы $w$, смотреть, куда пришли. Всего выписали $n+1$ состояние (может и больше, рассмотрим тогда первые $n + 1$), значит, 
по принципу Дирихле, для каких-то префиксов $x = a_1 \dots a_i$ и $xy = a_1 \dots a_ia_{i+1} \dots a_k$ состояния, им соответствующие, совпадут.

Обозначим $z = a_{k+1}\dots a_{|w|}$, тогда верно: 
$\\
\hat\delta(q_0, x) = q,\\ 
\hat\delta(q, y) = q,\\
\hat\delta(q, z) \in T$.

$x, y, z$ подходят под условие леммы, победа.

\end{proof}              
\begin{exmp}
$L = \{0^n1^n\}$

Отрицание утверждения леммы: для любого $n$ существует слово $w$ длины $n$ такое, что утверждение леммы не будет верным (то есть, нельзя разбить на три части).


Взяли произвольное $n$, в качестве $w$ подставили $w=0^n1^n$, лемму, как несложно заметить, поломали: нельзя вот так просто брать и копипастить середину.
\end{exmp}
\begin{exmp}
$L = \{(0|1)^*\}$ (Количество 0 равно количеству 1).

Можно взять, например, $0^{2n}1^{2n}$. Так как $|xy| \leq n$ "--- префикс нашего слова, то $y$ в любом случае будет состоять из одних нулей, поэтому если его мы повторим несколько раз, то все сломаем.
\end{exmp}
