\section{} % 01
	Алфавит $\Sigma$ всегда конечен (обычно 0 и 1, но иногда важно), слово "--- конечная последовательность, есть пустое $\epsilon$, язык "--- мн-во слов (любое).
	Языки либо конечны, либо счётны.
	Бывают неразрешимые, мы же хотим описывать те, которые совсем просто разрешать.

	Детерминированный конечный автомат (ДКА, DFA) "--- пятёрка (алфавит $\Sigma,$ состояния $Q$, стартовое $q_0$, терминальные $T$,
	везде определённая функция перехода $\delta \colon Q \times \Sigma \to Q$).
	Автомат по очереди ест буквы, принимает $\iff$ закончили в $T$.
	$\delta$ обобщается до $\hat\delta\colon Q \times \Sigma^* \to A$ (обобщённая функция).
	Если $A$ "--- автомат, то $L(A)$ "--- его язык.
	Размер "--- число состояний.
	Тупиковое состояние "--- нельзя дойти до терминала, на изображения не рисуют (но в размере учитываем).

	Эквивалентны, если $L(A)=L(B)$.
	Минимизация по числу вершин: вершины различимы, если можно дописать $z$ и одна примет, другая нет.
	Это эквивалентность.
	Лемма: если $r \nequiv s$ и в них можно попасть по $x$ из $(p, q)$, то $p \nequiv q$.
	Алгоритм: удаляем недостижимые вершины, потом строим граф пар состояний и проводим рёбра по лемме,
	прошли dfs по обратным рёбрам от $(\in T, \notin T)$, разбили на классы.
	Стянули классы в одну вершину, надо проверить детерминированность и корректность языка.
	Алгоритм работает за $\O(n^2 \Sigma)$ (по числу рёбер).

\section{} % 02
	Правый контекст слова $C_L^R(x)$ "--- что можно дописать к $x$, чтобы лежало в языке, они могут пересекаться.
	Если два слова попали в одно состояние автомата, то контексты равны.
	Если контексты не равны, то вершины различимы.
	Теорема: кол-во вершин в минимальном DFA равно числу разных контекстов.
	Теорема: все минимальные изоморфны, так как есть биекция между контекстами и вершинами.
	Теорема: контекстов конечно $\iff$ есть автомат ($\La$: можно минимизировать, $\Ra$: строим явно, проверить детерминированность и корректность).
	Бесконечно контекстов: $\t{(}^n\t{)}^n$.

	Проверка эквивалентности: граф на парах состояний из двух автоматов, дальше dfs по обратным рёбрам,
	как в минимизации (стартуем из очевидно различимых вершин).
	Дополнение автоматного автоматно: можно смотреть на контексты, можно явно взять дополнение к мн-ву терминальных.
	Пересечение, объединение, разность автоматных "--- автоматны, так как можно посмотреть на $C_L^R(x)$,
	их было конечно, станет тоже конечно.
	Прямое произведение: состояние "--- это пара, переходы ясно какие, терминалы "--- если терминал и там, и там
	(принимает пересечение).
	Если изменить терминалы в прямом произведении, можно принимать объединение и разность.

	Динамика: можно проверять свойства языка (bfs'ом искать минимальное слово в языке).
	Можно считать кол-во слов длины $n$ динамикой.
	Можно заоптимизировать динамику до матрицы размера $n$.
	Тогда из линейки должны знать (но не знаем), что число слов длины $n$ растёт либо линейно, либо поэкспоненте.

\section{} % 03
	$\epsilon-NFA$ "--- пятёрка из алфавита, состояний, стартового, терминалов и $\Delta \colon Q \times (\Sigma \cup \{\epsilon\}) \to (2^Q\setminus \varnothing)$,
	изменилась только функция перехода и появился $\epsilon$-переход.
	$E(q)$ "--- это $\epsilon$-замыкание $q$, все состояния, до которых можно дойти по $\epsilon$ из $q$.
	Определение принятия слова автоматом.
	Алгоритм принятия за $O(nQ^2)$: на каждом шаге храним множество состояний, где может быть НКА,
	потом переходим по букве, и потом делаем предподсчитанные $\epsilon$-замыкания всех состояний.
	Можно с битсетами поделить на 64.
	Для Машины Тьюринга ничего такого не катит, потому что там ещё есть лента.

	Детерминизация: сделали $2^Q$ состояний, переходы, как в алгоритме принятия.
	Не все состояния могут быть нужны (оценок, правда, нет), их можно выкинуть, и принимать слово за $O(n)$ вместо $O(nQ^2)$.
	А можно совместить: если состояний много, то явно не строить.
