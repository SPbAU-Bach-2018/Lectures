\section{Билет 1}

\subsection{Типы задач}
	\begin{Def}
		\textit{Слово} "--- элемент $\{0,1\}^*$, длина слова $x$ обозначается $|x|$.
	\end{Def}
	\begin{Def}
		\textit{Язык} "--- некоторое множество слов (возможно, пустое или бесконечное).
	\end{Def}
	\begin{Rem}
		Мы считаем, что битовыми строками можно кодировать вообще любые объекты, которые можно описать.
		Кодировать будем, разумеется, наиболее разумно (если не сказано иное), чтобы размер строк был как можно меньше.
		Где важен тип кодирования "--- будем явно указывать.
	\end{Rem}
	\begin{exmp}
		Натуральные числа можно естесственно закодировать битовой строкой "--- представление числа в двоичной системе счисления.
	\end{exmp}
	\begin{exmp}
		Пары битовых строк: $(a, b)$ можно закодировать какой-то битовой строчкой.
		Тогда за $|(a, b)|$ естественным образом будет обозначаться длина этой строчки.
		В принципе, ожидаемо, что $|(a, b)| = \theta(|a| + |b|)$, по-хорошему надо выбрать один способ кодирования и для него доказать, но мы не стали.
	\end{exmp}

	\begin{Def}
		\textit{Индивидуальная задача} "--- это пара $(a, b)$, где $a, b$ "--- слова.
		$a$ называется условием или входом, $b$ называется решением для данного входа.
	\end{Def}
	\begin{Rem}
		Это определение не нужно и дальше нигде встречаться не будет.
	\end{Rem}

	\begin{Def}
		\textit{Массовая задача $R$} "--- некоторое множество $R$ индивидуальных задач (возможно, пустое или бесконечное):
		\[ R \subseteq 2^{\{0,1\}^*\times\{0,1\}^*}\] 
		Также можно рассматривать как бинарное отношение на строках: $aRb \iff (a, b) \in R$
		(читать как <<$b$ является решением задачи $R$ с условием $a$>>)
		Мы будем писать и так, и так.
	\end{Def}

	\begin{exmp}
		Задача $FRAC$ "--- множество таких пар натуральных чисел $(n, d)$, что $n \vdots d$.
		То есть у одного <<условия>> ($n$) может быть несколько <<решений>> ($d$), никаких проблем.
	\end{exmp}

	\begin{Def}
		Мы умеем решать \textit{задачу поиска} для массовой задачи $R$, если есть алгоритм, который по условию $x$
		находит произвольное решение $w$ такое, что $(x, w) \in R$ или же сообщает, что такого решения нет.
	\end{Def}

	\begin{Def}
		Мы умеем решать \textit{задачу распознавания} для массовой задачи $R$, если есть алгоритм, который по условию $x$
		отвечает: есть ли хоть какое-нибудь решение $w$.
	\end{Def}
	\begin{Rem}
		Таким образом, если мы умеем решать задачу распознавания для $R$, то у нас есть алгоритм, разрешающий следующий язык:
		\[ L(R) = \{ x \mid \exists w \colon (x, y) \in R \} \]
	\end{Rem}

\subsection{Машины Тьюринга}
\subsubsection{Базовая модель}
	Машина Тьюринга (МТ) "--- вычислительная модель.
	Есть много модификаций, но у каждой МТ есть следующее:
	\begin{itemize}
		\item
			Фиксированный конечный алфавит $\Sigma$, в котором имеется как минимум два специальных символа: пробел ($\textvisiblespace$) и
			специальный символ начала ленты ($\triangleright$).
		\item
			Фиксированное конечное число \textit{лент}, бесконечных в одну сторону.
			Лента "--- это бесконечно много ячеек, занумерованных натуральными числами.
		\item Конечное множество \textit{состояний} $q_i$.
		\item Конечное множество \textit{переходов}.
			Каждый переход "--- это кортеж:
			\[ (q, c_1, c_2, \dots, c_l, c_1', c_2', \dots, c_l', m_1, m_2, \dots, m_l r) \]
			при этом:
			\begin{itemize}
				\item $l$ "--- число лент
				\item $c_i, c_i' \in \Sigma$
				\item $q, r$ "--- состояния
				\item $m_i \in \{\la, \dot, \ra\}$ "--- \textit{сдвиг головки $i$}
			\end{itemize}
			Говорим, что это переход из $q$ в $r$ по символам на лентах $c_1, \dots, c_l$, который пишет на ленты $c_1', \dots, c_l'$
			и сдвигает головки в направлениях $m_i$.
		\item В зависимости от модификации могут вводиться какие-нибудь выделенные подмножества состояний (например, терминальные состояния, см. ниже) и лент, накладываться дополнительные ограничения.
	\end{itemize}
	Чтобы МТ что-нибудь вычисляла, вводится понятие \textit{конфигурации} конкретной МТ $M$, оно состоит из:
	\begin{itemize}
		\item Для каждой ленты хранится одно натуральное число, соответствующее какой-то ячейке "--- \textit{позиция головки на этой ленте}
		\item
			Для каждой ленты хранится отображение $f \colon \N \to \Sigma$, которое в конечном числе точек может возвращать что угодно, а в остальных возвращает $\textvisiblespace$.
			Также можно дополнительно потребовать $f(1)=\triangleright$, но это необязательно (соответствующие определения будут эквивалентны).
		\item
			Выделяется \textit{текущее состояние} МТ $q$.
	\end{itemize}
	Дальше вводится понятие \textit{корректного перехода из конфигурации} $A$ в какие-то другие конфигурации.
	Чтобы сгенерировать список этих конфигураций, надо сделать следующее:
	\begin{enumerate}
		\item Рассмотреть все переходы из текущего состояния конфигурации $A$.
		\item Оставить из них только те переходы, у которых символ $c_i$ совпадает с символом на позиции головки на ленте $i$
		\item
			Для каждого из оставшихся сказать, что мы можем перейти в конфигурацию, у которой текущее состояние изменено с $q$ на $r$,
			символы $c_i$ на лентах заменены на символы $c_i'$, соответственно, а позиции головок на каждой ленте независимо изменены в соответствии с $m_i$:
			\begin{itemize}
				\item При $\la$ головка сдвигается на единицу влево
				\item При $\cdot$ головка остаётся на месте
				\item При $\ra$ головка сдвигается на единицу вправо
			\end{itemize}
	\end{enumerate}
	\begin{Rem}
		Можно формально определить бинарное отношение <<быть корректным переходом>> между состояниями,
		аккуратно расписав алгоритм выше.
	\end{Rem}
	\begin{Rem}
		Никакая головка не должна уезжать за край ленты.
		Есть разные способы этого добиться.
	\end{Rem}

\subsubsection{Модификации}
	Все модификации МТ ниже эквивалентны друг другу, мы выбираем ту, в которой удобнее работать в данной задаче.
	Для доказательства эквивалентности двух моделей, надо выбрать машину в одной модели и переделать.

	Чтобы головка не уезжала налево за край ленты, можно считать по-разному:
	\begin{itemize}
		\item Переход, при котором головка уезжает налево некорректен
		\item Если головка уезжает налево, вычисление прекращается.
	\end{itemize}

	\begin{Def}
		\textit{Детерминированная машина Тьюринга} (ДМТ) "--- если зафиксировать начальное состояние и множество символов под лентой, то переход либо есть и ровно один, либо его нет.
		Если перехода нет, то можно либо отвергать слово, либо переходить в какое-то спецсостояние (эквивалентно).
		Можно считать, что все переходы всегда должны быть (эквивалентно).
	\end{Def}
	\begin{Rem}
		Если у ДМТ зафиксировать конфигурацию, то следующая конфигурация (если есть) всегда определяется однозначно.
		Поэтому можно говорить о том, что ДМТ что-то однозначно вычисляет (или зацикливается).
	\end{Rem}
	\begin{Def}
		На ДМТ можно вычислять функции: на фиксированную (входную) ленту пишем вход, запускаем ДМТ, пока не завершиться, после этого ожидаем на фиксированной ленте (выходной) получить ответ.
	\end{Def}
	\begin{Def}
		На ДМТ также можно вычислять ответы <<да/нет>>: говорим, что ДМТ обязана завершать работу в ровно одном из двух состояний "--- $q_{yes}$ или $q_{no}$, и именно этим определяется результат работы.
	\end{Def}

	\begin{Def}
		\textit{Недетерминированная машина Тьюринга} (НМТ) "--- без подобных ограничений, может быть несколько корректных переходов из одной конфигурации.
	\end{Def}
	\begin{Def}
		НМТ принимает слово $x$, если остановилась в состоянии $q_{yes}$ на хотя бы одной подсказке.
	\end{Def}

\subsubsection{Метрики}
	\begin{Def}
		\textit{Время работы $M$} "--- количество шагов.
	\end{Def}
	\begin{Def}
		\textit{Используемая $M$ память} "--- сумма следующей величины по всем лентам: максимальное правое положение головки на ленте.
	\end{Def}
	\begin{exmp}
		Если машина на двух лентах сначала отвела первую головку вправо на 10, потом вернула, потом сделала то же самое со второй головкой,
		то используемая память "--- $10+10=20$.
	\end{exmp}

	На НМТ и там, и там независимо берётся максимум по всем веткам.
	Можем считать, что время/память всегда фиксированы из-за будильников.

\subsection{Классы $\P$ и $\NP$}
	\begin{Def}
		Массовая задача $R$ \textit{полиномиально ограничена} (п.о.), если существует полином $p$, ограничивающий длину кратчайшего решения для каждого входа,
		на котором вообще есть ответ:
		\[
			\forall x \colon (\exists w \colon (x, w) \in R) \Ra \exists w \colon (x, w) \in R \land |w| \le p(|x|)
		\]
		Длина решения зависит полиномиально от длины входа.
	\end{Def}
	\begin{Def}
		Массовая задача $R$ \textit{полиномиально проверяема} (п.п.), если существует ДМТ $M$ и полином $q$, ограничивающий время проверки решения:
		\[
			(x, w) \in R \iff M((x, w))=1
		\]
		Причём вычисление $M((x, w))$ всегда завершается не более, чем за $q(|(x, w)|)$ шагов.
	\end{Def}
	\begin{Rem}
		Можно считать, что $q$ на самом деле от двух переменных, можно считать, что он от $|x|+|w|$ "--- это всё будет эквивалентно.
	\end{Rem}

	\begin{Def}
		$\widetilde{\NP}$ "--- класс п.о. п.п. задач поиска, т.е. это все п.о. п.п. массовые задачи, которым мы задаём вопрос <<а какое есть решение у данного условия?>>
	\end{Def}
	\begin{Rem}
		Дальше будет класс $\NP$, в нём тоже будут лежать п.о. п.п. массовые задачи, однако им мы уже будем задавать вопрос <<есть ли решение у данного условия?>>.
		Можно считать $\widetilde{\NP}$ классом (некоторым множеством) массовых задач, а $\NP$ "--- классом языков.
	\end{Rem}

	\begin{Def}
		$\widetilde{\P}$ "--- подкласс $\widetilde{\NP}$, причём для каждой задачи $R$ должно быть для каждого условия $x$ найти за полиномиальное от $x$ время какое-нибудь решение.
	\end{Def}
	\begin{Rem}
		Можно считать, что если решения нет, то мы это тоже за полиномиальное время узнаём.
		Или зацикливаемся.
		Это эквивалентно "--- добавляем будильник в МТ.
	\end{Rem}

	\begin{Def}
		$\NP$ "--- все языки, порождаемые массовыми задачами из $\widetilde{\NP}$.
		Т.е. задача $A \in \widetilde{\NP}$ порождает язык из условий $x$ таких, что $\exists w \colon (x, w) \in A$.
	\end{Def}
	\begin{Def}
		$\P$ "--- все такие языки $A$, что: есть ДМТ $M$ и полином $q$, причём для любого слова $x$ $M(x)=A(x)$ и машина отработает не больше, чем за $q(|x|)$.
	\end{Def}
	\begin{assertion}
		Это определение эквивалентно такому: $\P$ "--- все языки, порождаемые $\widetilde{\P}$.
	\end{assertion}
	\begin{proof}
		\begin{description}
			\item[$L(\widetilde{\P}) \subseteq \P$]:
				взяли язык $A$ из левой части.
				Запустили алгоритм, ищущий решение.
				Если он нашёл, то условие принадлежит соответствующему языку, иначе не принадлежит.
			\item[$\P \subseteq L(\widetilde{\P})$]:
				взяли язык $A \in \P$.
				Ему можно сопоставить массовую задачу $A'$:
				\[ (x, w) \in A' \iff A \in A \land w=\epsilon \]
				Очевидно, она лежит в $\widetilde{\NP}$ и для каждого условия $x$ можно либо найти решение $\epsilon$, либо сказать, что решений нет.
				Проверку существования решения ща полиномиальное время сделать сумеем.
		\end{description}
	\end{proof}

	\begin{assertion}
		Второе определение $\NP$: это все такие языки, для которых существует полиномиальная ДМТ, которая проверяет слово из языка при наличии подсказки.
		При этом наличие хотя бы одной подсказки эквивалентно тому, что слово в языке.
	\end{assertion}
	\begin{assertion}
		Третье определение $\NP$: это все такие языки, которые можно разрешить на полиномиальной НМТ.
	\end{assertion}

\subsection{Сведение по Карпу}
	Это то, что обычно подразумевается под <<сведением задач>> (в случае задач распознавания).

	Задача $L_1$ сводится по Карпу к $L_2$, если есть такая полиномиально вычислимая $f$, что:
	\[ x \in L_1 \iff f(x) \in L_2 \]
	То есть если хотим решить задачу $L_1$, то можно вычислить $f(x)$, решить задачу $L_2$ и сразу получить ответ на исходную.
	Тут важно, что ответ мы хотим получить сразу.
	Например, тогда подсказки для $L_2$ мы сразу можем назвать подсказками для $L_1$, а вот если бы, скажем, ответ инвертировали, то так сделать было бы нельзя.

\subsection{Сведение по Левину}
	Это то, что обычно подразумевается под <<сведением задач>> (в случае задач поиска).
	Опять же, использовать в будущем не будем.

	Задача $R_1$ сводится по Левину к $R_2$, если есть три функции $f, g, h$ такие, что (тут по $x_i, y_i$ стоят кванторы всеобщности):
	\begin{enumerate}
		\item $f(x_1)$ по условию для $R_1$ возвращает за полиномиальное время условие для $R_2$.
		\item Если есть решение $R_1$, то есть не сильно большее решение $R_2$:
			\[ R_1(x_1, y_1 \Ra R_2(f(x_1), g(x_1, y_1)) \]
			Причём $g$ "--- п.о. (но необязательно полиномиально вычислима).
		\item Если известно решение $R_2$, то его можно быстро переделать в решение $R_1$: 
			\[ R_2(f(x_1), y_2) \Ra R_1(x_1, h(f(x_1), y_2)) \]
			При этом функция $h$ принимает только $f(x_1)$, а не сам $x_1$, и работает за полиномиальное время.
	\end{enumerate}
	\begin{Rem}
		Смысл такой: если у нас есть условие для $R_1$, то мы можем посчитать условие для $R_2$ (функцией $f$), решить задачу $R_2$ и получить для неё ответ,
		получить ответ для $R_1$ (функцией $h$).
		Функция $g$ нужна только для того, чтобы гарантировать, что ответ на задачу $R_2$ будет не очень большой.
	\end{Rem}
	\begin{Rem}
		Иногда <<для красоты>> требуют, чтобы функция $g$ тоже была полиномиально вычислима.
		Нам это вроде не было важно.
	\end{Rem}

	\begin{Rem}
		Сведение по Левину имеет смысл только в том случае, если мы говорим о задачах с конкретными сертификатами.
		Сведение же по Карпу более общее "--- оно сводит языки.
	\end{Rem}

\subsection{Полные задачи}
	Тут определяется и для классов задач поиска, и для классов задач распознавания.

	\begin{Def}
		Задача $A$ "--- \textit{трудная для класса $C$} (или \textit{$C$-трудная}), если произвольная задача $B \in C$ сводится к $A$ (по Карпу или Левину).
	\end{Def}
	\begin{Def}
		Задача $A$ "--- \textit{полная для класса $C$} (или \textit{$C$-полная}), если она $C$-трудная и лежит в классе $C$.
	\end{Def}

	\begin{Def}
		Класс $\NP$-полных задач обозначается $\mathsf{NPC}$.
	\end{Def}
	\begin{Def}
		Класс $\NP$-полных задач обозначается $\mathsf{NPC}$.
	\end{Def}

\subsection{Задача об ограниченной остановке}
	\begin{Def}
		$\t{1}^t$ "--- так обозначается строка из $t$ единиц.
	\end{Def}
	\begin{Def}
		Задача $\mathsf{BH}$ (\textit{об ограниченной остановке}) "--- это множество троек $(M, x, \t{1}^t)$ таких, что:
		\begin{enumerate}
			\item
				$M$ "--- недетерминированная машина Тьюринга
			\item
				Существует подсказка $w$ для $M$ такая, что $M(x, w)$ останавливается и принимает $x$.
				\begin{Rem}
					Конечно же, $|w| \le t$, так как у нас машина после $t$ шагов будет остановлена.
				\end{Rem}
		\end{enumerate}
	\end{Def}

	\begin{theorem}
		$\mathsf{BH}$ является $\NP$-трудной.
	\end{theorem}
	\begin{proof}
		Возьмём произвольный язык $L \in \NP$.
		По определению для него есть НМТ $M_L$ такая, что:
		\[ x \in L \iff M_L(x) = 1 \]
		причём $M_L$ принимает $x$ за время не большее $p(|x|)$, где $p$ "--- полином.

		Давайте сводить $L$ к $\mathsf{BH}$ по Карпу, строя п.о. п.п. функцию $f$.
		Наша функция $f$ будет по входу $x$ выдавать машину $M_L$ (она константа и не зависит от $x$),
		потом "--- сам вход $x$, а потом "--- $1^{p(|x|)}$.
		Очевидно, что $x \in L \iff f(x) \in \mathsf{BH}$, просто по определению $\NP$.

		Также понятно, что $f$ полиномиально вычислима и, следовательно, полиномиально ограничена
		(мы верим, что вычислить значение полинома и вывести столько единиц мы справимся).
	\end{proof}

	\begin{theorem}
		$\mathsf{BH}$ является $\NP$-полной.
	\end{theorem}
	\begin{proof}
		Эта задача уже точно является $\NP$-трудной, осталось показать, что она лежит в $\NP$.

		Для этого просто строим универсальную недетерминированную машину Тьюринга, которая будет эмулировать данную на вход НМТ
		в течение не более $t$ шагов, а когда эмулируемой НМТ потребовалось принять недетерминированное решение, наша универсальная машина тоже
		будет принимать недетерминированное решение.
		\begin{Rem}
			Осторожно с построением универсальных машин: нам важно, чтобы замедление было максимум полиномиальным от $t$ и чтобы эмулируемая машина
			могла иметь произвольное число лент (а универсальная "--- лишь константное), см. билет 2.
		\end{Rem}
	\end{proof}
