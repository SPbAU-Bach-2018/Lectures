\setcounter{section}{0}
\section{Билет 1}

\subsection{Типы задач}
	\begin{Def}
		\textit{Слово} "--- элемент $\{0,1\}^*$, длина слова $x$ обозначается $|x|$.
	\end{Def}
	\begin{Def}
		\textit{Язык} "--- некоторое множество слов (возможно, пустое или бесконечное).
	\end{Def}
	\begin{Rem}
		Мы считаем, что битовыми строками можно кодировать вообще любые объекты, которые можно описать.
		Кодировать будем, разумеется, наиболее разумно (если не сказано иное), чтобы размер строк был как можно меньше.
		Где важен тип кодирования "--- будем явно указывать.
	\end{Rem}
	\begin{exmp}
		Натуральные числа можно естесственно закодировать битовой строкой "--- представление числа в двоичной системе счисления.
	\end{exmp}
	\begin{exmp}
		Пары битовых строк: $(a, b)$ можно закодировать какой-то битовой строчкой.
		Тогда за $|(a, b)|$ естественным образом будет обозначаться длина этой строчки.
		В принципе, ожидаемо, что $|(a, b)| = \theta(|a| + |b|)$, по-хорошему надо выбрать один способ кодирования и для него доказать, но мы не стали.
	\end{exmp}

	\begin{Def}
		\textit{Индивидуальная задача} "--- это пара $(a, b)$, где $a, b$ "--- слова.
		$a$ называется условием или входом, $b$ называется решением для данного входа.
	\end{Def}
	\begin{Rem}
		Это определение не нужно и дальше нигде встречаться не будет.
	\end{Rem}

	\begin{Def}
		\textit{Массовая задача $R$} "--- некоторое множество $R$ индивидуальных задач (возможно, пустое или бесконечное):
		\[ R \subseteq 2^{\{0,1\}^*\times\{0,1\}^*}\] 
		Также можно рассматривать как бинарное отношение на строках: $aRb \iff (a, b) \in R$
		(читать как <<$b$ является решением задачи $R$ с условием $a$>>)
		Мы будем писать и так, и так.
	\end{Def}

	\begin{exmp}
		Задача $FRAC$ "--- множество таких пар натуральных чисел $(n, d)$, что $n \vdots d$.
		То есть у одного <<условия>> ($n$) может быть несколько <<решений>> ($d$), никаких проблем.
	\end{exmp}

	\begin{Def}
		Мы умеем решать \textit{задачу поиска} для массовой задачи $R$, если есть алгоритм, который по условию $x$
		находит произвольное решение $w$ такое, что $(x, w) \in R$ или же сообщает, что такого решения нет.
	\end{Def}

	\begin{Def}
		Мы умеем решать \textit{задачу распознавания} для массовой задачи $R$, если есть алгоритм, который по условию $x$
		отвечает: есть ли хоть какое-нибудь решение $w$.
	\end{Def}
	\begin{Rem}
		Таким образом, если мы умеем решать задачу распознавания для $R$, то у нас есть алгоритм, разрешающий следующий язык:
		\[ L(R) = \{ x \mid \exists w \colon (x, y) \in R \} \]
	\end{Rem}

\subsection{Машины Тьюринга}
\subsubsection{Базовая модель}
	Машина Тьюринга (МТ) "--- вычислительная модель.
	Есть много модификаций, но у каждой МТ есть следующее:
	\begin{itemize}
		\item
			Фиксированный конечный алфавит $\Sigma$, в котором имеется как минимум два специальных символа: пробел (\textvisiblespace) и
			специальный символ начала ленты ($\triangleright$).
		\item
			Фиксированное конечное число \textit{лент}, бесконечных в одну сторону.
			Лента "--- это бесконечно много ячеек, занумерованных натуральными числами.
		\item Конечное множество \textit{состояний} $q_i$.
		\item Конечное множество \textit{переходов}.
			Каждый переход "--- это кортеж:
			\[ (q, c_1, c_2, \dots, c_l, c_1', c_2', \dots, c_l', m_1, m_2, \dots, m_l r) \]
			при этом:
			\begin{itemize}
				\item $l$ "--- число лент
				\item $c_i, c_i' \in \Sigma$
				\item $q, r$ "--- состояния
				\item $m_i \in \{\la, \dot, \ra\}$ "--- \textit{сдвиг головки $i$}
			\end{itemize}
			Говорим, что это переход из $q$ в $r$ по символам на лентах $c_1, \dots, c_l$, который пишет на ленты $c_1', \dots, c_l'$
			и сдвигает головки в направлениях $m_i$.
		\item В зависимости от модификации могут вводиться какие-нибудь выделенные подмножества состояний (например, терминальные состояния, см. ниже) и лент, накладываться дополнительные ограничения.
	\end{itemize}
	Чтобы МТ что-нибудь вычисляла, вводится понятие \textit{конфигурации} конкретной МТ $M$, оно состоит из:
	\begin{itemize}
		\item Для каждой ленты хранится одно натуральное число, соответствующее какой-то ячейке "--- \textit{позиция головки на этой ленте}
		\item
			Для каждой ленты хранится отображение $f \colon \N \to \Sigma$, которое в конечном числе точек может возвращать что угодно, а в остальных возвращает \textvisiblespace.
			Также можно дополнительно потребовать $f(1)=\triangleright$, но это необязательно (соответствующие определения будут эквивалентны).
		\item
			Выделяется \textit{текущее состояние} МТ $q$.
	\end{itemize}
	Дальше вводится понятие \textit{корректного перехода из конфигурации} $A$ в какие-то другие конфигурации.
	Чтобы сгенерировать список этих конфигураций, надо сделать следующее:
	\begin{enumerate}
		\item Рассмотреть все переходы из текущего состояния конфигурации $A$.
		\item Оставить из них только те переходы, у которых символ $c_i$ совпадает с символом на позиции головки на ленте $i$
		\item
			Для каждого из оставшихся сказать, что мы можем перейти в конфигурацию, у которой текущее состояние изменено с $q$ на $r$,
			символы $c_i$ на лентах заменены на символы $c_i'$, соответственно, а позиции головок на каждой ленте независимо изменены в соответствии с $m_i$:
			\begin{itemize}
				\item При $\la$ головка сдвигается на единицу влево
				\item При $\cdot$ головка остаётся на месте
				\item При $\ra$ головка сдвигается на единицу вправо
			\end{itemize}
	\end{enumerate}
	\begin{Rem}
		Можно формально определить бинарное отношение <<быть корректным переходом>> между состояниями,
		аккуратно расписав алгоритм выше.
	\end{Rem}
	\begin{Rem}
		Никакая головка не должна уезжать за край ленты.
		Есть разные способы этого добиться.
	\end{Rem}

\subsubsection{Модификации}
	Все модификации МТ ниже в разном смысле эквивалентны друг другу, мы выбираем ту, в которой удобнее работать в данной задаче.
	Для доказательства эквивалентности двух моделей, надо выбрать машину в модели $A$ и построить эквивалентную ей машину в модели $B$.
	Под эквивалентностью можно понимать что-то из следующего:
	\begin{itemize}
		\item Обе машины решают задачу распознавания одного и того же языка
		\item Обе машины вычисляют одну и ту же функцию
		\item Обе машины используют одно и то же количество памяти (это может быть неправда при переделке ДМТ в НМТ)
		\item Обе машины работают за одно и то же время, или хотя бы время работы различается лишь не более, чем в фиксированную константу раз (это, опять же, не так для ДМТ и НМТ)
	\end{itemize}

	\begin{Def}
		\textit{Детерминированная машина Тьюринга} (ДМТ) "--- если зафиксировать начальное состояние и множество символов под лентой, то переход либо есть и ровно один, либо его нет.
		Если перехода нет, то можно либо отвергать слово, либо переходить в какое-то спецсостояние (эквивалентно).
		Можно считать, что все переходы всегда должны быть (эквивалентно).
	\end{Def}
	\begin{Rem}
		Если у ДМТ зафиксировать конфигурацию, то следующая конфигурация (если есть) всегда определяется однозначно.
		Поэтому можно говорить о том, что ДМТ что-то однозначно вычисляет (или зацикливается).
	\end{Rem}
	\begin{Def}
		На ДМТ можно вычислять функции: на фиксированную (входную) ленту пишем вход, запускаем ДМТ, пока не завершиться, после этого ожидаем на фиксированной ленте (выходной) получить ответ.
	\end{Def}
	\begin{Def}
		На ДМТ также можно вычислять ответы <<да/нет>>: говорим, что ДМТ обязана завершать работу в ровно одном из двух состояний "--- $q_{yes}$ или $q_{no}$, и именно этим определяется результат работы.
	\end{Def}
	\begin{Rem}
		Чтобы головка не уезжала налево за край ленты, можно считать по-разному:
		\begin{itemize}
			\item Переход, при котором головка уезжает налево некорректен
			\item Если головка уезжает налево, вычисление прекращается.
		\end{itemize}
	\end{Rem}

	\begin{Def}
		\textit{Недетерминированная машина Тьюринга} (НМТ) "--- без подобных ограничений, может быть несколько корректных переходов из одной конфигурации.
	\end{Def}
	\begin{Def}
		НМТ принимает слово $x$, если есть такая последовательность корректных переходов, что машина останавливается в состоянии $q_{yes}$.
	\end{Def}
	\begin{Rem}
		Также иногда говорят, что НМТ-машина помимо входа принимает некоторую \textit{подсказку}, которая указвает, какой переход делать в случае неоднозначности.
		Например: НМТ принимает слово, если она принимает его хотя бы с одной подсказкой и отвергает, если нет такой подсказки.
	\end{Rem}
	\begin{Rem}
		Для НМТ может быть наглядно рисовать дерево вычислений: в корне стоит начальная конфигурация, детьми вершины-конфигурации являются конфигурации,
		в которые НМТ может перейти.
		В таком дереве лист является законченным вычислением.
		Тогда время работы "--- глубина дерева.
	\end{Rem}

\subsubsection{Метрики}
	\begin{Def}
		\textit{Время работы $M$} "--- количество шагов.
	\end{Def}
	\begin{Def}
		\textit{Используемая $M$ память} "--- сумма следующей величины по всем лентам: максимальное правое положение головки на ленте.
	\end{Def}
	\begin{exmp}
		Если машина на двух лентах сначала отвела первую головку вправо на 10, потом вернула, потом сделала то же самое со второй головкой,
		то используемая память "--- $10+10=20$.
	\end{exmp}

	\begin{Def}
		На НМТ время работы и память вычисляются так: независимо берётся максимум по всем веткам.
		То есть если в одной ветке время было 2 и память 5, а в другой "--- время 3 и память 4, то время работы машину будет 3, а память "--- 4.
	\end{Def}
	\begin{assertion}
		Мы можем считать, что если у конкретной НМТ всегда каким-то разумным образом ограничено время работы и память в той последовательности переходов,
		которая ведёт к принятию слова (например, на входе $x$ будет сделано не более $f(|x|)$ переходов и не более $g(|x|)$ памяти),
		то она \textbf{всегда} использует не более $\O(g(|x|))$ памяти и $\O(f(|x|))$ времени.
	\end{assertion}
	\begin{proof}
		Давайте возьмём произвольную НМТ с функциями $f$ и $g$.
		Заставим эту НМТ параллельно с её основной работой считать используемую память и количество сделанных шагов на отдельных лентах
		(предполагаем, что значения $f$ и $g$ для конкретного входа мы можем вычислить быстро).
		Если в какой-то момент машина обнаруживает, что она сделала уже больше $f(|x|)$ шагов или использует более $g(|x|)$ памяти,
		то она точно уверена, что в этой ветке ей уже можно слово отвергать и завершаться.
		Если слово не принималось НМТ, то оно и не станет приниматься, а вот если принималось, то хотя бы одна ветка останется (но какие-то длинные могут и исчезнуть).
		Это называется <<полиномиальный будильник>> и может встречаться не только в НМТ, но и в ДМТ (например, если мы знаем, что ДМТ всегда находит ответ при его существовании
		за короткое время).
	\end{proof}

	\begin{Rem}
		Иногда бывает так, что МТ должна использовать памяти меньше, чем вход.
		Тогда считают, что лента со входом доступна только на чтение (т.е. мы всегда пишем на неё тот же символ, что и прочитали)
		и в общую память она не входит.
	\end{Rem}

\subsection{Классы $\P$ и $\NP$}
	\begin{Def}
		Массовая задача $R$ \textit{полиномиально ограничена} (п.о.), если существует полином $p$, ограничивающий длину кратчайшего решения для каждого входа,
		на котором вообще есть ответ:
		\[
			\forall x \colon (\exists w \colon (x, w) \in R) \Ra \exists w \colon (x, w) \in R \land |w| \le p(|x|)
		\]
		Длина решения зависит полиномиально от длины входа.
	\end{Def}
	\begin{Def}
		Массовая задача $R$ \textit{полиномиально проверяема} (п.п.), если существует ДМТ $M$ и полином $q$, ограничивающий время проверки решения:
		\[
			(x, w) \in R \iff M((x, w))=1
		\]
		Причём вычисление $M((x, w))$ всегда завершается не более, чем за $q(|(x, w)|)$ шагов.
	\end{Def}
	\begin{Rem}
		Можно считать, что $q$ на самом деле от двух переменных, можно считать, что он от $|x|+|w|$ "--- это всё будет эквивалентно.
	\end{Rem}

	\begin{Def}
		$\widetilde{\NP}$ "--- класс п.о. п.п. задач поиска, т.е. это все п.о. п.п. массовые задачи, которым мы задаём вопрос <<а какое есть решение у данного условия?>>
	\end{Def}
	\begin{Rem}
		Дальше будет класс $\NP$, в нём тоже будут лежать п.о. п.п. массовые задачи, однако им мы уже будем задавать вопрос <<есть ли решение у данного условия?>>.
		Можно считать $\widetilde{\NP}$ классом (некоторым множеством) массовых задач, а $\NP$ "--- классом языков.
	\end{Rem}

	\begin{Def}
		$\widetilde{\P}$ "--- подкласс $\widetilde{\NP}$, причём для каждой задачи $R$ должно быть для каждого условия $x$ найти за полиномиальное от $x$ время какое-нибудь решение.
	\end{Def}
	\begin{Rem}
		Можно считать, что если решения нет, то мы это тоже за полиномиальное время узнаём.
		Или зацикливаемся.
		Это эквивалентно "--- добавляем будильник в МТ.
	\end{Rem}

	\begin{Def}
		$\NP$ "--- все языки, порождаемые массовыми задачами из $\widetilde{\NP}$.
		Т.е. задача $A \in \widetilde{\NP}$ порождает язык из условий $x$ таких, что $\exists w \colon (x, w) \in A$.
	\end{Def}
	\begin{Def}
		$\P$ "--- все такие языки $A$, что: есть ДМТ $M$ и полином $q$, причём для любого слова $x$ $M(x)=A(x)$ и машина отработает не больше, чем за $q(|x|)$.
	\end{Def}
	\begin{assertion}
		Это определение эквивалентно такому: $\P$ "--- все языки, порождаемые $\widetilde{\P}$.
	\end{assertion}
	\begin{proof}
		\begin{description}
			\item[$L(\widetilde{\P}) \subseteq \P$]:
				взяли язык $A$ из левой части.
				Запустили алгоритм, ищущий решение.
				Если он нашёл, то условие принадлежит соответствующему языку, иначе не принадлежит.
			\item[$\P \subseteq L(\widetilde{\P})$]:
				взяли язык $A \in \P$.
				Ему можно сопоставить массовую задачу $A'$:
				\[ (x, w) \in A' \iff (x \in A) \land (w=\epsilon) \]
				Очевидно, она лежит в $\widetilde{\NP}$ и для каждого условия $x$ можно либо найти решение $\epsilon$, либо сказать, что решений нет.
				Проверку существования решения за полиномиальное время сделать сумеем.
		\end{description}
	\end{proof}

	\begin{assertion}
		Второе определение $\NP$: это все такие языки, для которых существует полиномиальная ДМТ, которая проверяет слово из языка при наличии подсказки.
		При этом наличие хотя бы одной подсказки эквивалентно тому, что слово в языке.
	\end{assertion}
	\begin{assertion}
		Третье определение $\NP$: это все такие языки, которые можно разрешить на полиномиальной НМТ.
	\end{assertion}

\subsection{Сведение по Карпу}
	Это то, что обычно подразумевается под <<сведением задач>> (в случае задач распознавания).

	Задача $L_1$ сводится по Карпу к $L_2$, если есть такая полиномиально вычислимая $f$, что:
	\[ x \in L_1 \iff f(x) \in L_2 \]
	То есть если хотим решить задачу $L_1$, то можно вычислить $f(x)$, решить задачу $L_2$ и сразу получить ответ на исходную.
	Тут важно, что ответ мы хотим получить сразу.
	Например, тогда подсказки для $L_2$ мы сразу можем назвать подсказками для $L_1$, а вот если бы, скажем, ответ инвертировали, то так сделать было бы нельзя.

	\begin{assertion}
		Классы $\P$, $\NP$ замкнуты относительно сведения по Карпу, т.е. если $R_2 \in \P$, то сводимая к ней $R_1$ тоже лежит в $\P$
	\end{assertion}

\subsection{Сведение по Левину}
	Это то, что обычно подразумевается под <<сведением задач>> (в случае задач поиска).
	Опять же, использовать в будущем не будем.

	Задача $R_1$ сводится по Левину к $R_2$, если есть три функции $f, g, h$ такие, что (тут по $x_i, y_i$ стоят кванторы всеобщности):
	\begin{enumerate}
		\item $f(x_1)$ по условию для $R_1$ возвращает за полиномиальное время условие для $R_2$.
		\item Если есть решение $R_1$, то есть не сильно большее решение $R_2$:
			\[ R_1(x_1, y_1) \Ra R_2(f(x_1), g(x_1, y_1)) \]
			Причём $g$ "--- п.о. (но необязательно полиномиально вычислима).
		\item Если известно решение $R_2$, то его можно быстро переделать в решение $R_1$: 
			\[ R_2(f(x_1), y_2) \Ra R_1(x_1, h(f(x_1), y_2)) \]
			При этом функция $h$ принимает только $f(x_1)$, а не сам $x_1$, и работает за полиномиальное время.
	\end{enumerate}
	\begin{Rem}
		Смысл такой: если у нас есть условие для $R_1$, то мы можем посчитать условие для $R_2$ (функцией $f$), решить задачу $R_2$ и получить для неё ответ,
		получить ответ для $R_1$ (функцией $h$).
		Функция $g$ нужна только для того, чтобы гарантировать, что ответ на задачу $R_2$ будет не очень большой.
	\end{Rem}
	\begin{Rem}
		Иногда <<для красоты>> требуют, чтобы функция $g$ тоже была полиномиально вычислима.
		Нам это вроде не было важно.
	\end{Rem}

	\begin{Rem}
		Сведение по Левину имеет смысл только в том случае, если мы говорим о задачах с конкретными сертификатами.
		Сведение же по Карпу в некотором смысле более общее "--- оно сводит языки.
	\end{Rem}
	\begin{assertion}
		Если задача $R_1$ сводится по Левину к $R_2$, то язык $L(R_1)$ сводится по Карпу к $L(R_2)$
	\end{assertion}
	\begin{proof}
		Функция $f$ для сведения по Карпу будет взята из сведения по Левину.
		В самом деле, два случая:
		\begin{description}
			\item[$x \in L(R_1)$:]
				Тогда мы точно знаем, что есть некоторый $y_1$, причём $(x, y_1) \in R_1$.
				Следовательно, по сведению по Левину есть такой $y_2=g(x_1, y_1)$, что $(f(x_2), y_2) \in R_2$.
				Значит, $x \in L(R_1) \Ra f(x) \in L(R_2)$.
			\item[$x \notin L(R_1)$:]
				Хотим показать, что тогда $f(x) \notin L(R_2)$.
				Предположим противное: $f(x) \in L(R_2)$.
				Тогда есть некоторый $y_2$ такой, что $(f(x), y_2) \in R_2$.
				Тогда из сведения по Левину знаем, что $(f(x, h(f(x), y_2)) \in R_1$, т.е. $x \in L(R_1)$,
				противоречие.
		\end{description}
	\end{proof}

	\begin{assertion}
		Классы $\widetilde{\P}$, $\widetilde{\NP}$ замкнуты относительно сведения по Левину, т.е. если $R_2 \in \P$, то сводимая к ней $R_1$ тоже лежит в $\P$
	\end{assertion}

\subsection{Полные задачи}
	Тут определяется и для классов задач поиска, и для классов задач распознавания.

	\begin{Def}
		Задача $A$ "--- \textit{трудная для класса $C$} (или \textit{$C$-трудная}), если произвольная задача $B \in C$ сводится к $A$ (по Карпу или Левину).
	\end{Def}
	\begin{Def}
		Задача $A$ "--- \textit{полная для класса $C$} (или \textit{$C$-полная}), если она $C$-трудная и лежит в классе $C$.
	\end{Def}

	\begin{Def}
		Класс $\NP$-полных задач обозначается $\mathsf{NPC}$.
	\end{Def}

\subsection{Задача об ограниченной остановке}
	\begin{Def}
		$\t{1}^t$ "--- так обозначается строка из $t$ единиц.
	\end{Def}
	\begin{Def}
		Задача $\mathsf{BH}$ (\textit{об ограниченной остановке}) "--- это множество троек $(M, x, \t{1}^t)$ таких, что:
		\begin{enumerate}
			\item
				$M$ "--- недетерминированная машина Тьюринга
			\item
				Существует подсказка $w$ для $M$ такая, что $M(x, w)$ останавливается и принимает $x$.
				\begin{Rem}
					Конечно же, $|w| \le t$, так как у нас машина после $t$ шагов будет остановлена.
				\end{Rem}
		\end{enumerate}
	\end{Def}

	\begin{theorem}
		$\mathsf{BH}$ является $\NP$-трудной.
	\end{theorem}
	\begin{proof}
		Возьмём произвольный язык $L \in \NP$.
		По определению для него есть НМТ $M_L$ такая, что:
		\[ x \in L \iff M_L(x) = 1 \]
		причём $M_L$ принимает $x$ за время не большее $p(|x|)$, где $p$ "--- полином.

		Давайте сводить $L$ к $\mathsf{BH}$ по Карпу, строя п.о. п.п. функцию $f$.
		Наша функция $f$ будет по входу $x$ выдавать машину $M_L$ (она константа и не зависит от $x$),
		потом "--- сам вход $x$, а потом "--- $1^{p(|x|)}$.
		Очевидно, что $x \in L \iff f(x) \in \mathsf{BH}$, просто по определению $\NP$.

		Также понятно, что $f$ полиномиально вычислима и, следовательно, полиномиально ограничена
		(мы верим, что вычислить значение полинома и вывести столько единиц мы справимся).
	\end{proof}

	\begin{theorem}
		$\mathsf{BH}$ является $\NP$-полной.
	\end{theorem}
	\begin{proof}
		Эта задача уже точно является $\NP$-трудной, осталось показать, что она лежит в $\NP$.

		Для этого просто строим универсальную недетерминированную машину Тьюринга, которая будет эмулировать данную на вход НМТ
		в течение не более $t$ шагов, а когда эмулируемой НМТ потребовалось принять недетерминированное решение, наша универсальная машина тоже
		будет принимать недетерминированное решение.
		\begin{Rem}
			Осторожно с построением универсальных машин: нам важно, чтобы замедление было максимум полиномиальным от $t$ и чтобы эмулируемая машина
			могла иметь произвольное число лент (а универсальная "--- лишь константное), см. билет 2.
		\end{Rem}
	\end{proof}
