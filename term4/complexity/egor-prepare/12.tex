\setcounter{section}{11}
\section{Билет 12}
	\begin{Def}
		Язык $\QBF$ состоит из замкнутых формул в предварённой форме с конечным количеством кванторов.
		а под всеми кванторами "--- формулама в ДНФ или КНФ.
	\end{Def}
	\begin{Rem}
		Отличие от $\QBF_k$ в том, что в $\QBF_k$ количество чередований квантор ограничено числом $k$.
		Схожесть в том, что и там, и там может быть произвольное (но конечное) число кванторов и переменных.
	\end{Rem}
	\begin{Rem}
		Мы не знаем, лежит ли $\QBF$ в каком-нибудь уровне полиномиальной иерархии.
	\end{Rem}

	\begin{lemma}
		$\QBF \in \PSPACE$
	\end{lemma}
	\begin{proof}
		Давайте перебирать значения переменных, начиная с внешних.
		На это требуется экспоненциальное время, но всего полиномиальная память.
		После того, как знаем значения переменных, можно честно посчитать значение формулы под кванторами.
		Если очередной квантор "--- $\forall$, то надо, чтобы обе ветки перебора вернули \t{true},
		если $\exists$, то надо, чтобы хотя бы одна ветка перебора вернула \t{true}.
	\end{proof}

	\begin{theorem}
		$\QBF$ "--- $\PSPACE$-полная
	\end{theorem}
	\begin{proof}
		Нам осталось показать, что произвольная задача $L \in \PSPACE$ сводится к $\QBF$.
		Зафиксируем $L$ и какую-нибудь полиномиальную по памяти ДМТ $M$, разрешающую $L$.
		Не умаляя общности считаем, что в случае принятия слова машина $M$ очищает всю память
		и переходит в фиксированное состояние, т.е. конфигурация принятия ровно одна.

		Пусть нам дали вход $x$ длины $n$.
		Идея такая: рассмотрим (чисто теоретически) граф конфигураций $M$, он имеет размер $2^{p(n)}$ (где $p(n)$ "--- время работы $M$).
		Одна его вершина кодируется $p(n)$ битами.
		Ребро из вершины в вершину есть тогда и только тогда, когда можно перейти из одной конфигурации в другую.
		Если мы сможем быстро возвести матрицу смежности этого графа (с добавленными петлями) в степень $2^{\lceil\log p(n)\rceil}$
		и посмотреть на наличие ребра между начальной конфигурацией для входа $x$ и принимающей, то мы решим задачу.

		Давайте научимся строить предикатные формулы $\phi_i(a, b)$ полиномиального (от $n$) размера.
		Формула $\phi_i(a, b)$ должна выдавать единицу тогда и только тогда, когда есть путь
		из конфигурации $a$ в $b$ длины не более $2^i$.
		У формулы $\phi_i$ имеется $2p(n)$ булевых входов, сама она должна быть размера не более $q(p(n))$.

		$\phi_0$ строится довольно просто (как в теореме Кука-Левина): у нас есть константное число переходов
		в $M$, надо проверить каждый при помощи формулы полиномиальной длины (т.е. что символы под головками корректны до чтения и после записи и т.д.).

		$\phi_{i+1}(a, b)$ строится так: надо найти промежуточную вершину $c$ и проверить
		достижимость $\phi_i(a, c) \land \phi_i(c, b)$.
		К сожалению, это будет экспоненциальное разрастание, поэтому надо чуть схитрить, оставить лишь одно вхождение $\phi_i$
		и добавить кванторы:
		\[ \phi_{i+1}(a, b) \eqDef \exists c \colon \forall x, y \colon (((x, y) = (a, c) \lor ((x, y) = (c, b))) \to \phi_i(x, y))\]
		Получаем, что размер $\phi_{i+1}$ лишь на $p(n)$ (размер одной переменной) больше размера $\phi_i$, т.е. полиномиален от $n$ при фиксированном $i$.

		Теперь для окончательной проверки надо записать формулу $\phi_{\lceil p(n) \rceil}(A, B)$,
		где $A$ "--- единственная начальная конфигурация, а $B$ "--- единственная конечная.
		Это что-то полиномиального от $n$ размера.
		Потом надо привести эту формулу в предварённую нормальную формулу и получить готовый запрос к $\QBF$.
		Для приведения в предварённую форму надо переименовать переменные и вынести все кванторы влево, не меняя их последовательности.
	\end{proof}
	\begin{conseq}
		Если $\PSPACE=\PH$, то иерархия коллапсирует, так как тогда $\QBF$ лежит в каком-то уровне иерархии $\Sigma_k$,
		а тогда $\QBF_{k+1}$ лежит не выше, значит, иерархи коллапсирует до $\Sigma_k$.
	\end{conseq}
