\section{Билет 21}
\subsection{Определения}
	\begin{Def}
		\textit{Интерактивный протокол} "--- это описание процесса передачи информации между двумя независимыми устройствами: $P$ (Prover) и $V$ (Verifier).
		Передача информации происходит по раундам, в каждом раунде одно устройство передаёт какую-то информацию другому, обычно раунды чередуются
		(сначала Prover передаёт, потом Verifier, потом снова Prover...), кто начинает "--- входит в протокол.
		Полезно считать суммарный размер переданных данных.
		Prover может использовать случайные биты, может вычислять произвольные функции (в том числе невычислимые), Verifier обычно может вычислять лишь какие-то ограниченные по времени/памяти функции.
		Также Verifier может использовать случайные биты, которые Prover'у неизвестны.
	\end{Def}
	\begin{Def}
		\textit{Класс $\IP$} "--- это класс языков $L$, распознаваемых при помощи интерактивного протокола:
		\begin{enumerate}
			\item Распознаваемая строчка $x$ известна изначально и Prover, и Verifier.
			\item Суммарный размер переданных данных и число раунда должны быть п.о. размером $x$.
			\item Время работы Verifier на каждом раунде должно быть п.о. размером $x$ (соответственно, общее время работы Verifier тоже п.о.).
			\item После окончания протокола Verifier должен выдать ответ <<да/нет>>: верно ли, что $x \in L$.
			\item Если $x \in L$, то у $P$ должна существовать стратегия, которая независимо от действий Verifier (и его случайных битов) заставит Verifier сказать <<да>>
			\item Если $x \notin L$, то у $P$ нет стратегии, которая заставит Verifier сказать <<да>> с вероятностью большей $\frac 12$
		\end{enumerate}
	\end{Def}
	\begin{Rem}
		Доказывать принадлежность $\IP$ обычно надо так: сначала придумать интерактивный протокол, а дальше доказать, что правильно действующий Verifier удовлетворяет всем условиям.
		При этом важно помнить, что Prover может отвечать как угодно (в частности, не соблюдать протокол).
		Обычно полезно считать, что если Verifier <<поймал за руку Prover>> (т.е. обнаружил, что Prover нарушает протокол), то сразу надо говорить <<нет>>.
		На случай $x \in L$ это не влияет, так как Prover в этом случае может просто действовать в соответствии с протоколом.
		А в случае $x \notin L$ это обычно упрощает доказательство.
	\end{Rem}
	\begin{assertion}
		В классе $\IP$ тоже можно понижать ошибку, как и в $\RP$, т.е. для произвольного полинома $p(|x|)$ можно добиться того, чтобы
		вероятность ошибки Verifier в случае $x \notin L$ не превосходила $2^{-p(|x|)}$ для любого $x$.
	\end{assertion}
	\begin{proof}
		Просто делаем $p(|x|)$ запусков протокола, а в конце Verifier говорит <<да>> только в том случае, если во всех раундах получили <<да>>.

		Если $x \in L$, то у Prover в каждом запуске есть стратегия, значит, у него в целом есть стратегия, при которой в каждом из запуском получится ответ <<да>>.

		Если $x \notin L$, то нам надо в каждом из $p(|x|)$ запусков получить ответ <<да>> от Prover.
		Вероятность этого не превосходит $2^{-p(|x|)}$.
	\end{proof}
	\begin{Rem}
		Ещё интерактивные протоколы можно использовать для вычисления функций (например, перманента матрицы).
		Происходить будет так: в первом же раунде Prover говорит Verifier'у ответ на задачу, а дальше идёт интерактивный протокол
		для массовой задачи поиска, в котором Prover доказывает Verifier'у, что это действительно корректный ответ.
	\end{Rem}

\subsection{Протокол для неизоморфизма}
	\begin{Def}
		\textit{Язык пар неизоморфных графов}: это множество таких пар $(G, H)$, что $G$ и $H$ являются неизоморфными друг другу графами.
	\end{Def}
	\begin{exmp}
		$(C_4, K_{2,2})$ не лежат в этом языке "--- цикл из четырёх вершин изоморфен полному двудольному графу на 4 вершинах.
	\end{exmp}
	\begin{exmp}
		$(C_6, K_{3,3})$ лежат в в этом языке "--- в этих графах просто разное число рёбер.
	\end{exmp}

	\begin{theorem}
		Язык пар неизоморфных графов лежит в $\IP$.
	\end{theorem}
	\begin{proof}
		Предъявим протокол: пусть известна пара $(G_0, G_1)$.
		Verifier для начала должен проверить, что ему на вход действительно закодировали пару графов.
		Дальше Verifier случайно выбирает один бит $a$, случайным образом перенумеровывает вершины графа $G_a$, получает граф $G'$ и посылает $G'$ Prover'у.
		После этого Prover обязан возвратить Verifier'у бит $a$.
		Если Prover возвращает не тот бит, ответ "--- <<нет>>.
		
		Такой Verifier точно полиномиален, а раунд вообще всего один.

		Если $G_0$ и $G_1$ неизоморфны (т.е. $x \in L$), то Prover, увидя граф $G'$, сразу может сказать, кому из $G_0$ и $G_1$ он изоморфен, а кому "--- нет (это даже вычислимая функция).
		Значит, он точно может правильно ответить Verifier.

		Теперь пусть $G_0$ и $G_1$ изоморфны (т.е. $x \notin L$).
		Заметим, что тогда Prover получит на вход случайный граф, изоморфный одновременно и $G_0$, и $G_1$, причём все такие графы он получит равновероятно.
		На каждом входе Prover'а ровно в половине случаев этот вход был получен из $G_0$, а в половине "--- из $G_1$.
		Рукомахательное рассуждение: ясно, что Prover никакой информации из полученного графа не получает, значит, ему надо угадывать, причём равновероятно, а тогда вероятность угадать не больше $\frac 12$.

		Более строго:
		пусть в случае получения помеченного графа $H$ Prover с вероятностью $p_{H}$ выдаёт единицу, а с вероятностью $1-p_{H}$ "--- нолик.
		Тогда посчитаем вероятность того, что Prover угадал.
		Протокол может ошибиться только в том случае, если Prover угадал, в каком случае он находится.
		Посчитаем вероятность этого события, есть два случая (для фиксированного $H$):
		\begin{enumerate}
			\item Prover выдал 0 (вероятность этого "--- $p_H$), ответ был $0$ (вероятность этого "--- $\sfrac 12$).
				Значит, вероятность этого случая "--- $\frac{p_H}{2}$.
			\item Prover выдал 1 (вероятность этого "--- $1-p_H$), ответ был $1$ (вероятность этого "--- $\sfrac 12$).
				Значит, вероятность этого случая "--- $\frac{1-p_H}{2}$.
		\end{enumerate}
		Суммируем, получаем, что независимо от $H$ вероятность того, что Prover угадает, равна $\frac 12$, что и требуется для интерактивного протокола.
	\end{proof}

\subsection{Протокол для перманента}
	\begin{Def}
		\textit{Перманент} матрицы $A$ ($\perm A$) порядка $n$ "--- это как определитель, только везде знак <<плюс>>:
		\[
			\perm A \eqDef \sum_{\sigma \in S_n} a_{1,\sigma(1)} \cdot a_{2,\sigma(2)} \cdot \dots \cdot a_{n,\sigma(n)}
		\]
	\end{Def}
	\begin{Rem}
		Полиномиальный алгоритм вычисления определителя в некотором поле у нас есть (если мы считаем, что любые операции в поле идут за полином) "--- это алгоритм Гаусса
		приведения матрицы к верхнетреугольному виду.
		А вот для перманента такого счастья нет, его вычислять очень сложно (точнее, просто мы не умеем).
		Зато есть интерактивный протокол для проверки ответа, это прикольный факт.
	\end{Rem}
	\begin{Rem}
		Тем не менее, раскладывать перманент по строке или столбцу всё-таки можно "--- так же, как определитель, но знак везде <<плюс>>.
	\end{Rem}

	\begin{Rem}
		Дальше мы везде будем считать, что в задачу проверки перманента как-то входит описание поля $F$, в котором можно эффективно вычислять результаты арифметических операций.
		Например, в виде машин Тьюринга, которые выполняют операции с этим полем.
		Также нам будет важно, что размер поля достаточно большой (больше $n^4$).
	\end{Rem}
	\begin{Def}
		Язык $\mathsf{PERM}$ "--- это множество пар $(A, c)$, где $A$ "--- матрица порядка $n$, а $c$ "--- её перманент в поле $F$.
	\end{Def}
	\begin{Def}
		Язык $\mathsf{PERM_2}$ "--- это множество четвёрок $(A, B, c, d)$, где $A$ и $B$ "--- матрицы порядка $n$, а $c$ и $d$ "--- их перманенты, соответственно.
	\end{Def}
	\begin{lemma}
		Если $\mathsf{PERM}\in\IP$, то и $\mathsf{PERM_2} \in \IP$.
	\end{lemma}
	\begin{proof}
		Пусть есть четвёрка $(A, B, c, d)$.
		Если $n=1$, то Verifier может сам проверить.
		Интересный случай "--- $n>1$.

		Давайте рассмотрим такую матрицу над кольцом многочленов от одной переменной над $F$:
		\[ A'(x) = Ax + B(1-x) \in F[x] \]
		Её перманент "--- это какой-то многочлен $p$, причём $p(0)=\perm B$, $p(1)=\perm A$ и $p$ не является тождественным нулём (\TODO почему?).
		Давайте спросим у Proover перманент такой матрицы в форме коэффициентов многочлена ($n$ элементов поля $F$).
		\begin{Rem}
			Мы не запускаем ещё раз протокол внутри "--- нам в протоколе надо поле, а не кольцо.
			Мы просто просим у Proover'а многочлен, проверим потом.
		\end{Rem}
		Проверим, во-первых, что $p(0)=d$ и $p(1)=c$, иначе сразу ответим <<нет>> "--- мы либо поймали за руку, либо исходная четвёрка не лежала в языке.

		Дальше осталось проверить корректность многочлена.
		Для этого выбираем случайную точку $x$ из поля, подставляем её в многочлен (получаем значение) и в матрицу $A'$ (получаем матрицу над $F$).
		Дальше проверяем интерактивным протоколом, что $\perm (A'(x)) = p(x)$.

		Очевидно, если Prover следует протоколу, то он нас убедит.
		Оценим вероятность того, что исходная четвёрка в языке не лежит, но мы поверили Prover'у.
		Заметим, что для этого Prover должен был заведомо прислать некорректный многочлен $p$ (иначе бы не сошлось $p(0)=d \land p(1)=c$).
		Два случая:
		\begin{enumerate}
			\item
				$\perm (A'(x)) = p(x)$, то есть $(\perm A' - p)(x) = 0$, то есть случайно выбранный из поля $x$ попал в корень многочлена степени не выше $n$.
				Вероятность этого случая не больше $\frac{n}{|F|}$, в нём нас обманут с вероятностью 1 "--- сами дураки.
			\item
				$\perm (A'(x)) \neq p(x)$ (что происходит с вероятностью не больше единицы), то есть нас обманули уже во вложенном интерактивном протоколе.
				Но вероятность этого события не больше $\frac 12$.
		\end{enumerate}
		Значит, вероятность ошибки не больше:
		\[ \frac{n}{|F|} \cdot 1 + 1 \cdot \frac 12 \]
		Если $|F| > (2+\epsilon)n$, то мы получили вероятность ошибки, отделённую от единицы, её можно понижать.
	\end{proof}

	\begin{lemma}
		Если $\mathsf{PERM_2} \in \IP$, то
		задача $\mathsf{PERM_k} \in \IP$ (проверка перманентов сразу $k$ матриц) лежит в $\IP$.
	\end{lemma}
	\begin{proof}
		Аналогично предыдущей лемме сначала склеим первые две матрицы в одну, потом получившуюся с третьей, с четвёртой и так далее.
		А в конце сделаем один запуск интерактивного протокола.
		\begin{Rem}
			Сделать $n$ запусков интерактивного протокола мы не можем, так как тогда время работы протокола разрастётся экспоненциально.
		\end{Rem}

		Заметим, что Prover может нас обмануть и заставить сказать <<да>> только в том случае, если мы хотя бы на каком-то шаге выбрали неправильный $x$ (попавший в корень), либо уже
		в финальном запуске.
		Вероятность выбрать неправильный $x$ на каком-то шаге не превышает $n\cdot\frac{n}{|F|} = \frac{n^2}{|F|}$, то есть нам надо иметь поле размера хотя бы $n^2(1+\epsilon)$, чтобы получить отделённую от единицы вероятность ошибки.
	\end{proof}

	\begin{theorem}
		$\mathsf{PERM} \in \IP$
	\end{theorem}
	\begin{proof}
		Взяли матрицу $A$ порядка $n$ и константу $c$.
		Если $n=1$, то Verifier может сам проверить ответ.

		Иначе разложим перманент по первой строке и попросим у Prover'а перманенты соответствующих миноров:
		\[
			\perm A = a_1 \cdot A_1 + a_2 \cdot A_2 + \dots + a_n \cdot A_n
		\]
		Во-первых, проверим, что сумма сошлась с константой $c$, иначе либо ответ сразу <<нет>>, либо мы поймали за руку.

		Дальше выполним интерактивный протокол для задачи $\mathsf{PERM_{n-1}}$ для проверки перманентов сразу всех матриц $A_i$.
	\end{proof}

	\begin{Rem}
		Если оценивать сразу, а не через уменьшение ошибки (так вообще можно?), то можно взять поле размера $n^3(1+\epsilon$ и получить ошибку не более $\frac{1}{1+\epsilon}$.
		У нас всего в протоколе будет порядка $n^2$ выборов $x$, каждый неверен с вероятностью не более $\frac{n}{|F|}$, значит вероятность ошибки хоть где то не более $\frac{n^3}{|F|}$.
	\end{Rem}
