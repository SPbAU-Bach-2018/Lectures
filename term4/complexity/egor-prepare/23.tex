\setcounter{section}{22}
\section{Билет 23}
\subsection[Классы AM и MA]{Классы $\AM$ и $\MA$}
	\begin{Def}
		Классы вроде $\mathsf{MAAMAMAMA}$ "--- это как $\IP$, но со следующими отличиями:
		\begin{enumerate}
			\item Prover зовётся Мерлин, а Verifier зовётся Артур
			\item Случайные биты, которые использует Артур, становятся доступны Мерлину (но только после того, как он их сгенерировал)
			\item Число раундов равно длине строки-названия класса
			\item На $i$-м раунде передаёт информацию тот, чья буква стоит на $i$-м месте
		\end{enumerate}
	\end{Def}
	\begin{Rem}
		Бессмысленно пихать две одинаковые буквы подряд "--- зачем разбивать передачу данных на два раунда?
	\end{Rem}
	\begin{Rem}
		Можно считать, что Мерлин знает, как работает Артур и поэтому на самом деле Артуру ничего говорить Мерлину (кроме случайных бит) не нужно.
		Ему нужно только в конце сказать, верит он или не верит.
		Требуется, чтобы Артур ошибался с вероятностью не более $\frac 13$.
	\end{Rem}
	\begin{Rem}
		Есть ещё классы с односторонней ошибкой "--- $\AM_1$ и $\MA_1$, тут требуется, чтобы в случае $x \in L$ Артур никогда не ошибался.
	\end{Rem}
	\begin{Rem}
		Иногда тут тоже зовут Prover/Verifier, но оговариваются, что у нас private coin (приватные случайные биты).
	\end{Rem}
	\begin{Rem}
		\[ \NP \subset \MA \subset \AM \]
	\end{Rem}

	\begin{assertion}
		В $\mathsf{MA}$ можно понижать ошибку до $2^{-poly(n)}$ лишь полиномиальным увеличением времени работы ($n$ "--- размер входа).
	\end{assertion}
	\begin{proof}
		Мерлин присылает нам одну подсказку, мы её $\approx poly(n)$ раз тестируем, выдаём majority.
		Оценка "--- как обычно, через неравенство Чернова.
		В каждом раунде мы ошибёмся с вероятностью не более $\sfrac 13$.
	\end{proof}

	\begin{assertion}
		В $\mathsf{AM}$ можно понижать ошибку до $2^{-poly(n)}$ лишь полиномиальным увеличением времени работы ($n$ "--- размер входа).
	\end{assertion}
	\begin{proof}
		Пусть Артур выкинет не один набор случайных бит, а столько, сколько надо для $\approx poly(n)$ раундов.
		Мерлин пришлёт по подсказке на каждый раунд, мы их все тестируем, берём majority.
		Важное наблюдение для доказательства "--- все раунды независимы в том смысле, что Мерлин либо может на каких-то случайных битах
		нас убедить, либо не может.
		Если мог, но не воспользовался "--- он сам дурак.

		Если $x \in L$, то в каждом раунде нам либо повезло с подсказкой (и Мерлин может ответить), либо не повезло.
		Majority этих событий с хорошей вероятностью <<повезло>>.

		Если $x \notin L$, то в каждом раунде нам либо не повезло с подсказкой (и Мерлин может ответить), либо повезло (и Мерлин не может).
		Majority этих событий с хорошей вероятностью <<не повезло>>.
	\end{proof}

\subsection{Попарно независимые хэш-функции}
	\begin{Def}
		Семейство хэш-функций $H$, которые действуют из $\{0, 1\}^n$ в $\{0, 1\}^k$ является \textit{попарно независимым семейством}, если:
		\begin{enumerate}
			\item Каждый элемент равновероятно (по функции) отправляется в любой хэш:
				\[ \forall x \in \{0, 1\}^n \colon \forall \{0, 1\}^k \colon \Pr_h \{ h(x) = y \} = \frac{1}{2^k} \]
			\item Каждые два разных элемента равновероятно (по функции) отправляется в любые два хэша (может, одинаковых):
				\[ \forall x, x' \in \{0, 1\}^n \colon \forall y, y' \{0, 1\}^k \colon (x \neq x') \Ra \Pr_h \{ h(x) = y \land h(x') = y' \} = \frac{1}{2^{2k}} \]
		\end{enumerate}
	\end{Def}

	\begin{assertion}
		Без доказательства: для любого $n \ge 1$ существует поле с $2^n$ элементами.
	\end{assertion}
	\begin{theorem}
		Если $k=n$, то есть попарно независимое семейство хэш-функций.
	\end{theorem}
	\begin{proof}
		Случай $n=0$ неинтересен.
		Иначе скажем, что наши битовые строчки (и размера $n$, и размера $k$) соответствуют элементам поля.
		Тогда возьмём семейство из $2^{2n}$ хэш-функций, индексируемых двумя элементами поля:
		\[ h_{a,b}(x) = ax + b \]

		Покажем, что каждый элемент равновероятно (по функции) отправляется в любой хэш.
		Зафиксируем $x$ и $y$, посчитаем число решений уравнения $ax+b=y$ (относительно $a$ и $b$).
		Очевидно, что для каждого возможного $a$ существует ровно одно подходящее $b$, т.е. всего решений $2^{k}$,
		а всего хэш-функций "--- $2^{2k}$, получили нужную вероятность.

		Покажем, что для двух элементов тоже выполняется что надо.
		Зафиксируем $x \neq x'$, $y$, $y'$.
		Посчитаем число решений системы:
		\begin{gather*}
			\begin{cases}
				ax + b = y \\
				ax' + b = y'
			\end{cases}
			\iff
			\begin{cases}
				ax + b = y \\
				a(x'-x) = y'-y
			\end{cases}
			\circleeq{\iff} \\
			\text{так как $x'-x\neq 0$} \\
			\circleeq{\iff}
			\begin{cases}
				b = y - ax \\
				a = \frac{y'-y}{x'-x}
			\end{cases}
		\end{gather*}
		Получаем, что решение всегда единственно.
		Значит, вероятность действительно равна $\frac{1}{2^{2k}}$.
	\end{proof}
	\begin{conseq}
		Если $k>n$, то есть семейство попарно независимых хэш-функций.
	\end{conseq}
	\begin{proof}
		Давайте построим семейство попарно независимых хэш функций из $\{0,1\}^k$ в $\{0,1\}^k$.
		После этого возьмём в точности его, а чтобы хэш-функции стали принимать строки короче (длины $n<k$),
		будем их просто добивать нулями.
		Так как у нас вероятности берутся по хэш-функциям, а по входам стоят только кванторы всеобщности, ничего не поменялось "--- мы лишь ослабили условия.
	\end{proof}
	\begin{conseq}
		Если $k<n$, то есть семейство попарно независимых хэш-функций.
	\end{conseq}
	\begin{proof}
		Давайте построим семейство попарно независимых хэш функций из $\{0,1\}^n$ в $\{0,1\}^n$.
		После этого возьмём в точности его, а чтобы хэш-функции стали выдавать хэши короче (длины $k<n$),
		обрежем хэши.
		Теперь получим, что условие $h(x)=y$ на самом деле (в исходном семействе) равносильно дизъюнкции $2^{n-k}$ аналогичных условий для исходного семейства.
		Но все эти условия дизъюнктны.
		То есть вероятность можно просто сложить, получить, что надо: $2^{-n} \cdot 2^{n-k} = 2^{-k}$.
		Аналогично для второго условия.
	\end{proof}

\subsection{Протокол Гольдвассер-Сипсера}
	Раздел 1.16.2 в конспекте Оли, и \href{http://neerc.ifmo.ru/wiki/index.php?title=\%D0\%9F\%D1\%80\%D0\%BE\%D1\%82\%D0\%BE\%D0\%BA\%D0\%BE\%D0\%BB_\%D0\%93\%D0\%BE\%D0\%BB\%D0\%B4\%D0\%B2\%D0\%B0\%D1\%81\%D1\%81\%D0\%B5\%D1\%80-\%D0\%A1\%D0\%B8\%D0\%BF\%D1\%81\%D0\%B5\%D1\%80\%D0\%B0_\%D0\%B4\%D0\%BB\%D1\%8F_\%D0\%BE\%D1\%86\%D0\%B5\%D0\%BD\%D0\%BA\%D0\%B8_\%D1\%80\%D0\%B0\%D0\%B7\%D0\%BC\%D0\%B5\%D1\%80\%D0\%B0_\%D0\%BC\%D0\%BD\%D0\%BE\%D0\%B6\%D0\%B5\%D1\%81\%D1\%82\%D0\%B2\%D0\%B0}{викиконспекты}.

	\begin{theorem}
		Пусть есть некоторое множество $S \subseteq \{0, 1\}^n$ и для каждого $x \in S$
		есть сертификат его принадлежности $S$ (полиномиальный от $n$, полином один на всё $S$),
		а если $x \notin S$, то такого сертификата нет.
		Также есть фиксированное число $K$.

		Тогда можно построить протокол из $\mathsf{AM}$ такой, что если $|S| \ge k$, то с вероятностью $\sfrac 23$ протокол говорит <<да>>,
		а если $|S| \le \sfrac{K}{2}$, то с вероятностью $\sfrac 23$ говорит <<нет>>
	\end{theorem}

\subsection{Применение протокола Гольдвассер-Сипсера}
	Если у нас был протокол, который использовал приватные случайные биты, то можно его переделать в протокол, который использует публичные биты.
	Просто теперь Мерлин убеждает Артура, что множество случайных бит, в которых бы Verifier поверил Prover'у в закрытой игре, довольно большое.
	Сертификат элемента множества (случайных бит) "--- это как раз ответ Prover'а.
