\setcounter{section}{14}
\section{Билет 15}
\subsection[{NSpace[log n] <= NC2}]{$\NSpace[\log n] \subseteq \NC^2$}
	Пусть есть НМТ $M$, распознающая язык $L$ с $\O(\log n)$ памяти.
	Давайте построим logspace-равномерное семейство схем глубины $\O(\log^2 n)$, которое распознает этот же язык.
	Для этого будем строить алгоритм, выводящий схему для слов определённой длины как композицию двух logspace-функций:
	\begin{enumerate}
		\item
			Построение по входу $x$ схемы глубины $\O(1)$, выводящей описание
			графа псевдоконфигураций $M$ (т.е. конфигураций без учёта состояния входной ленты, так как она read-only).
		\item Проверка достижимости принимающей псевдоконфигурации из начальной в данном графе.
	\end{enumerate}
	Пункт 2 обсуждался в предыдущем билете (там получалась схема как раз глубины $\O(\log^2 n)$), так что сконцентрируемся на первом.

	Пусть нам дали длину $n$.
	Мы знаем, что всего у $M$ будет $p(n)$ .
	Давайте построим граф на $p(n)$ вершинах.
	Из каждой конфигурации в каждую другу может либо вести ребро, либо не вести "--- это либо однозначно определено, либо
	зависит от конкретного бита во входе МТ (так как на вход указывает ровно одна головка).
	Соответственно, схема в каждом бите будет выводить либо константу, либо какой-то конкретный бит входа (либо его отрицание).
    Наш logspace-алгоритм просто перебирает все пары псевдоконфигураций (на это требуется $\O(\log n)$ памяти) и смотрит,
    возможен ли между ними переход в зависимости от бита на входной ленте.

    В итоге наша схема состоит из двух частей: первая, глубины $\O(1)$, строит матрицу смежности графа псевдоконфигураций,
    а вторая, глубины $\O(\log^2 n)$, быстро возводит эту матрицу в степень.

\subsection[{DSpace[log n] <= NSpace[log n]}]{$\DSpace[\log n] \subseteq \NSpace[\log n]$}
	Очевидно, так как любая ДМТ является заодно и НМТ.

\subsection[{NC1 <= DSpace[log n]}]{$\NC^1 \subseteq \DSpace[\log n]$}
	\begin{lemma}
		По описанию схемы глубины $d$ и её входам можно с использованием $\O(\log n + d)$ памяти вычислить её выходы.
	\end{lemma}
	\begin{proof}
		Будем по очереди вычислять значение на выходах.

		Зафиксировали конкретный выход.
		Теперь давайте пойдём от него DFS'ом наверх, ко входам.
		В стеке вызовов будем хранить не номера вершин (это много памяти), а путь из этого выхода к текущей вершины: последоветельность
		нулей и единиц (в какого ребёнка пошли), т.е. $\O(d)$ памяти.
		Также надо будет хранить результаты текущих вычислений, но их не более $\O(d)$ "--- на каждом уровне у нас одна вершина сейчас вычисляется,
		у неё максимум один предок вычислен, он и хранится (если вычислено два "--- то мы уже и саму вершину посчитали).

		В каждый момент нам надо будет знать лишь номер текущей вершины (его можно хранить), иногда надо будет находить гейт, поданный на вход
		вершине (надо пробежаться по описанию всей схемы), иногда надо будет подниматься вверх по стеку (пробежимся по всему стеку и по очереди
		найдём номера вершин от выхода до текущей).

		Мы можем несколько раз посчитать значение одного и того же гейта, но в этом ничего страшного нет "--- мы всё равно посчитаем значение корректно
		и будем использовать не очень много памяти.
	\end{proof}

	Пусть у нас есть язык $L \in \NC^1$, мы хотим построить распознающий logspace-алгоритм.
	Давайте построим его как композицию logspace-алгоритма, генерирующего по длине входа схему
	и logspace-алгоритма, вычисляющего значение этой схемы на входе (у нас же схема глубины $\O(\log n)$).
