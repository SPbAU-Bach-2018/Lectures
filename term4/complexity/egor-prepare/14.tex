\setcounter{section}{13}
\section{Билет 14}
\subsection{Основные понятия}
	Под <<параллельными вычислениями>> мы дальше будем подразумевать вычисления при помощи схем.
	Схема можем вычислять произвольную функцию от слов фиксированной длины.

	\begin{Def}
		\textit{Время} вычисления схемы $C$ "--- глубина схемы (максимальная длина от какого-нибудь входа до какого-нибудь выхода).
	\end{Def}
	\begin{Def}
		\textit{Работа} схемы "--- количество гейтов.
	\end{Def}
	\begin{Rem}
		Если у нас есть схема глубины $d$ и работы $w$, то мы можем вычислить её за время $d$, используя $w$ процессоров "--- каждому процессору поручим свой гейт.
		Поэтому на схемы можно смотреть как на параллельные вычисления.
		Это, впрочем, не самое оптимальное оптимальное решение.
	\end{Rem}

	\begin{Def}
		Говорим, что гейт лежит на уровне $i$ в схеме $C$, если имеется путь от какого-то входа до этого гейта длины $i$ и нет путей длиннее.
		Другими словами, если у нас $w$ процессоров, то этот гейт мы не можем посчитать раньше, чем в момент $i$, а ровно в него "--- можем.
	\end{Def}
	\begin{Rem}
		Это отличается от уровней бхода BFS'а, потому что BFS ищет кратчайшие пути, а нам надо длиннейшие.
	\end{Rem}

	\begin{theorem}
		Принцип Брента: если есть схема $C$ глубины $d$ с $w$ гейтами, то при использовании $\lceil \frac{w}{d} \rceil$ процессоров её можно посчитать за время, не большее $2d$.
		То есть если упрощённо считать, что схема имеет на $i$-м уровне пример $\frac{w}{d}$ гейтов, которые можно считать параллельно, то мы не сильно ошибаемся.
	\end{theorem}
	\begin{proof}
		Всего в схеме $d$ уровней.
		Обозначим за $g_i$ количество гейтов на уровне $d$:
		\[ \sum_{i=1}^d g_i = w \]
		Обозначим $k \eqcolon \lceil \frac{w}{d} \rceil$ "--- число используемых процессоров.
		Тогда давайте действовать так: сначала мы считаем все гейты на первом уровне (они независимы), потом все гейты на втором и так далее.
		Между уровнями никакого параллелизма не добавляем.

		Если у нас на уровне $g_i$ гейтов, то мы можем их посчитать за время $\lceil \frac{g_i}{k} \rceil$ "--- сначала считаем параллельно первые $k$ гейтов, потом следующие $k$ и так далее.
		То есть суммарное время работы по всем уровням будет равно:
		\begin{gather*}
			\sum_{i=1}^d \lceil \frac{g_i}{k} \rceil \le
			\sum_{i=1}^d \left(\frac{g_i}{k} + 1\right) \le
			d + \sum_{i=1}^d \frac{g_i}{k} = 
			d + \frac{\sum_{i=1}^d  g_i}{k} = 
			d + \frac{w}{\lceil \frac wd \rceil} \le
			d + \frac{w}{\left(\frac wd\right)} = 2d
		\end{gather*}
	\end{proof}
	\begin{Rem}
		Если у нас меньше процессоров, то время работы пропорционально возрастает "--- теперь на каждом уровне просто надо больше шагов.
	\end{Rem}
	\begin{Rem}
		Если у нас больше процессоров, то время работы может не измениться, если на каждом уровне схемы ровно $\frac{w}{d}$ гейтов, зависящих от всех на предыдущем уровне.
	\end{Rem}

\subsection{Арифметические операции}
	\begin{lemma}
		Посчитать выражение $a_1 \lor \dots \lor a_n$ можно схемой глубины $\O(\log n)$
	\end{lemma}
	\begin{proof}
		Просто рисуем двоичное дерево: на первом уровне у нас есть отдельные $a_i$, на втором мы считаем логическое <<или>> пар соседних,
		на третьем "--- логическое <<или>> четвёрок соседних (пользуясь вторым уровнем) и так далее.
	\end{proof}
	\begin{Rem}
		Аналогично можно действовать с любой ассоциативной операций, например, с $\oplus$ или с $\land$.
		Более того, точно так можно действовать даже когда операция в качестве аргументов принимает не биты, а последовательности из $k$ бит (где $k$ "--- константа).
		Тогда, правда, глубина домножится на глубину вычисления функции от двух аргументов (которая всё равно константа и на асимптотику не повлияет).
	\end{Rem}

	\begin{lemma}
		Более того, если у нас имеются переменные $a_1, \dots, a_n$, то можно посчитать значения ассоциативной функции $f$ на префиксах:
		\[ f(a_1), f(a_1, a_2), f(a_1, a_2, a_3), \dots, f(a_1, \dots, a_n) \]
	\end{lemma}
	\begin{proof}
		Можно либо действовать так же и потом просто посмотреть на получившееся дерево как на дерево отрезков из алгоритмов (а запрос к дереву отрезков "--- это $\O(\log n)$ запросов к его вершинам),
		либо применить разделяй-и-властвуй.

		Для этого рекурсивно считаем префиксные значения для первой половины переменных, для второй, а потом ко всем значениям из второй половины дописываем в начало
		$f(a_1, \dots, a_{\sfrac n2})$.
	\end{proof}

	\begin{theorem}
		Сумму двух чисел длины $n$, записанных в двоичной системе счисления, можно посчитать схемой глубины $\O(\log n)$.
	\end{theorem}
	\begin{proof}
		Также есть \href{http://neerc.ifmo.ru/wiki/index.php?title=\%D0\%94\%D0\%B2\%D0\%BE\%D0\%B8\%D1\%87\%D0\%BD\%D1\%8B\%D0\%B9_\%D0\%BA\%D0\%B0\%D1\%81\%D0\%BA\%D0\%B0\%D0\%B4\%D0\%BD\%D1\%8B\%D0\%B9_\%D1\%81\%D1\%83\%D0\%BC\%D0\%BC\%D0\%B0\%D1\%82\%D0\%BE\%D1\%80}{на Викиконспектах}.

		Давайте сначала схемой глубины $\O(\log n)$ выясним, в каких разрядах будет при сложении возникать перенос.
		А потом отдельно выясним значение каждого разряда: это просто сумма двух разрядов исходных чисел плюс перенос (который мы уже знаем).

		Давайте научимся считать функцию $f$ от двух чисел одинаковой длины $k$, она будет выдавать два бита:
		\begin{enumerate}
			\item Верно ли, что при сложении чисел возникнет перенос из разряда $k$?
			\item Верно ли, что при сложении этих чисел и еще одной единицы возникнет перенос из разряда $k$?
		\end{enumerate}
		Эта функция ассоциативна в том смысле, что если мы знаем $f(a, b)$ и $f(c, d)$, то легко можем посчитать $f(\overline{ac}, \overline{bd})$:
		\begin{enumerate}
			\item
				Перенос при сложении $\overline{ac} + \overline{bd}$ может случиться только в одном из двух случаев:
				\begin{itemize}
					\item Перенос возникает уже при сложении $a+b$.
					\item Возникает перенос при сложении $c+d$, а также при сложении $a+b+1$
				\end{itemize}
			\item
				Аналогично для случая $\overline{ac}+\overline{bd}+1$, но там уже надо будет смотреть на сложение не $c+d$, а сложение $c+d+1$.
		\end{enumerate}
		Теперь мы предыдущим леммам мы можем посчитать эту функцию на всех суффиксах двух слов и, тем самым, узнать, из каких разрядов будут переносы.
	\end{proof}

	\begin{theorem}
		Произведение двух чисел длины $n$, записанных в двоичной системе счисления, можно посчитать схемой глубины $\O(\log n)$.
	\end{theorem}
	\begin{proof}
		Также есть \href{http://neerc.ifmo.ru/wiki/index.php?title=\%D0\%94\%D0\%B5\%D1\%80\%D0\%B5\%D0\%B2\%D0\%BE_\%D0\%A3\%D0\%BE\%D0\%BB\%D0\%BB\%D0\%B5\%D1\%81\%D0\%B0}{на Викиконспектах}.

		Сначала построим элемент $3 \to 2$ глубины $\O(1)$, который по трём числам длины $2n$ будет строить два числа длины $2n$ с такой же суммой (перенос из разряда $2n$ отбрасывается).
		Он строится просто: $a = x \oplus y \oplus z$, а $b$ "--- это маска возникших переносов при суммировании $x+y+z$ (т.е. просто $((x \& y) | (x \& z) | (y \& z)) << 1$).

		Теперь умножение.
		Сначала строим $n$ чисел размера $2n$ каждое, как при умножении в столбик, это можно схемой глубины $\O(1)$.
		Дальше нужно сложить эти $n$ чисел.
		Давайте разобъём их на тройки, в каждой тройке запустим элемент $3 \to 2$, получим в полтора раза меньше чисел.
		Будем так повторять, пока не получим два числа (а это произойдёт через $\O(\log n)$ спусков).
		То есть за глубину $\O(\log n)$ мы свели умножение к сумме двух чисел, а её мы уже умеем делать за ещё $\O(\log n)$.
	\end{proof}

\subsection{Умножение матриц и достижимость}
	\begin{lemma}
		Если есть две прямоугольные матрицы над полем $\mathrm{F}_2$ размеров $n \times m$ и $m \times k$, то их произведение (размера $n \times k$)
		можно посчитать схемой размера $\O(nmk)$ и глубины $\O(\log m)$.
	\end{lemma}
	\begin{proof}
		Давайте отдельно посчитаем каждый бит матрицы-ответа.
		Он является скалярным произведением строки и столбца исходных матриц.
		Давайте сначала схемой глубины $\O(1)$ посчитаем $m$ бит "--- произведения соответствующих элементов, а потом схемой глубины $\O(\log m)$ их сложим.
	\end{proof}
	\begin{Rem}
		Можно сделать ровно то же самое, если мы не работаем в поле $\mathrm{F}_2$, а если у нас операция сложения является операцией <<или>>.
	\end{Rem}

	\begin{lemma}
		Если имеется ориентированный граф $G$ на $n$ вершинах и $A$ "--- его матрица смежности, то $(A+E)^n$ является его матрицей достижимости
		(т.е. единица в строке $i$ и столбце $j$ стоит тогда и только тогда, когда вершина $j$ достижима из вершины $i$).
	\end{lemma}
	\begin{Rem}
		Под <<$+$>> в этой лемме и ниже подразумевается операция <<$\lor$>>.
	\end{Rem}
	\begin{proof}
		Докажем следующее утверждение индукцией по $k$: $(A+E)^k$ "--- это матрица существования путей (маршрутов) длины не более $k$.

		База при $k=0$ очевидна (просто единичная матрица).
		Переход $k \to (k+1)$.
		Обозначим $B\eqcolon (A+E)^k$.
		Заметим, что $B(A+E)=BA+B$, т.е. в матрице $(A+E)^{k+1}$ будут, как минимум, все пути длины не более $k$.
		А что такое $BA$?
		Если посмотреть на определение умножения матриц, то получается, что в ячейке $BA$ единица стоит тогда и только тогда,
		когда был какой-то путь $i \to \alpha$ длины не более $k$ и путь $\alpha \to j$ длины не более 1, т.е.
		автоматически был путь $i \to j$ длины не более $k+1$.
		Что и требовалось.

		А никакой путь в графе не может быть длинее $n$, значит, $(A+E)^n$ уже является матрицей достижимости).
	\end{proof}

	\begin{theorem}
		Задача проверки достижимости вершины $b$ из вершины $a$ в орграфе $G$ на $n$ вершинах решается схемой глубины $\O(\log^2 n)$.
	\end{theorem}
	\begin{proof}
		Сначала надо схемой глубины $\O(1)$ построить матрицу смежности $A$ графа $G$, потом прибавить к ней $E$ за ещё одну операцию.
		Затем надо быстрым возведением в степень возвести $A+E$ в степень хотя бы $n$, для этого потребуется $\O(\log n)$ умножений матриц,
		каждое можно сделать за глубину $\O(\log n)$.
		Получаем итоговую глубину $\O(\log^2 n)$.
	\end{proof}
