\setcounter{section}{6}
\section{Билет 7}
	\begin{Def}
		Задача $A$ \textit{сводится по Тьюрингу} к задаче $B$, если есть машина $M^B$ решающая задачу $A$.
	\end{Def}
	\begin{Rem}
		Про время работы вообще ничего не говорим.
		Так можно сводить не только языки (т.е. задачи распознавания), но и задачи поиска.
	\end{Rem}
	\begin{Rem}
		Это сведение для языков "--- более общий случай сведения по Карпу (там мы разрешаем вызвать оракула только один раз, только в конце, и ничего не можем делать с его ответом).
	\end{Rem}

	\begin{assertion}
		Классы $\P$ и $\widetilde{\P}$ замкнуты относительно сведения по Тьюрингу, т.е. $\P^{\P}=\P$ и $\widetilde\P^{\widetilde\P}=\widetilde\P$
	\end{assertion}
	\begin{proof}
		Мы можем заменить все магические вызовы оракула на явный запуск оракула.
		Пусть машина работала $t$ шагов, где $t \le p(n)$ ($n$ "--- длина входа машины).
		Тогда, очевидно, она не может скормить оракулу строчку длиннее $t$.
		Так как оракул работает за $q(k)$ (где $k$ "--- длина \textit{входа оракула}, а $p$ "--- полином),
		то на каждом входе оракул будет работать не более $q(p(n))$ "--- тоже какой-то полином.

		Если мы вместо обращения к оракулу будем явно вычислять функцию, то получим замедленее не более, чем в $q(p(n))$ раз,
		т.е. всё равно полином.
	\end{proof}
	\begin{Rem}
		Обратите внимание, что в общем случае оракул может получать гораздо более длинный вход, чем сама машина получила на вход.
		Длина входа оракула ограничена только временем работы.
	\end{Rem}
	\begin{Rem}
		А вот про классы $\NP$ и $\widetilde{\NP}$ мы такой замкнутости не знаем.
	\end{Rem}

	\begin{theorem}
		\begin{itemize}
			\item Для любой задачи поиска $R$ из $\NP$:
			\item Существует Л\'евинский оптимальный алгоритм поиска $A$ (детерминированный) со следующим свойством:
			\item Для любого другого алгоритм $B$, решающего задачу $R$:
			\item Существует такой полином $p$, что:
			\item На любом входе $x$, где есть ответ:
			\item Время работы $A$ не более чем $p(t)$, где $t$ "--- время работы $B$.
		\end{itemize}
	\end{theorem}
	\begin{proof}
		$A$ будет перебирать вообще все детерминированные машины: не только полиномиальные, не только останавливающиеся, а вообще все.
		Это можно сделать, перебирая все конечные строки (например, для описаний, не являющимися корректными машинами, можно считать, что они имеют право вести себя как угодно).
		Назовём эти машины $M_0, \dots, M_n, \dots$.

		Давайте будем на шаге с номером $i=2^l(1+2k)$ моделировать $k$-й шаг машины $M_l$, то есть на нечётных шагах моделируем шаги $M_1$,
		на деляющихся только на 2 (но не на 4) "--- шаги $M_2$, на делящихся на 4 "--- $M_3$ и так далее.
		Если какая-нибудь машина завершается, то мы смотрим на её ответ и проверяем, не является ли он ответом на задачу.
		Если является, то выдаём, иначе продолжаем эмуляцию.

		Заметим, что если есть какой-то алгоритм поиска (а какой-то точно есть "--- можно просто перебрать все решения), то мы на входе $x$ точно когда-то завершимся.
		Давайте предположим, что есть алгоритм $B$, которому соответствует машина $M_a$ и который на входе $x$ завершится за время $t$.
		Тогда мы обнаружим этот факт через $2^a(1+2t)$ шагов алгоритма (если не найдём ответ раньше), обозначим это число за $n$.
		Тогда заметим, что на каждом из предыдущих шагов мы тратили константное время не более $\O(n)$ времени на эмуляцию очередного шага очередной МТ
		и не более $\O(p(n))$ времени на проверку возможно выданного ответа (так как ответ не может быть больше времени работы МТ, а его проверка делается за полином).
		Значит, всего у нас время работы до завершения оптимального алгоритма на входе $x$ не более $n \cdot \O(n) \cdot \O(p(n))$, что есть полином от $n$, что есть
		полином от $t$, что и требовалось показать.
	\end{proof}
	\begin{Rem}
		На входах без ответа наш алгоритм зацикливается.
	\end{Rem}
	\begin{Rem}
		Это полезное знание, если у есть конечное число оптимальных алгоритмов $A_1, \dots, A_k$, причём каждый из алгоритмов быстро работает на каком-то своём множестве входов (но тормозит на других).
		Тогда оптимальный алгоритм будет работать на каждом выходе не более, чем в полином раз медленнее, чем \textit{каждый} из этих алгоритмов.
		А так как их конечно, то мы даже можем сказать, что оптимальный алгоритм на каждом входе не сильно хуже, чем оптимальный для этого входа.
	\end{Rem}
