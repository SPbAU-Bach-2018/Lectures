\setcounter{section}{21}
\section{Билет 22}
\subsection{Введение}
	Будем доказывать двумя включениями.
	\begin{lemma}
		\[ \IP \subseteq \PSPACE \]
	\end{lemma}
	\begin{proof}
		Это простое включение: $\IP \subseteq \PSPACE$.
		Для начала добавим в протокол полиномиальный будильник, чтобы ограничить объём данных.
		Пусть дали вход $x$, хотим проверить $x \in L$.
		Надо нарисовать дерево возможных ответов Prover'а и Verifier'а.
		В каждой вершине считаем вероятность принятия строки Verifier'ом начиная из данного состояния (храним как несократимую дробь, длина числителя и знаменателя ограничены полиномом).
		Если в вершине ход делает Verifier "--- надо взять взвешенное среднее по всем детям (Verifier делает случайный переход).
		Если в вершине ход делает Prover "--- надо взять максимум по всем детям.
		Таким dfs'ом проходимся по дереву и в конце-концов посчитаем вероятность принятия $x$ при оптимальной стратегии Prover.
		Дальше надо лишь сравнить её с $\sfrac13$ и $\sfrac 23$.
	\end{proof}

	Сложное включение: $\PSPACE \subseteq \IP$.
	Нам будет досточно построить протокол для $\PSPACE$-полной задачи $\QBF$.
	Тогда для построения интерактивного протокола для другой задачи $L \in \PSPACE$ перед началом протокола Prover и Verifier независимо за полиномиальное время поймут, про
	какую $\QBF$-задачу они говорят, а потом уже будут работать с этой $\QBF$-задачей.

\subsection{Арифметизация}
	Для начала перейдём от булевой формулы к арифметической формуле с арифметическими переменными, обычными арифметическими операциями и трёмя дополнительными унарными операциями.
	Отображение булевских операций такое:
	\begin{itemize}
		\item Формула от переменных $\to$ многочлен от тех же переменных
		\item $\t{false} \to 0$
		\item $\t{true} \to 1$
		\item $a \land b \to a \cdot b$
		\item $\lnot a \to 1 - a$
		\item $a \lor b = \lnot (\lnot a \land \lnot b) = 1 - (1-a)(1-b)$, эту операцию обозначим $a \odot b$
	\end{itemize}
	Также добавим ещё три операции над многочленами, они будут вести себя так:
	\begin{itemize}
		\item <<Квантор всеобщности>> по переменной:
			\[ A_x\,P(x_1, \dots, x_k, x) \coloneq P(x_1, \dots, x_k, 0) \cdot P(x_1, \dots, x_k, 1) \]
			Степень многочлена от этой операции увеличивается не более, чем в два раза.
		\item <<Квантор существования>> по переменной:
			\[ E_x\,P(x_1, \dots, x_k, x) \coloneq P(x_1, \dots, x_k, 0) \cdot P(x_1, \dots, x_k, 1) \]
			Степень многочлена от этой операции увеличивается не более, чем в два раза.
		\item Линеаризация:
			\[ L_x\,P(x_1, \dots, x_k, x) \coloneq P \bmod (x^2 - x) \]
			Эта операция не меняет значение многочлена в точках, где все $x_i \in \{0, 1\}$, так как $x^k \bmod (x^2-x) \equiv x^{1\text{~или~}2}$,
			что равно $x$ при $x \in \{0, 1\}$.
			То есть в целом эту операцию можно пихать в любых местах, она нужна только для понижения степени многочлена по одной переменной до единицы.
			Если применить несколько таких операций по всем переменным, то степень многочлена упадёт до количества переменных.
	\end{itemize}
	Нам надо было проверить, что такая булева формула истинна (с точностью до первого квантора):
	\[ \forall x_1 \colon \exists x_2 \colon \dots Q_k x_k \colon \phi(x_1, \dots, x_k) \]
	Это в терминах наших новых операций равносильно тому, что следующее замкнутое арифметическое выражение равно единице:
	\[
		A_{x_1}\,L_{x_1} \,
		E_{x_2}\,L_{x_1} \, L_{x_2} \,
		A_{x_3}\,L_{x_1} \, L_{x_2} \, L_{x_3} \,
		\dots \,
		p(x_1, x_2, \dots, x_n)
	\]
	\begin{Rem}
		Это выражение действительно замкнутое, имеет размер порядка $n^2+|p|$, несмотря на то, что внутри есть многочлен от $n$ переменных.
		Все эти переменные убиваются операциями над многочленом.
	\end{Rem}
	Арифметизацию перед началом протокола Verifier выполнит самостоятельно.

\subsection{Интерактивный протокол}
	Дальше Prover будет доказывать Verifier'у, что имеющаяся у него формула тождественно равна единице.
	Мы будем рекурсивно строить чуть более общий протокол, который позволяет проверять равенства такого вида для суффиксов формулы:
	\[
		\left( q_{x_i} \, q_1 \, q_2 \, \dots \, q_{\alpha}\, p(x_1, \dots, x_{i-1}, x_{i}, \dots, x_n) \right)|_{\substack{x_1=r_1\\ \vdots\\ x_{i-1}=r_{i-1}}} = c
	\]
	Здесь $q_{x_i}$ "--- некоторый оператор по переменной $x_i$, $q_i$ "--- какие-то последующие операции, $r_i$ "--- подстановленные значения для переменных $x_1, \dots, x_{i-1}$,
	которые уже не будут убиваться встречающимися в формуле операторами, $c$ "--- значение, которому должно быть равно выражение.
	\begin{Rem}
		В случае $q=L$ также будет иметься фиксированное значение $r_i$ для переменной $x_i$ (т.е. она тоже подставляется в выражение).
	\end{Rem}

	Если операций не осталось, то мы уже знаем значения всех переменных и Verifier легко сам вычислит значение.
	А чтобы построить протокол для исходной задачи, надо просто начать с первой операции и $i=1$ (т.е. никакие значения переменных ещё не известны).

	По протоколу Prover должен первым шагом разложить следующий многочлен $x_i$ и прислать его коэффициенты:
	\[
		s(x_i) \coloneq q_1\, q_2\,\dots\,q_{\alpha}\, p(r_1, \dots, r_{i-1}, x_i, x_{i+1}, \dots, x_n)
	\]
	Это просто вся формула после $q_{x_i}$ с подставленными $r_1, \dots, r_{i-1}$.
	Дальше несколько случаев:
	\begin{description}
		\item[$q=A$:]
			Тогда для начала надо проверить, что $s(0) \cdot s(1) = c$ (т.е. что оператор $A$ правильно посчитан в предположении корректности $s$).
			Если сошлось, то выбираем случайное $x_i$ \textit{из некоторого поля} (т.е. не обязательно 0 или 1), считаем $s(r_i)$ самостоятельно
			и дальше рекурсивно просим Prover доказать, что многочлен $s$ действительно такой, как он нам сказал.
		\item[$q=E$:]
			Аналогично, но проверять надо $s(0) \odot s(1) = c$
		\item[$q=L$:]
			В этом случае у нас уже есть значение $r_i$ для подстановки в переменную $x_i$, надо проверить $s(r_i)=c$.
			А потом надо опять проверить, что $s$ нам дали корректный: выбираем новый случайный $r_i'$ \textit{из поля} и просим Prover
			доказать, что многочлен $s$ корректен, доказав, что он в случайной точке равен тому, что мы сами посчитали.
	\end{description}
	На одном шаге мы облажаемся (т.е. попадём в корень $s(r_i)-s_{\text{реальный}}(r_i)$) с вероятностью не более $\frac{d}{|F|}$, а если мы нигде не облажаемся, то
	в конце-концов поймаем Prover'а за руку.
	Всего шагов у нас не более $d^2$, т.е. надо брать поле размера порядка $d^4$, чтобы получить ошибку $d$.
	А на любом шаге $d$ не более $2n$ из-за операторов линеаризации, что очень хорошо.
