\setcounter{section}{3}
\section{Билет 4}
\subsection{$\mathsf{Circuit-SAT}$}
	\begin{Def}
		Массовая задача $\mathsf{Circuit-SAT}$ "--- это множество пар $(C, \vec x)$ таких, что:
		\begin{enumerate}
			\item $C$ "--- описание ацикличной булевой схемы с выделенными $k$ входами и одним выделенным выходом.
				Возможные гейты "--- какой-нибудь конечный базис (например, <<и>>, <<или>>, <<не>>), каждый элемент
				базиса имеет фиксированное число входов и один выход (который, впрочем, можно подключать куда угодно в схеме сколько угодно раз).
				Неважно, как базис брать за определение, всё будет эквивалетно.
			\item
				$\vec x$ "--- битовый вектор длины $k$ такой, что если подать соответствующие биты на входы схемы и вычислить значения гейтов,
				то на выходном гейте будет единица.
		\end{enumerate}
	\end{Def}
	\begin{Rem}
		Например, элемент <<и всех входов>> для произвольного числа входов в схему брать мы не можем.
	\end{Rem}

	\begin{lemma}
		$\mathsf{Circuit-SAT} \in \NP$
	\end{lemma}
	\begin{proof}
		Построим НМТ: она вначале сделает $k$ недетерминированных решений (выберет значения входных гейтов и запишет их на ленту), а дальше
		за линейное от размера схемы время вычислит значение выходного гейта (скажем, DFS'ом по гейтам, начиная с конечного).
	\end{proof}

	\begin{theorem}
		$\mathsf{Circuit-SAT}$ "--- $\NP$-полная
	\end{theorem}
	\begin{proof}
		Нам осталось показать, что эта задача $\NP$-трудная.

		Возьмём произвольную задачу $L \in \NP$, для неё, по определению, есть НМТ $M$, которая за время не большее $p(|x|)$ говорит <<да>>,
		если слово действительно лежит в языке $L$.

		Сведём $L$ к $\mathsf{Circuit-SAT}$ (по Карпу).
		Пусть дали слово $x$ длины $n$, вычислим $t \coloneq p(|x|)$.
		Построим схему с $t$ входами размера $\O(t^2)$, эмулирующую работу $M$ в течение $t$ шагов.
		Входами схемы будет описание того, какой переход на каком шаге выбирает машина $M$ "--- всего $t \cdot |Q|$ бит (см. ниже).
		\begin{enumerate}
			\item
				Так как $M$ работает не более $t$ шагов, то она использует не более $t$ памяти (возможно, надо домножить на число лент, это ок).
			\item
				Значит, конфигурацию $M$ (память лент, позиции головок и состояние) можно закодировать в виде битовой строчки константной длины.
				Будет удобно кодировать позицию лент не номером, используя $\log t$ битов, а последовательностью из $t$ бит, из которых ровно один равен единице "--- тот, где стоит головка.
				Аналогично будет удобно кодировать текущее состояние "--- не $\log |Q|$ битов, а $|Q|$ битов.
			\item
				Дальше можно построить схему, которая по двумя конфигурациям и текущему переходу выдаёт единицу тогда и только тогда, когда из одной можно перейти в другую за один шаг таким переходом:
				\begin{enumerate}
					\item
						Сначала надо прочитать бит под каждой головкой и вывести его в отдельный гейт для головки "--- это мы сначала берём логическое <<и>> ленты с маской положения головки,
						остаётся один бит, а потом берём логическое <<или>> этих битов.
					\item
						Потом надо проверить, что переход действительно ожидает эти биты под головками и это состояние.
					\item
						Потом надо проверить, что конечное состояние действительно такое, как ожидает переход.
					\item
						Потом надо проверить, что биты под головками поменялись правильным образом, головки правильно подвинулись.
					\item
						Потом надо проверить, что биты не под головками остались неизменны.
				\end{enumerate}
			\item
				Дальше делаем $t$ слоёв схемы, каждый слой "--- это гейты, кодирующие конфигурацию $M$.
				Первый слой фиксирован (исходная конфигурация, в неё зашит вход $x$), между соседними слоями стоит проверка корректности перехода,
				конечный слой должен принимать слово.
		\end{enumerate}
		Теперь получаем, что наша схема выдаёт единицу тогда и только тогда, когда подсказка, поданная схеме на вход, заставляет машину $M$ пройти через $t$ шагов и
		завершиться в принимающем состоянии, что и требовалось.
	\end{proof}

\subsection{$\mathsf{3-SAT}$}
	\begin{Def}
		Массовая задача $\mathsf{3-SAT}$ "--- это множество таких пар $(\phi, \vec x)$, что:
		\begin{enumerate}
			\item $\phi$ "--- это булева формула в 3-КНФ от $n$ переменных.
				Это как КНФ, но в каждом клозе формулы присутствует не более трёх термов.
			\item $\vec x$ "--- вектор из $n$ бит, причём $\phi(\vec x)=1$.
		\end{enumerate}
	\end{Def}

	\begin{lemma}
		$\mathsf{3-SAT} \in \NP$
	\end{lemma}
	\begin{proof}
		Построим НМТ: она в начале делает $n$ недетерминированных переходов, выбирая значения переменных $x$ (и, например, записывая их на ленту),
		а потом посчитает значение формулы по значениям переменных, проверит, что получилась единица
	\end{proof}

	\begin{lemma}
		Для произвольной функции $f(x, y)$ от двух бит условие $z=f(x, y)$ можно записать в 3-КНФ.
	\end{lemma}
	\begin{proof}
		Заметим, что выражение $(x \land y) \ra z$ легко переписывается в 3-КНФ:
		\begin{gather*}
			(x \land y) \ra z \\
			\Updownarrow \\
			(\lnot x \lor \lnot y \lor z)
		\end{gather*}
		Доказать можно, расписав таблицу истинности.

		Теперь давайте переберём четыре значения $(x, y)$, посчитаем $f(x, y)$ и запишем конъюнкцию четырёх 3-КНФ.
		Например, если $f(0, 1)=0$, то надо дописать 3-КНФ для выражения $(\lnot x \land y) \ra \lnot z$.
	\end{proof}

	\begin{theorem}
		$\mathsf{3-SAT}$ "--- $\NP$-полная задача.
	\end{theorem}
	\begin{proof}
		Сведём $\mathsf{Circuit-SAT}$ и $\mathsf{3-SAT}$.

		Пусть нам дали схему с $n$ входами и $m$ гейтами (помимо входов).
		У нашей формулы будет $n+m$ переменных: $x_1, \dots, x_n, y_1, \dots, y_m$.
		Давайте запишем условия на $y_i$ в 3-КНФ по предыдущей лемме: мы знаем, как вычисляется каждый $y_i$ через остальные переменные.
		Также допишем в конец получившейся 3-КНФ значение $y_i$, соответствующего выходному гейту.

		Т.о. наша формула будет истинна тогда и только тогда, когда все $y_i$ являются корректно посчитанными значениями гейтов и на выходном гейте единица.
		Значит, она выполнима тогда и только тогда, когда выполнима исходная схема.
	\end{proof}
	\begin{Rem}
		Тут мы за полиномиальное время сводили только задачу выполнимости "--- у нас даже число переменных изменилось.
		Если бы хотели вычислить схему на произвольном входе формулой, то формула бы наверняка экспоненциально разраслась.
		Тут мы этого избежали за счёт увеличения числа переменных.
	\end{Rem}
