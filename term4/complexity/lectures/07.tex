\section{Класс функций $\#P$}
Сегодня мы поговорим об интерактиынх протоколах. Прежде чем говорить, 
об интерактивных протоколах я хочу вас научить еще одному классу. Он, может 
быть, вам и не понадбится, но в общем полезно про него знать.  

Это класс не языков, это класс функций, который зовется $\#P$.

Это, в некотором смысле обобщения многих классов, что мы изучали. Почти классы, 
которые мы изучали формулируются в виде недетерменированных машин тьюринга: 
\begin{enumerate}
\item $NP$ "--- есть хотя бы одна единица. 
\item $co-NP$ "--- наоборот.
\item $RP$ "--- единиц много. 
\item $BPP$ "--- принимающий 2/3 или отвергающий 2/3
\end{enumerate}

Все эти классы опеределяются в терминах количества
принимающих состояний в Машине Тьюринга. 

\begin{Def}
$\#P = \{f | \exists NMT M \colon \forall x f(x) \#\{accepting path M(x)\}\}$\\
\end{Def}

Если есть оракул, который говорит, сколько в Машине Тьюринга принимающих состояний,то
мы научились решать $NP, RP, BPP, PP\cdots$.

В частности, мы научились решать любой класс полиномиальной иерархии, 
но это сложная теорема, ее мы не будем доказывать. 

\begin{exmp}
PERM - вычисление пермонента матрицы является $\#P$ полная задача.

То что эта задача $\#P$ полная мы доказывать не будем, потому 
что это скучно. И это даже не достойна упражнения.

Сведения между функциями это сведения по тьюрингу, то
есть с помощью оракулов.

\begin{Def}
Пермонент это как определитель, но не знако переменный.
$Perm A = \sum_{\sigma \in S_n}a_{1\sigma(1)} \cdots a_{n\sigma(n)}$. 
\end{Def}
\end{exmp}
 
\begin{proof}
Для этой задачи построим IP протокол. 

Сейчас у нас в протоколе случайные биты скрытые.
Прувер всесильный, а варифаер полиномиальный и
в конце концов он должен сказать да или нет. Оба знают
вход. Конечно, мы сказали, что хотим вычислить функцию,
а не да нет. Но давай-те у нас просто первым входом
прувер скажет ответ, а дальше просто быдет это доказывать.  
А мы скажем, правильно он сказал или нет. 

То есть с помощью протокола 
хотим доказать, что $perm A = c$, где с - константа. 

Все это будет происходить в некотором конечном поле, но не
велечины два, а побольше. 

Теперь как мы это будем делать. Самостоятельно вычислить пермонент мы не 
можем. Нет у нас времени. А вот для определителя у нас есть, 
например, метод Гауса. 

Мы сведем сначала задачу вычисления пермонента к нескольким задачам поменьше. 
Мы можем разложить пермонент по какой-нибудь строчке. 

Раскладываем матрицу по строке. Точнее просим это сделать прувера. 

Просим прувера отправить пермоненты соответствующих подматриц. 
$permA = a_{11} perm A_1 + a_{12}perm A_2 + \cdots + a_{1n}perm A_n = с$
$perm A_{i} = c_i$\\

Мы сразу проверем, что сумма сошлась. 

Теперь можно проверять n тождест на единичку меньше.

Если мы дальше будем продолжать таким же образом, количество
задач, которые нужно проверять, станет экспоненциально много. 

Давай-те теперь научимся из двух задачек делать одну такого же размера. 

Вот пусть у нас есть две задачи:
$perm B = b$\\
$perm D = d$\\

Составим символьную матрицу $perm(Bx + D(1 - x)) = p(x)$ \\
Результат будет многочлен. 
Мы можем подставлять разные x получать пермоненты разных матриц. 

Проверим, что результат совпадает с тем, в чем он хочет нас убедить. 
То есть подставим 0 и подставим 1. 

Нужно проверить, что то, что прислал прувер является пермонентом. Для этого выбирем 
случайное значения для x. Получиться некоторая конкретная матрица и нужно проверить, что она хорошая. 
$R = Br + D(1 - r)$\\
$p(r) = \rho$\\
Проверим, что $perm R = \rho$\\
                                                                  
Теперь весь алгоритм вместе. 

Нам дали матрицу и дали скаляр и просят это дело проверить. Мы раскладываем 
по первой строчке и получаем кучу задачек. $n$ штук. Потом потихоньку начинаем
собирать их вместе. Взяли первые две задачи попросили у прувера многочлен.
ткнули в случайную точку. Получили одну.

Потом повторили.

И того у нас будет n таких этапов и на каждом этапе нам нужно собрать
меньше n матриц вместе.

Какие шансы у прувера нас обмануть? Ну это
конечно зависит от размера поля. Мы тут пользуемся тем, что
у ненулегого многочлена достаточно мало корней. Поэтому поле будет
достаточно большого размера. В частности, если нам нужно вычислять в поле
поменьше, то нужно взять расширения. С самого начала будем считать, что
вычисление ведется над полем размера $\ge n^4$\\

Первый шаг мы разбиваем матрицу на много и проверяем, что 
сумма такая, тут он вообще не может нас обмануть. Если исходное 
было не верно, то хотя бы одно из них тоже будет не верно. 

Он может нам прислать коэффиценты неправильного многочлена. Может 
оказаться, что многочлен не соответствует символьной матрице. Большая
беда, если многочлены разные, но мы попали в совпадающую точку.

Шансы на это $\frac{deg(p(x) - perm(Bx - D(1 - x)))}{n^4}$\\

Если тот многочлен прислал, то совсем все хорошо. То есть, все, что может
плохого случиться, это пришлют не тот многочлен. Всего таких событий не
больше $n^2$  за время всего протокола.

Значит вероятность ошибится не больше, чем $\frac{1}{n}$. 
        
\end{proof}

\section{$PSPACE = IP$}
\begin{theorem}
$PSPACE \subset IP$\\
$Adi Shammir$ 
\end{theorem}
\begin{proof}
Задача о булевых формулах с кванторами является PSPACE полной. 
То есть, если мы предъявим интерактивный протокол, для задачи 
QBF, то мы докажем $PSPACE \subset IP$.

Сначала докажем простое обратное включение.\\ 
$IP \subset PSPACE$\\

По большому счету у нас есть два игрока, у 
одного ход существования, у другого ход вероятностный. 
И нам нужно самостоятельно промоделировать игру этих игроков. 
Переборным образом. И понять, верно ли что вероятность принять
равна 1.

У нас есть полиномиальная память, которую мы будем использовать. 

Перебираем все ходы verifier. Дальше перебираем все возможные случайные 
числа, потом все шаги prover и так далее.

В конце моделируем работу verifier. Дальше, рекурсивно 
раскручиваемся и считаем вероятность выграть. 

$PSPACE \subset IP$\\

Закадируем булеву формулу в виде арифметического выражения.
\begin{enumerate}
\item $False \to 0$\\
\item $True \to 1$\\
\item $a \wedge b \to a\cdot b$\\
\item $\not a \to 1 - a$\\
\item $a \vee b \to 1 - (1 - a)(1 - b) = a \odot b $\\
\end{enumerate}
То есть мы перешли из булевых формул в арифметические. 

Если формула была истеной, то мы получим арифметически 1, 
если формула была ложной, то получим арифметичекси 0. 

Даже это верно в любом кольце. 

Теперь нам нужно что-то
сделать с квантарами. Это мы делаем с помощью операция над формулами.

Мы не будем это делать явно, иначе у нас будет слишком много скобочек, 
но всякий раз, когда мы видем $\forall x$ мы заменяем его 
на $A_xP$, $\exists x$ заменяем на $E_xP$ и имеем в веду, что
\begin{enumerate}
\item 
$(A_xP)(...) = P(0, \cdots)\cdot P(1, \cdot)$\\
\item 
$(E_xP)(...) = P(0, \cdots) \cdot P(1, \cdot)$\\
\end{enumerate}
Новые арифметические операторы. С понятным смыслом, но это
не значит, что мы это прям сразу будем раскрывать.
 
Вводим оператор линеаризации,то есть убиваем степени.   
$(L_xP)(x, ...) = P mod (x^2 - x)$. Это значает что у 
x все степени превращаются в степень один.

Со значаниями многочлена ничего не происходит. Если
мы срезали степень у нолика и единички, то значание
многочлена вообще никак не поменялось.

То есть такой оператор мы можем применить, когда хотим сколько угодно раз. 

Перепишем формулу следующим образом, напихае везде, где только 
можно операторов линеаризации по всему. 
$q_{x_1}^{(1)}L_{x_1}q_{x_2}^{(2)}L_{x_1}L_{x_2} \cdots P(x_1,\cdots, x_n) = 1$.

Таким способом записана некоторая арифметическая формула. Ее
значание в булефых точках совпадает со значаниями исходной булевой
формулы. 

Таким образом, нам достаточно, что бы прувер доказал нам, 
что эта формула кодирует константу 1.

Теперь мы будем подставлять не всегда 0 и 1. Мы
требуем от прувера многочлен, который
соответствует формуле без первого квантора, потом
к этому многочлену применится оператор A и все.
$A_{x_1}q'\cdots q'''P(x_1, \cdots, x_n)$\\
$R(x_1, \cdots, x_n) = q'\cdots q'''P(x_1, x_2, \cdots, x_n)$ \\ 
То есть получили многочлен от $x_1$, назовем его $s(x_1)$. 
Степень этого многочлена не 
велика, поэтому результат этого многочлена мы можем сами вычислить. 
\begin{enumerate}
\item $q = A$\\ 
        можем проверить, что $s(0)s(1) = c$ \\
        Далее выбираем случайные точки $r_1$ и проверяем рекурсивно, 
        что $R(r_1, \cdots, x_n) = s(r_1)$\\

        Свели задачу к задаче с меньшем количеством кванторов.
        Когда кванторы закончатся у нас останется
        только сам многочлен и значения для всех переменых.  
\item $q = E$\\
        Аналогично с проверкой $s(0) \odot s(1) = c$. 
\item $q = L$\\
       Тут есть особенность в том, что кванторы
       удаляют перменные, а этот оператор перменные не
       удаляют и значение для этой переменной уже есть.

       Просим коэффиценты многочлена R после подстановки всех
       переменных, кроме $x_i$. Он присылает нам какой-то 
       многочлен от $x_i$. Нужно проверить, что
       это правильный многочлен и нужно проверить что
       мнгочлен правильно линеаризуется $s(0) + (s(1) - s(0))_{r_i} = c$. 

       Ответ прувера соответствует тому, что утверждал прувер раньше.

      Теперь нужно проверить, что многочлен правильный. Для этого нужно
      ткнуть в новую случайную точку и нужно проверить, что новый многочлен
      правильный.  
                    
\end{enumerate}
Степень многочлена будет маленькая, 
поэтому попасть в корень маленькая вероятность. Шагов 
у нас столько, сколько кванторов, 
значит вероятность ошибиться на одном шаге $\le \frac{d}{\text{размер поля}}$\\

Значит если размер поля больше $d^4$, то размер поля $\le \frac{1}{d}$\\


Самая большая степень может быть, когда мы только в первый раз линеаризовали, 
она может быть досаточно боьшой, вплоть до размера формулы. Но больше она уже 
точно никогда не будет, как раз благодаря операции 
линеаризации. 

\end{proof}

