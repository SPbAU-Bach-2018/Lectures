\setauthor{Черникова Ольга}

\setcounter{section}{4}

\section{классы P и NP} 
\subsection{Задачи поиска и распознования}
\begin{Def}
	\textit{Алфавит} "--- по умолчанию будем использовать $\{0,1\}$.\\ 
	Обозначения алфавита "--- $\Sigma$
\end{Def}

\begin{Def}
	\textit{Слово} "--- элемент $\{0,1\}^*$, длина слова $x$ обозначается $|x|$.\\
	Множество слов длины $n$ обозначается $\{0, 1\}^n$\\
\end{Def}

\begin{Def}
	\textit{Язык} "--- некоторое множество слов (возможно, пустое или бесконечное).
\end{Def}

\begin{Rem}
	Мы считаем, что битовыми строками можно кодировать вообще любые объекты, которые можно описать.
	Кодировать будем, разумеется, наиболее разумно (если не сказано иное), чтобы размер строк был как можно меньше.
	Где важен тип кодирования "--- будем явно указывать.
\end{Rem}

\begin{exmp}
	Натуральные числа можно естесственно закодировать битовой строкой "--- представление числа в двоичной системе счисления.
\end{exmp}

\begin{exmp}
	Пары битовых строк: $(a, b)$ можно закодировать какой-то битовой строчкой.
	Тогда за $|(a, b)|$ естественным образом будет обозначаться длина этой строчки.
	В принципе, ожидаемо, что $|(a, b)| = \theta(|a| + |b|)$, по-хорошему надо выбрать один способ кодирования и для него доказать, но мы не стали.
\end{exmp}

\begin{Def}
	\textit{Индивидуальная задача} "--- это пара $(a, b) \in \{0, 1\}^* \times \{0, 1\}^*$, где $a, b$ "--- слова.
	$a$ называется условием или входом, $b$ называется решением для данного входа.
\end{Def}

\begin{Def}
	\textit{Массовая задача $R$} "--- некоторое множество $R$ индивидуальных задач (возможно, пустое или бесконечное):
	\[ R \subseteq 2^{\{0,1\}^*\times\{0,1\}^*}\] 
	Также можно рассматривать как бинарное отношение на строках: $aRb \iff (a, b) \in R$
	(читать как <<$b$ является решением задачи $R$ с условием $a$>>)
	Мы будем писать и так, и так.
\end{Def}

\begin{Rem}
	Наиболее интересные массовые задачи "--- бесконечные, с возможностью проверить корректность решения. 
\end{Rem}

\begin{exmp}
	Пологаем $\N \subset \{0, 1\}^*$\\
	$FRAC = \{(n, d) | n \vdots d, 1 < d < n\}$\\
\end{exmp}

\begin{Def}
	Алгоритм решает задачу поиска для массовой задачи $R$, если для условия $x$ он находит решение $w$, удовлетворяющее $(x, w) \in R$
\end{Def}

\begin{Def}
	Алгоритм решает задачу распознования(языки), задачу типа да/нет. 
	То есть алгоритм, который по $x$ умеет понимать, существует ли $w$, такое, что $(x, w) \in R$ 
\end{Def}

\begin{Rem}
	Массовая задача для $R$ задает язык:
	$$L(R) = \{x | \exists w (x, w) \in R\} $$
\end{Rem}

\begin{exmp}
	$L(FRAC) =$ множество всех составных слов. 
\end{exmp}


\subsection{Машина Тьюринга}
\subsubsection{Общее определение}
Машина Тьюринга (МТ) "--- вычислительная модель.
Есть много модификаций, но у каждой МТ есть следующее:
\begin{itemize}
	\item
		Фиксированный конечный алфавит $\Sigma$, в котором имеется как минимум два специальных символа: пробел (\textvisiblespace) и
		специальный символ начала ленты ($\triangleright$).
	\item
		Фиксированное конечное число \textit{лент}, бесконечных в одну сторону.
		Лента "--- это бесконечно много ячеек, занумерованных натуральными числами.
	\item Читающие/пишещие голвки, по одной для каждой ленты, каждая в один момент видет одну позицию 
	\item Конечное множество \textit{состояний} $q_i$. Выделяется начальное состояние $q_s$.
		Так же будем выделять терминальные состояния $q_y$ и $q_n$.
	\item Конечное множество \textit{переходов}.
		Каждый переход "--- это функция:
		\[(q, c_1, c_2, \dots, c_l) \to (c_1', c_2', \dots, c_l', m_1, m_2, \dots, m_l r)\]
		при этом:
		\begin{itemize}
			\item $l$ "--- число лент
			\item $c_i, c_i' \in \Sigma$
			\item $q, r$ "--- состояния
			\item $m_i \in \{\la, \dot, \ra\}$ "--- \textit{сдвиг головки $i$}
		\end{itemize}
		Говорим, что это переход из $q$ в $r$ по символам на лентах $c_1, \dots, c_l$, который пишет на ленты $c_1', \dots, c_l'$
		и сдвигает головки в направлениях $m_i$.
\end{itemize}

\begin{center}
\psfig{file=lecture1pic.eps, width=8cm}
\end{center}

Чтобы МТ что-нибудь вычисляла, вводится понятие \textit{конфигурации} конкретной МТ $M$, оно состоит из:
\begin{itemize}
	\item Для каждой ленты хранится одно натуральное число, соответствующее какой-то ячейке "--- \textit{позиция головки на этой ленте}
	\item
		Для каждой ленты хранится отображение $f \colon \N \to \Sigma$, которое в конечном числе точек может возвращать что угодно, а в остальных возвращает \textvisiblespace.
		Также можно дополнительно потребовать $f(1)=\triangleright$, но это необязательно (соответствующие определения будут эквивалентны).
	\item
		Выделяется \textit{текущее состояние} МТ $q$.
\end{itemize}

Дальше вводится понятие \textit{корректного перехода из конфигурации} $A$ в какие-то другие конфигурации.
Чтобы сгенерировать список этих конфигураций, надо сделать следующее:
\begin{enumerate}
	\item Рассмотреть все переходы из текущего состояния конфигурации $A$.
	\item Оставить из них только те переходы, у которых символ $c_i$ совпадает с символом на позиции головки на ленте $i$
	\item
		Для каждого из оставшихся сказать, что мы можем перейти в конфигурацию, у которой текущее состояние изменено с $q$ на $r$,
		символы $c_i$ на лентах заменены на символы $c_i'$, соответственно, а позиции головок на каждой ленте независимо изменены в соответствии с $m_i$:
	\begin{itemize}
		\item При $\la$ головка сдвигается на единицу влево
		\item При $\cdot$ головка остаётся на месте
		\item При $\ra$ головка сдвигается на единицу вправо
	\end{itemize}
\end{enumerate}

\begin{Rem}
	Изначально машина находится в начальной конфигурации, $q = q_s$, все голочки находятся на начальных позициях.
\end{Rem}

\begin{Rem}
	Можно формально определить бинарное отношение <<быть корректным переходом>> между состояниями,
	аккуратно расписав алгоритм выше.
\end{Rem}

\begin{Rem}
	Никакая головка не должна уезжать за край ленты.
	Есть разные способы этого добиться.
\end{Rem}

\subsubsection{Модификации}
Все модификации МТ ниже эквивалентны друг другу, мы выбираем ту, в которой удобнее работать в данной задаче.
Для доказательства эквивалентности двух моделей, надо выбрать машину в одной модели и переделать.

Чтобы головка не уезжала налево за край ленты, можно считать по-разному:
\begin{itemize}
	\item Переход, при котором головка уезжает налево некорректен
	\item Если головка уезжает налево, вычисление прекращается.
\end{itemize}

\begin{Def}
	\textit{Детерминированная машина Тьюринга} (ДМТ) "--- если зафиксировать начальное состояние и множество символов под лентой, то переход либо есть и ровно один, либо его нет.
	Если перехода нет, то можно либо отвергать слово, либо переходить в какое-то спецсостояние (эквивалентно).
	Можно считать, что все переходы всегда должны быть (эквивалентно).
\end{Def}
	
\begin{Rem}
	Если у ДМТ зафиксировать конфигурацию, то следующая конфигурация (если есть) всегда определяется однозначно.
	Поэтому можно говорить о том, что ДМТ что-то однозначно вычисляет (или зацикливается).
\end{Rem}
	
\begin{Def}
	На ДМТ можно вычислять функции: на фиксированную (входную) ленту пишем вход, запускаем ДМТ, пока не завершиться, после этого ожидаем на фиксированной ленте (выходной) получить ответ.
 	То есть можем решать задачу поиска. 
\end{Def}
	
\begin{Def}
	На ДМТ также можно вычислять ответы <<да/нет>>: говорим, что ДМТ обязана завершать работу в ровно одном из двух состояний "--- $q_{yes}$ или $q_{no}$, и именно этим определяется результат работы.
	То есть решать задачу распознавания.
\end{Def}

\begin{Def}
	Говорим, что ДМТ $M$ распознает язык $A$, если принимает все $x \in A$, отвергает все $x \not \in A$, пишем, что $A = L(M)$.
\end{Def}

\subsubsection{Метрики}

\begin{Def}
	\textit{Время работы $M$} "--- количество шагов до остоновки машины.
\end{Def}

\begin{Def}
	\textit{Используемая $M$ память} "--- сумма следующей величины по всем лентам: максимальное правое положение головки на ленте.
\end{Def}

\begin{Rem}
	При сублинейных ограничениях на память первая лента(где вход) $read-only$ и положение головки на ней не считается. 
\end{Rem}

\begin{exmp}
	Если машина на двух лентах сначала отвела первую головку вправо на 10, потом вернула, потом сделала то же самое со второй головкой,
	то используемая память "--- $10+10=20$.
\end{exmp}


\subsection{Классы $P$ и $NP$}
\begin{Def}
	Массовая задача $R$ полиномиально ограничена, если существует полином $p$, ограничивающий длину	кратчайшего решения:
	$\forall x(\exists u \colon (x, u) \in R \Ra \exists w \colon (x, w) \in R \wedge |w| \le p(|x|))$
\end{Def}
\begin{Def}
	Массовая задача $R$ полиномиально проверяема, если существует полином $q$, ограничивающий время проверки решения:
	для любой пары $(x, w)$ можно проверить принадлежность $R$ за время $q(|(x, w)|)$.
\end{Def}
\begin{Def}
	$\tilde {NP}$ "--- класс задач поиска, задаваемых полиномиально ограниченными, полиномиально проверяемыми массовыми задачами. 
\end{Def}
\begin{Def}
	$\tilde P$"--- класс задач поиска из $\tilde {NP}$, разрешимых за полиномиальное время, то есть задаваемых
	отношениями $R$, такими, что $\forall x \in \{0, 1\}^*$ за полиномиальное время можно найти $w$, для которого $(x, w) \in R$.
\end{Def}

\begin{Rem}
	Ключевой вопрос теории сложности: $\tilde P ?= \tilde {NP}$
\end{Rem}

\begin{Def}
	$NP$ "--- класс задач распознавания(языков), задаваемых полиномиально ограниченными полиномиально 
	проверяемыми массовыми задачами, то есть $NP = \{L(R)| R \in \tilde{NP}\}$

	Иначе говоря, $L \in NP$, если имеется п.о. п.п. $R$, такая, что 
	$$\forall x \in \{0, 1\}^* \colon x \in L \Lra \exists w (x, w) \in R$$
\end{Def}

\begin{Def}
	P "--- класс задач распознавания(языков) A, разрешимых за полиномиальное время\\
	То есть существует ДМТ $M$ и полином $q$, такой, что для любого слова $x$ $M(x)=A(x)$ и машина отработает не больше, чем за $q(|x|)$.
\end{Def}

\begin{Rem}
	Ясно, что $P \subset \{L(R)|R \in \tilde{P}\}$
\end{Rem}

Очевидно, $P \subset NP$.

\begin{Rem}
Ключивой вопрос теории сложности: $P ?= NP$
\end{Rem}


\subsection{Еще определения NP}
Определим НМТ.
\begin{Def}
	\textit{Недетерминированная машина Тьюринга} (НМТ) "--- почти вся та же ДМТ, кроме того, что функция перехода может быть многозначной. 
	То есть при данном состояние и данными символами под головкой возможны написания разных символов и разные сдвиги головки. 
\end{Def}

В НМТ может быть несколько вариантов переходов из одной конфигурации. 
В таком случае можно расмотреть дерево вычислений на НМТ:

\includegraphics[width=0.25\linewidth]{im1}

То есть дерево вычислений это все варианты переходов в НМТ и на конце 0 если закончили в состояние $q_N$ и 1, если в $q_Y$. 

\begin{Def}
	НМТ принимает слово $x$, если остановилась в состоянии $q_{yes}$ на хотя бы одной ветке.
\end{Def}

\begin{Def}
	Время и память в НМТ это максимум по времени и памяти по всем возможным веткам развития. 
\end{Def}

\begin{Rem}
	В машины(ДМТ, НМТ) с заведомо ограниченным временем работы можно встроить \textbf{будильник} и считать время вычисления на входах одной 
	длины всегда одним и тем же. 
\end{Rem}

Теперь определение НМТ, через ДМТ:
\begin{Def}
	Недетерминированная машина Тьюринга(НМТ) "--- это просто ДМТ, у которой есть дополнительный аргумент (подсказка w на второй ленте)
\end{Def}

\begin{Def}
	НМТ $M$ принимает вход $x$, если существует $w$, для которой вычисление заканчивается в $q_y$(пишем $M(x, w) = 1$).\\
\end{Def}

\begin{Rem}
	Вычислительный путь в старом определение это тоже самое, что подсказка в новом. Можно считать, что длина подсказки определяется длиной входа. 
\end{Rem}

\begin{Def}
	$NP$ "--- класс языков, принимаемых полиномиальными по времени НМТ.
\end{Def}

\begin{Rem}
	Последние определения класса $NP$, можно считать двумя, так как у нас есть несколько определений НМТ.
\end{Rem}