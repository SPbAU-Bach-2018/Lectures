\section{Пример языка из NP не NP-полного и не из P}
В прошлый раз мы говорили про классы $NP$ и $P$ и возникает естественный вопрос, есть ли в классе 
$NP$ какие-нибудь еще задачи, кроме задач из класса $P$ и $NP$-трудных. Сейчас мы докажем, 
что если $P \ne NP$, то такие задачи есть. Понятно, что если $P = NP$, то такого быть не может...

\begin{theorem}
	Если $P \ne NP$, то существует задача из $NP$, которая не 
	является $NP$-полной и не лежит в классе $P$.
\end{theorem}

\begin{proof}
	Делать мы будем это с помощью хитрой диаганализации.

	Построим новый язык $K$, который будет похож на выполнимаость, но мы кое-что от туда повыкидываем. 
	Для этого нам нужно посчитать функцию $f$, которая будет устроена следующим образом:
	$f \colon \N \to \N$  

	Если $f(|x|)$ четная, то все хорошо, если нечетная, то мы выкидываем эту выполнимую формулу из языка $K$.

	Другими словами язык $K = {x | x \in SAT \wedge f(|x|) \vdots 2}$.

	Теперь как мы будем считать $f$:
	\begin{enumerate}
    	\item за n шагов считаем функции начиная от 0 $f(0), f(1), \cdots f(i)$. 
    	Она конечно мало что успеет, но что-нибудь то успеет. Ну на этом $n$ не 
    	успеет, на другом успеет. Она такая, неторопливая функция. Обозначим 
    	последнее вычисленное число за k.($f(i) = k$)
    
    	Положим $f(0) = 0$\\
    	\item работаем за $n$ шагов. 
    	\begin{enumerate}
    		\item if (k --- четно) берем машину номер $\frac{k}{2}$ это нужно для 
    		того, что бы перебрать все машины, и пытаемся найти контрпример к тому, 
    		что эта машина вычисляет язык $K$. 
    		
    		if (существует z) $M_{\frac{k}{2}}(z) \ne K(z)$  return k + 1. 
    		Видимо, стоит машинке дать поработать n шагов и выкинуть если n шагов ей не хватило. 


    	    	Очень грустная машина, искать контрпример очень долго. Машина для языка $K$ тоже 
    		очень грустная, она решает SAT и вычисляет f рекурсивно. 

    		Если она не успела найти контрпример, то возращаем k. 
    
    		$M_i$ "--- $i$-ая машина Тьюринга. 
    		\item if (k "--- нечетно), то будем портить  жизнь сводимостям, что бы задача не стала $NP$-полной. 

    		if (существует z) $K(R_{\frac{k - 1}{2}}(z)) \ne SAT(z)$ return $k + 1$
    		
    		если не успели, вернули $k$. $R$ это сведение. 
    	\end{enumerate} 
	\end{enumerate}

	Это очень медленно растущая функция, но если контрпримеры есть, то $f$ увеличивается.

	Теперь давай-те докажем, что $K$  не является полиномиально разрешимым и не является $NP-$полным. 
	\begin{enumerate}
		\item Пусть $K$ полиномиально разрешим, тогда с какого-то момента f останется навсегда на какой-то 
		четной константе, поскольку просто будет существавать машина, для котрой не найдется контрпримера, но тогда, 
		по определению языка $K$, наш язык отличается от $SAT$, только в конечном числе точек, значит 
		язык эквивалентен $NP$"---полному. Значит $P = NP$, но мы предположили, что это не так. 	
		\item Если K $NP$ "--- полная, то мы во втором случае никогда не найдем контр пример, то 
		есть в какой-то момент остановимся на нечетной константе. 
		Но тогда, по определению языка, в него могут попасть только конечное число элементов, противоречие с тем, что язык $NP$--- полный. 
\end{enumerate}
\end{proof}

\section{Полиномиальная иерархия}
\subsection{Оракульная машина тьюринга}
	\begin{Def}
	Оракульная машина тьюринга имеет доступ к оракулу, который за один шаг
	дает ответ на вопрос. 

	Формально: состояния $q_{in}$, $q_{out}$  и "фантастический переход" из 
	$q_{in}$ в $q_{out}$,заменяющий содержимое третий ленты на ответ оракула. 
	\end{Def}
	$M^B$ "--- оракульная машина M, котрый дали конкртетный оракул B. Класс NP может быть не замкнут относительно этих операций. 


Теперь некотрая тонкость про оракульные классы. Когда мы пишем $P^{NP}$, мы имеем в виду, что язык из класса 
$P$ задается машиной тьюринга и уже к ней привешивается оракул, а точнее какую-то конкретную задачу из класса $NP$.
Можно, на самом деле считать и что задача одна, и что задач много, так как всегда можно будет самостоятельно свести
к полной задаче и попросить решить ее. 

Например, в будующем будет пример, когда два классы равны, но существует оракул для которого они равны. 

\subsection{Определение иерархии по времени:} 
\begin{Def}
	$co-C = {L|\bar{L} \in C}$
\end{Def}

\begin{exmp}
	Например, $SAT \in NP$, а $\{$всюду ложных формул$\} \in co-NP$.\\
\end{exmp}

\begin{Rem}
	$co-NP$ пересекается с $NP$ по $P$, но может быть по чему-нибудь еще. 
\end{Rem}

\begin{Def}
	Полиномиальная иерархия. 
	$\sigma^0P = \Pi^0P = \Delta^0P = P$\\
	$\sigma^{i + 1}P = NP^{\Pi^iP}$\\
	$\Pi^{i + 1}P = co-NP^{\Sigma^iP}$\\
	$\Delta^{i + 1}P = P^{\sigma^iP}$\\
	\\
	$\Sigma^{i} = co-\Pi^{i}$\\
	\\
	$PH = \cup_{i \ge 0}\Sigma^{i}P$ \\
\end{Def}

\begin{theorem}
	$L \in \Sigma^{k}P \Lra \exists$ полиномиально ограниченное отношение $R \in \Pi^{k - 1}P$ такое,
	что $\forall x (x \in L \Lra \exists y R((x, y)))$
\end{theorem}
\begin{proof}
	\begin{description}
	\item[$\La$] L распазнается следующей машиной с оракулом $R:$ недетерменированно выбираем $y$ и проверяем $R(x, y)$ с помощью оракула.
	\item[$\Ra$] 
		Индукция, что есть $L \in \Sigma^{k}P$, то существует R, такая что $\forall x (x \in L \Lra \exists y R((x, y)))$. 
    		\begin{description}
    		\item[База:]
    			$\Sigma^1 P = NP$ это определение класса $NP$.
    		\item[Переход:] 
   			Для $k - 1$ верно, доказываем для $k$.
    
    			$L = L(M^O)$.
    			По определению задается оракульной недетерменнированой машиной $M$ с оракулом $O \in \Sigma^{k - 1}P$. 
    			По предположению индукции имеется полиномиально ограниченная $S \in \Pi^{k - 2}P$, такое что 
    			$\forall q(q \in O \Lra \exists w S(q, w) = 1)$.

    			Строим R.

   			$R(x, y) = 1$, если $y$ "--- принимающая ветвь вычисления для нашей оракульной машины $M^O$, 
   			но при каждом обращение в ветке $y$ к оракулу в случае положительного ответа $y$ так же содержит 
   			сертификат $w \colon S(q, w) = 1$.

  			Докажем, что $R \in \Pi^{k - 1}P:$ 
  			
  			Во-первых, нужно проверить корректность всех ходов $M^O$,
  			это мы делаем за полиномиальное время.  
  			
  			Во-вторых, должна проверить отношение $S(q, w)$, это мы 
  			можем проверять за время $\Pi^{k - 2}P$. 

  			И наконец, для всех отрицательных ответов нужно проверить, что
  			действительно не существует такого w, что $S(q, w) = 1$. 
  			
  			Это может быть сделано в рамках $\Pi^{k - 1}P$, так как $O \in \Sigma^{k - 1}P$, 
  			а это со-задача.
  		\end{description}
	\end{description}
\end{proof}             

\begin{conseq}
	$L \in \Sigma^k P \Lra \exists$ полиномиально ограниченное $(k + 1)$-арное
	отношение $R \in P$, такое, что $\forall x(x \in L \Lra \exists y_1 \forall y_2 \exists y_3 \cdots R(x, y_1, \cdots, y_k))$\\
\end{conseq}


\begin{Def}
	$QFB_k$ состоит из замкнутых истиных формул вида
	$$\exists X_1 \forall X_2 \exists X_3 \cdots X_k \phi$$
	где $\phi$ формула в КНФ или ДНФ, а $\{X_i\}_{i = 1}^{k}$ "---
	разбиение множества переменных этой формулы на непустые непересекающиеся подмножества. 
\end{Def}

\begin{theorem}
	$QBF_k$ "--- $\Sigma^kP$"---полные задачи. 
\end{theorem}

\begin{proof}
	Нужно свести произвольный язык из $\Sigma^{k}P$ к $QBF_k$.\\ 
	
	Что бы это доказать, нужно воспользоваться следствием и это 
	уже почти доказательство. k квантеров у нас уже есть, но у нас после этих квантеров написано полиномиально проверяемое 
	отношение, а мы бы хотели, что бы была записана булева формула.

	Из отношения сделать булеву формулу мы можем с помощью теоремы Кука-Левина. 

	$L \in \Sigma^{k}P \Lra \exists$ полиномиально ограниченые $R \in P$
	такое, что $\forall x(x \in L \Lra  \exists y_1 \forall y_2 \cdots R(x, y_1, \cdots, y_k))$
	
	Считаем, что все $y_i$ полиномиально ограничены от $x$.

	Если последний квантор "--- $\exists$, то запишем R в виде булевой формулы 
	$\Phi$ как в теореме Кука-Левина: $R(z) \Lra \exists w \Phi(z, w)$\\

	Итог: $\forall x(x \in L \Lra \exists y_1 \forall y_2 \cdots \exists w(\Phi(x, y_1, \cdots, w)))$.

	Если последний квантор "--- $\forall$, то запишем $\bar R$ в виде булевой формулы 
	$\Psi$ как в теореме Кука-Левина: $\bar R(z) \Lra \exists w \Pi(z,w)$\\
	Итог: $\forall x(x \in L \Lra \exists y_1 \forall y_2 \cdots \forall w(\bar{\Psi}(x, y_1, \cdots, w)))$.

	Здесь мы доказали, что задача $\Sigma^k$ трудная, но принадлежность $\Sigma^k$ очевидна. 
\end{proof}

\begin{theorem}
	Если $\Sigma^k P = \Pi^k P \Ra PH = \Sigma^kP$, при $k > 0$. 
\end{theorem}
\begin{proof}
	При $k = 1$ все просто, значит $NP = coNP$, значит квантор существования можно заменить на квантр всеобщности и все,
	все кванторы сразу становятся одинаковыми.

	Теперь на $k$-ом уровне более формально.
	
	Достаточно показать, что k + 1 уровень и k совпадают, то есть, что $\Sigma^{k + 1}P = \Pi^kP$.

	Пусть $L \in \Sigma^{k + 1}P$, то есть $L = \{x \colon \exists y R(x, y)\}$, для $R \in \Pi^k P = \Sigma^k P$.

	Значит, имеется $S \in \Pi^{k - 1}P$, такое что $R(x, y) \Lra \exists z S(x, y, z)$, то есть
	$x \in L \Lra \exists y \exists z S(x,y, z)$, то есть $L \in \Sigma^{k}P$ 
\end{proof}

\begin{conseq}
	Если существует $PH$-полная задача, то полиномиальная иерархия конечна. 
\end{conseq}

\begin{proof}
	Так как $L$ лежит в конкретном $\Sigma^k P$.
\end{proof}

\section{Классы, ограниченные по времени и памяти}
\subsection{Определения классов DTime и DSpace}
\begin{Def}
	$DTime[f(n)] = \{L| L\text{принимается ДМТ, работающей время O(f(n))}\}$\\
	$f(n)$ должна быть конструктивной по времени. То есть такой, что 
	существует машина тьюринга, которой если дать на вход $1^n$, она 
	может вывести $1^{f(n)}$ за время $O(f(n))$.
\end{Def}

\begin{Rem}
	$$P = \cup_{k \ge 0}DTime[n^k]$$
\end{Rem}

\begin{Def}
	$DSpace[f(n)] = \{L|L\text{ принимается ДМТ с памятью O(f(n))}\}$.\\
	$f(n)$ конструктивная по памяти, то есть существует машина Тьюринга, которой дали на вход $1^n$, 
	она выдала $1^{f(n)}$ и использовала при этом $O(f(n))$ памяти.
\end{Def}
\begin{Def}
	$$PSPACE = \cup_{k \ge 0}DSpace[n^k]$$
\end{Def}

\subsection{PSPACE-полная задача}
\begin{Def}
	Задача QBF - задача выполнимости формулы с кванторами. 
\end{Def}
\begin{theorem}
	QBF $PSPACE$-полная. 
\end{theorem}
\begin{proof}
	\begin{description}
	\item[$QBF \in  PSPACE$]. 
	С полиномиальной памятью мы умеем делать совершенно любой перебор. 
	Так как длина сертифекатов полиномиальная. 
	Перебираем все возможные сертификаты и подставляем их в R.

	\item[Сводим $L \in PSPACE$ к $QBF$.]
	L задается какое-то машиной тьюринга с полиномиальной памятью.\\ 
	
	Построим граф $2^{p(n)}$ конфигураций машины, принимающей $L$. Решим задачу достижимости.

	Строим $\phi_i(c_1, c_2) = $"существует путь из $c_1$ в $c_2$ длины $\le 2^i$"\\
	
	$\phi_i(c_1, c_2) = \exists d \forall x \forall y(((x = c_1 \wedge y = d) \vee (x = d \wedge y = c_2)) \Ra \phi_{i - 1}(x, y))$\\
	$\phi_0(c_1, c_2)$ записывается как в теореме Кука-Левина.  
	
	Длина как раз log получается от количества вершин и петлю на конец можем добавится, что бы достаточно большая степень двойки подошла.
	\end{description}
\end{proof}

\begin{conseq}
	Если $PH = PSPACE \Ra$ все сломается, значит что в полиномиальной иерархии завелась полная задача. 
\end{conseq}