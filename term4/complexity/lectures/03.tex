\section{Эквивалентность задач поиска и распознования для $NP$-полных языков}
	\begin{theorem}
		Пусть есть массовая задача $R \in \widetilde{NP}$, причём $L(R)$ "--- $\NP$-полон.
		Пусть также есть алгоритм $A$ для разрешения языка $L(R)$.
		Тогда имеется алгоритм $B$ для решения задачи поиска $R$, работающий не более, чем в полином раз медленнее алгоритма $A$.
	\end{theorem}
	\begin{Rem}
		Смысл такой: есть мы для $\NP$-полной задачи умеем проверять существование ответа, то искать ответ мы умеем не сильно медленнее.
	\end{Rem}
	\begin{proof}
		Мы знаем, что так как $L(R) \in \mathsf{NPC}$, то к $L(R)$ можно свести задачу $\SAT$,
		т.е. есть такая п.о. полиномиально вычислимая $f$, что для любой формулы $\phi$:
		\[ \phi \in \SAT \iff f(\phi) \in L(R) \]
		Значит, у нас есть алгоритм для проверки выполнимости формулы не медленнее, чем в полином раз медленнее $A$.
		Давайте теперь научимся, используя этот алгоритм, находить решение.
		Это просто: мы берём формулу, проверяем выполнимость.
		Если выполнима, то подставляем $x_1=0$, если формула всё ещё выполнима "--- мы угадали одну переменную, идём дальше.
		Иначе точно надо подставить $x_1=1$ и начать угадывать следующие переменные.
		Всего у нас будет не более $k$ запусков проверки на выполнимость, если имеется $k$ переменных.

		Т.о. есть алгоритм $A'$, который ищет решение $\mathsf{SAT}$ довольно быстро.

		Давайте учиться по условию $x$ для задачи $R$ быстро искать ответ.
		У нас есть ДМТ $M$, которая по входу из условия и решения $R$ проверяет корректность.
		Аналогично доказательству теоремы Кука-Левина (4 билет) можно построить булеву формулу, эмулирующую $M$.
		В неё будет зашито условие $x$, а переменные будут в точности задавать решение для входа, формула
		будет верна тогда и только тогда, когда решение действительно является решением.
		А для этой формулы мы можем применить алгоритм $A'$, который быстро найдёт решение.
	\end{proof}
	\begin{Rem}
		Краткая схема доказательства:
		\begin{enumerate}
			\item Сводим $\mathsf{SAT}$ к нашему $\NP$-полному языку, теперь умеем быстро проверять выполнимость.
			\item Угадываем значения переменных по одной, теперь мы умеем быстро искать решения для булевых формул.
			\item Строим по машине, проверяющей решение $R$, эквивалентную булеву формулу, решением которой будут являться в точности решения исходной задачи.
				Мы уже умеем быстро искать решения для булевых формул, успех.
		\end{enumerate}
	\end{Rem}
	\begin{Rem}
		$\NP$-полнота существенна, например, про задачу поиска нетривиальных делителей $\mathsf{FACTOR}$ такого неизвестно.
		Мы знаем детерминированные полиномиальные (от длины числа) алгоритмы проверки на простоту (ABS-тест), но вот искать делители так же эффективно не умеем.
	\end{Rem}

\section{Пример языка из NP не NP-полного и не из P}
В прошлый раз мы говорили про классы $NP$ и $P$ и возникает естественный вопрос, есть ли в классе 
$NP$ какие-нибудь еще задачи, кроме задач из класса $P$ и $NP$-трудных. Сейчас мы докажем, 
что если $P \ne NP$, то такие задачи есть. Понятно, что если $P = NP$, то такого быть не может...

\begin{theorem}
	Если $P \ne NP$, то существует задача из $NP$, которая не 
	является $NP$-полной и не лежит в классе $P$.
\end{theorem}

\begin{proof}
	Делать мы будем это с помощью хитрой диаганализации.

	Построим новый язык $K$, который будет похож на выполнимаость, но мы кое-что от туда повыкидываем. 
	Для этого нам нужно посчитать функцию $f$, которая будет устроена следующим образом:
	$f \colon \N \to \N$  

	Если $f(|x|)$ четная, то все хорошо, если нечетная, то мы выкидываем эту выполнимую формулу из языка $K$.

	Другими словами язык $K = {x | x \in SAT \wedge f(|x|) \vdots 2}$.

	Теперь как мы будем считать $f$:
	\begin{enumerate}
    	\item за n шагов считаем функции начиная от 0 $f(0), f(1), \cdots f(i)$. 
    	Она конечно мало что успеет, но что-нибудь то успеет. Ну на этом $n$ не 
    	успеет, на другом успеет. Она такая, неторопливая функция. Обозначим 
    	последнее вычисленное число за k.($f(i) = k$)
    
    	Положим $f(0) = 0$\\
    	\item работаем за $n$ шагов. 
    	\begin{enumerate}
    		\item if (k --- четно) берем машину номер $\frac{k}{2}$ это нужно для 
    		того, что бы перебрать все машины, и пытаемся найти контрпример к тому, 
    		что эта машина вычисляет язык $K$. 
    		
    		if (существует z) $M_{\frac{k}{2}}(z) \ne K(z)$  return k + 1. 
    		Видимо, стоит машинке дать поработать n шагов и выкинуть если n шагов ей не хватило. 


    	    	Очень грустная машина, искать контрпример очень долго. Машина для языка $K$ тоже 
    		очень грустная, она решает SAT и вычисляет f рекурсивно. 

    		Если она не успела найти контрпример, то возращаем k. 
    
    		$M_i$ "--- $i$-ая машина Тьюринга. 
    		\item if (k "--- нечетно), то будем портить  жизнь сводимостям, что бы задача не стала $NP$-полной. 

    		if (существует z) $K(R_{\frac{k - 1}{2}}(z)) \ne SAT(z)$ return $k + 1$
    		
    		если не успели, вернули $k$. $R$ это сведение. 
    	\end{enumerate} 
	\end{enumerate}

	Это очень медленно растущая функция, но если контрпримеры есть, то $f$ увеличивается.

	Теперь давай-те докажем, что $K$  не является полиномиально разрешимым и не является $NP-$полным. 
	\begin{enumerate}
		\item Пусть $K$ полиномиально разрешим, тогда с какого-то момента f останется навсегда на какой-то 
		четной константе, поскольку просто будет существавать машина, для котрой не найдется контрпримера, но тогда, 
		по определению языка $K$, наш язык отличается от $SAT$, только в конечном числе точек, значит 
		язык эквивалентен $NP$"---полному. Значит $P = NP$, но мы предположили, что это не так. 	
		\item Если K $NP$ "--- полная, то мы во втором случае никогда не найдем контр пример, то 
		есть в какой-то момент остановимся на нечетной константе. 
		Но тогда, по определению языка, в него могут попасть только конечное число элементов, противоречие с тем, что язык $NP$--- полный. 
\end{enumerate}
\end{proof}

\section{Полиномиальная иерархия}
\subsection{Оракульная машина тьюринга}
	\begin{Def}
	Оракульная машина тьюринга имеет доступ к оракулу, который за один шаг
	дает ответ на вопрос. 

	Формально: состояния $q_{in}$, $q_{out}$  и "фантастический переход" из 
	$q_{in}$ в $q_{out}$,заменяющий содержимое третий ленты на ответ оракула. 
	\end{Def}
	$M^B$ "--- оракульная машина M, котрый дали конкртетный оракул B. Класс NP может быть не замкнут относительно этих операций. 


Теперь некотрая тонкость про оракульные классы. Когда мы пишем $P^{NP}$, мы имеем в виду, что язык из класса 
$P$ задается машиной тьюринга и уже к ней привешивается оракул, а точнее какую-то конкретную задачу из класса $NP$.
Можно, на самом деле считать и что задача одна, и что задач много, так как всегда можно будет самостоятельно свести
к полной задаче и попросить решить ее. 

Например, в будующем будет пример, когда два классы равны, но существует оракул для которого они равны. 

\subsection{Определение иерархии по времени:} 
\begin{Def}
	$co-C = {L|\bar{L} \in C}$
\end{Def}

\begin{exmp}
	Например, $SAT \in NP$, а $\{$всюду ложных формул$\} \in co-NP$.\\
\end{exmp}

\begin{Rem}
	$co-NP$ пересекается с $NP$ по $P$, но может быть по чему-нибудь еще. 
\end{Rem}

\begin{Def}
	Полиномиальная иерархия. 
	$\sigma^0P = \Pi^0P = \Delta^0P = P$\\
	$\sigma^{i + 1}P = NP^{\Pi^iP}$\\
	$\Pi^{i + 1}P = co-NP^{\Sigma^iP}$\\
	$\Delta^{i + 1}P = P^{\sigma^iP}$\\
	\\
	$\Sigma^{i} = co-\Pi^{i}$\\
	\\
	$PH = \cup_{i \ge 0}\Sigma^{i}P$ \\
\end{Def}

\begin{theorem}
	$L \in \Sigma^{k}P \Lra \exists$ полиномиально ограниченное отношение $R \in \Pi^{k - 1}P$ такое,
	что $\forall x (x \in L \Lra \exists y R((x, y)))$
\end{theorem}
\begin{proof}
	\begin{description}
	\item[$\La$] L распазнается следующей машиной с оракулом $R:$ недетерменированно выбираем $y$ и проверяем $R(x, y)$ с помощью оракула.
	\item[$\Ra$] 
		Индукция, что есть $L \in \Sigma^{k}P$, то существует R, такая что $\forall x (x \in L \Lra \exists y R((x, y)))$. 
    		\begin{description}
    		\item[База:]
    			$\Sigma^1 P = NP$ это определение класса $NP$.
    		\item[Переход:] 
   			Для $k - 1$ верно, доказываем для $k$.
    
    			$L = L(M^O)$.
    			По определению задается оракульной недетерменнированой машиной $M$ с оракулом $O \in \Sigma^{k - 1}P$. 
    			По предположению индукции имеется полиномиально ограниченная $S \in \Pi^{k - 2}P$, такое что 
    			$\forall q(q \in O \Lra \exists w S(q, w) = 1)$.

    			Строим R.

   			$R(x, y) = 1$, если $y$ "--- принимающая ветвь вычисления для нашей оракульной машины $M^O$, 
   			но при каждом обращение в ветке $y$ к оракулу в случае положительного ответа $y$ так же содержит 
   			сертификат $w \colon S(q, w) = 1$.

  			Докажем, что $R \in \Pi^{k - 1}P:$ 
  			
  			Во-первых, нужно проверить корректность всех ходов $M^O$,
  			это мы делаем за полиномиальное время.  
  			
  			Во-вторых, должна проверить отношение $S(q, w)$, это мы 
  			можем проверять за время $\Pi^{k - 2}P$. 

  			И наконец, для всех отрицательных ответов нужно проверить, что
  			действительно не существует такого w, что $S(q, w) = 1$. 
  			
  			Это может быть сделано в рамках $\Pi^{k - 1}P$, так как $O \in \Sigma^{k - 1}P$, 
  			а это со-задача.
  		\end{description}
	\end{description}
\end{proof}             

\begin{conseq}
	$L \in \Sigma^k P \Lra \exists$ полиномиально ограниченное $(k + 1)$-арное
	отношение $R \in P$, такое, что $\forall x(x \in L \Lra \exists y_1 \forall y_2 \exists y_3 \cdots R(x, y_1, \cdots, y_k))$\\
\end{conseq}


\begin{Def}
	$QFB_k$ состоит из замкнутых истиных формул вида
	$$\exists X_1 \forall X_2 \exists X_3 \cdots X_k \phi$$
	где $\phi$ формула в КНФ или ДНФ, а $\{X_i\}_{i = 1}^{k}$ "---
	разбиение множества переменных этой формулы на непустые непересекающиеся подмножества. 
\end{Def}

\begin{theorem}
	$QBF_k$ "--- $\Sigma^kP$"---полные задачи. 
\end{theorem}

\begin{proof}
	Нужно свести произвольный язык из $\Sigma^{k}P$ к $QBF_k$.\\ 
	
	Что бы это доказать, нужно воспользоваться следствием и это 
	уже почти доказательство. k квантеров у нас уже есть, но у нас после этих квантеров написано полиномиально проверяемое 
	отношение, а мы бы хотели, что бы была записана булева формула.

	Из отношения сделать булеву формулу мы можем с помощью теоремы Кука-Левина. 

	$L \in \Sigma^{k}P \Lra \exists$ полиномиально ограниченые $R \in P$
	такое, что $\forall x(x \in L \Lra  \exists y_1 \forall y_2 \cdots R(x, y_1, \cdots, y_k))$
	
	Считаем, что все $y_i$ полиномиально ограничены от $x$.

	Если последний квантор "--- $\exists$, то запишем R в виде булевой формулы 
	$\Phi$ как в теореме Кука-Левина: $R(z) \Lra \exists w \Phi(z, w)$\\

	Итог: $\forall x(x \in L \Lra \exists y_1 \forall y_2 \cdots \exists w(\Phi(x, y_1, \cdots, w)))$.

	Если последний квантор "--- $\forall$, то запишем $\bar R$ в виде булевой формулы 
	$\Psi$ как в теореме Кука-Левина: $\bar R(z) \Lra \exists w \Pi(z,w)$\\
	Итог: $\forall x(x \in L \Lra \exists y_1 \forall y_2 \cdots \forall w(\bar{\Psi}(x, y_1, \cdots, w)))$.

	Здесь мы доказали, что задача $\Sigma^k$ трудная, но принадлежность $\Sigma^k$ очевидна. 
\end{proof}

\begin{theorem}
	Если $\Sigma^k P = \Pi^k P \Ra PH = \Sigma^kP$, при $k > 0$. 
\end{theorem}
\begin{proof}
	При $k = 1$ все просто, значит $NP = coNP$, значит квантор существования можно заменить на квантр всеобщности и все,
	все кванторы сразу становятся одинаковыми.

	Теперь на $k$-ом уровне более формально.
	
	Достаточно показать, что k + 1 уровень и k совпадают, то есть, что $\Sigma^{k + 1}P = \Pi^kP$.

	Пусть $L \in \Sigma^{k + 1}P$, то есть $L = \{x \colon \exists y R(x, y)\}$, для $R \in \Pi^k P = \Sigma^k P$.

	Значит, имеется $S \in \Pi^{k - 1}P$, такое что $R(x, y) \Lra \exists z S(x, y, z)$, то есть
	$x \in L \Lra \exists y \exists z S(x,y, z)$, то есть $L \in \Sigma^{k}P$ 
\end{proof}

\begin{conseq}
	Если существует $PH$-полная задача, то полиномиальная иерархия конечна. 
\end{conseq}

\begin{proof}
	Так как $L$ лежит в конкретном $\Sigma^k P$.
\end{proof}

\section{Сводимость по Тьюрингу}
	\begin{Def}
		Задача $A$ \textit{сводится по Тьюрингу} к задаче $B$, если есть машина $M^B$ решающая задачу $A$.
	\end{Def}
	\begin{Rem}
		Про время работы вообще ничего не говорим.
		Так можно сводить не только языки (т.е. задачи распознавания), но и задачи поиска.
	\end{Rem}
	\begin{Rem}
		Это сведение для языков "--- более общий случай сведения по Карпу (там мы разрешаем вызвать оракула только один раз, только в конце, и ничего не можем делать с его ответом).
	\end{Rem}

	\begin{assertion}
		Классы $\P$ и $\widetilde{\P}$ замкнуты относительно сведения по Тьюрингу, т.е. $\P^{\P}=\P$ и $\widetilde\P^{\widetilde\P}=\widetilde\P$
	\end{assertion}
	\begin{proof}
		Мы можем заменить все магические вызовы оракула на явный запуск оракула.
		Пусть машина работала $t$ шагов, где $t \le p(n)$ ($n$ "--- длина входа машины).
		Тогда, очевидно, она не может скормить оракулу строчку длиннее $t$.
		Так как оракул работает за $q(k)$ (где $k$ "--- длина \textit{входа оракула}, а $p$ "--- полином),
		то на каждом входе оракул будет работать не более $q(p(n))$ "--- тоже какой-то полином.

		Если мы вместо обращения к оракулу будем явно вычислять функцию, то получим замедленее не более, чем в $q(p(n))$ раз,
		т.е. всё равно полином.
	\end{proof}
	\begin{Rem}
		Обратите внимание, что в общем случае оракул может получать гораздо более длинный вход, чем сама машина получила на вход.
		Длина входа оракула ограничена только временем работы.
	\end{Rem}
	\begin{Rem}
		А вот про классы $\NP$ и $\widetilde{\NP}$ мы такой замкнутости не знаем.
	\end{Rem}

	\begin{theorem}
		\begin{itemize}
			\item Для любой задачи поиска $R$ из $\NP$:
			\item Существует Л\'евинский оптимальный алгоритм поиска $A$ (детерминированный) со следующим свойством:
			\item Для любого другого алгоритм $B$, решающего задачу $R$:
			\item Существует такой полином $p$, что:
			\item На любом входе $x$, где есть ответ:
			\item Время работы $A$ не более чем $p(t)$, где $t$ "--- время работы $B$.
		\end{itemize}
	\end{theorem}
	\begin{proof}
		$A$ будет перебирать вообще все детерминированные машины: не только полиномиальные, не только останавливающиеся, а вообще все.
		Это можно сделать, перебирая все конечные строки (например, для описаний, не являющимися корректными машинами, можно считать, что они имеют право вести себя как угодно).
		Назовём эти машины $M_0, \dots, M_n, \dots$.

		Давайте будем на шаге с номером $i=2^l(1+2k)$ моделировать $k$-й шаг машины $M_l$, то есть на нечётных шагах моделируем шаги $M_1$,
		на деляющихся только на 2 (но не на 4) "--- шаги $M_2$, на делящихся на 4 "--- $M_3$ и так далее.
		Если какая-нибудь машина завершается, то мы смотрим на её ответ и проверяем, не является ли он ответом на задачу.
		Если является, то выдаём, иначе продолжаем эмуляцию.

		Заметим, что если есть какой-то алгоритм поиска (а какой-то точно есть "--- можно просто перебрать все решения), то мы на входе $x$ точно когда-то завершимся.
		Давайте предположим, что есть алгоритм $B$, которому соответствует машина $M_a$ и который на входе $x$ завершится за время $t$.
		Тогда мы обнаружим этот факт через $2^a(1+2t)$ шагов алгоритма (если не найдём ответ раньше), обозначим это число за $n$.
		Тогда заметим, что на каждом из предыдущих шагов мы тратили константное время не более $\O(n)$ времени на эмуляцию очередного шага очередной МТ
		и не более $\O(p(n))$ времени на проверку возможно выданного ответа (так как ответ не может быть больше времени работы МТ, а его проверка делается за полином).
		Значит, всего у нас время работы до завершения оптимального алгоритма на входе $x$ не более $n \cdot \O(n) \cdot \O(p(n))$, что есть полином от $n$, что есть
		полином от $t$, что и требовалось показать.
	\end{proof}
	\begin{Rem}
		На входах без ответа наш алгоритм зацикливается.
	\end{Rem}
	\begin{Rem}
		Это полезное знание, если у есть конечное число оптимальных алгоритмов $A_1, \dots, A_k$, причём каждый из алгоритмов быстро работает на каком-то своём множестве входов (но тормозит на других).
		Тогда оптимальный алгоритм будет работать на каждом выходе не более, чем в полином раз медленнее, чем \textit{каждый} из этих алгоритмов.
		А так как их конечно, то мы даже можем сказать, что оптимальный алгоритм на каждом входе не сильно хуже, чем оптимальный для этого входа.
	\end{Rem}


\section{Классы, ограниченные по времени и памяти}
\subsection{Определения классов DTime и DSpace}
\begin{Def}
	$DTime[f(n)] = \{L| L\text{принимается ДМТ, работающей время O(f(n))}\}$\\
	$f(n)$ должна быть конструктивной по времени. То есть такой, что 
	существует машина тьюринга, которой если дать на вход $1^n$, она 
	может вывести $1^{f(n)}$ за время $O(f(n))$.
\end{Def}

\begin{Rem}
	$$P = \cup_{k \ge 0}DTime[n^k]$$
\end{Rem}

\begin{Def}
	$DSpace[f(n)] = \{L|L\text{ принимается ДМТ с памятью O(f(n))}\}$.\\
	$f(n)$ конструктивная по памяти, то есть существует машина Тьюринга, которой дали на вход $1^n$, 
	она выдала $1^{f(n)}$ и использовала при этом $O(f(n))$ памяти.
\end{Def}
\begin{Def}
	$$PSPACE = \cup_{k \ge 0}DSpace[n^k]$$
\end{Def}

\subsection{PSPACE-полная задача}
\begin{Def}
	Задача QBF - задача выполнимости формулы с кванторами. 
\end{Def}
\begin{theorem}
	QBF $PSPACE$-полная. 
\end{theorem}
\begin{proof}
	\begin{description}
	\item[$QBF \in  PSPACE$]. 
	С полиномиальной памятью мы умеем делать совершенно любой перебор. 
	Так как длина сертифекатов полиномиальная. 
	Перебираем все возможные сертификаты и подставляем их в R.

	\item[Сводим $L \in PSPACE$ к $QBF$.]
	L задается какое-то машиной тьюринга с полиномиальной памятью.\\ 
	
	Построим граф $2^{p(n)}$ конфигураций машины, принимающей $L$. Решим задачу достижимости.

	Строим $\phi_i(c_1, c_2) = $"существует путь из $c_1$ в $c_2$ длины $\le 2^i$"\\
	
	$\phi_i(c_1, c_2) = \exists d \forall x \forall y(((x = c_1 \wedge y = d) \vee (x = d \wedge y = c_2)) \Ra \phi_{i - 1}(x, y))$\\
	$\phi_0(c_1, c_2)$ записывается как в теореме Кука-Левина.  
	
	Длина как раз log получается от количества вершин и петлю на конец можем добавится, что бы достаточно большая степень двойки подошла.
	\end{description}
\end{proof}

\begin{conseq}
	Если $PH = PSPACE \Ra$ все сломается, значит что в полиномиальной иерархии завелась полная задача. 
\end{conseq}