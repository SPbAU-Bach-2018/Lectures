\section{Пример языка из NP не NP-полного и не из P}
В прошлый раз мы говорили про классы $NP$ и $P$ и 
возникает естественный вопрос, есть ли в классе 
$NP$ какие-нибудь еще задачи, кроме задач из 
класса $P$ и $NP$ "--- трудных. Сейчас мы докажем, 
что если $P \ne NP$, то такие задачи есть. Понятно, что
если $P = NP$, то такого быть не может...
\begin{theorem}
Если $P \ne NP$, то 
существует задача из $NP$, которая не 
является $NP$ "--- полной и не лежит в классе $P$.
\end{theorem}
\begin{proof}
Делать мы будем это с помощью хитрой диаганализации.

Построим новый язык $K$, который будет похож на 
выполнимаость, но мы кое-что от туда повыкидываем, 
для этого нам нужно посчитать функцию $f$, которая 
будет устроена следующим образом:
$f\colon \N \to \N$  
Если $f$ четная, то все хорошо, если нечетная, 
то мы выкидываем эту выполнимую формулу из языка $K$.

Другими словами язык $K = {x | x \in SAT \wedge f(|x|) \vdots 2}$.

Теперь как мы будем считать $f$:
\begin{enumerate}
    \item за n шагов считаем функции начиная от 0 $f(0), f(1), \cdots f(i)$. 
    Она конечно мало что успеет, но что-нибудь то успеет. Ну на этом $n$ не 
    успеет, на другом успеет. Она такая, неторопливая функция. Обозначим 
    последнее вычисленное число за k.($f(i) = k$)
    
    Положим $f(0) = 0$\\
    \item работаем за $n$ шагов. 
    \begin{enumerate}
    \item if (k --- четно) берем машину номер $\frac{k}{2}$ это нужно для 
    того, что бы перебрать все машины, и пытаемся найти контрпример к тому, 
    что эта машина вычисляет язык $K$. if (существует z) $M_{\frac{k}{2}} \ne K(z)$  return k + 1. 

    Очень грустная машина, искать контрпример очень долго. Машина для языка $K$ тоже 
    очень грустная, она решает SAT и вычисляет f рекурсивно. 

    Если она не успела найти контрпример, то возращаем k. 
    
    $M_i$ "--- $i$-ая машина Тьюринга. 
    \item if (k "--- нечетно), то будем портить  жизнь сводимостям, 
    что бы задача не стала $NP$ полной. 

    if (существует z) $K(R_{\frac{k - 1}{2}}) \ne SAT(z)$ return $k + 1$
    если не успели, вернули $k$. $R$ это сведение. 
    \end{enumerate} 
\end{enumerate}

Это очень медленно растущая функция, но если контрпримеры есть, 
то $f$ увеличивается.

Теперь давай-те докажем, что $K$  не является полиномиально разрешимым и 
не является $NP-$полным. 
\begin{enumerate}
\item Пусть $K$ полиномиально разрешим, тогда 
с какого-то момента f останется навсегда на какой-то 
четной константе, поскольку просто будет существавать 
машина, для котрой не найдется контрпримера, но тогда, 
по определению языка $K$, наш язык отличается от 
$SAT$, только в конечном числе точек, значит 
язык эквивалентен $NP$"---полному. Значит $P = NP$, 
но мы предположили, что это не так. 
\item 
Если K $NP$ "--- полная, то мы во втором 
случае никогда не найдем контр пример, то 
есть в какой-то момент остановимся на нечетной константе. 
Но тогда, по определению языка, в него могут попасть только конечное число 
элементов, противоречие с тем, что язык $NP$--- полный. 
\end{enumerate}
\end{proof}

\section{Полиномиальная иерархия}

Теперь некотрая тонкость про оракульные классы. Когда 
мы пишем $P^{NP}$, мы имеем в виду, что язык из класса 
$P$ задается машиной тьюринга и уже к ней привешивается оракул. 

Нпример, в будующем будет пример, когда два классы равны, но существует оракул
для которого они равны. 
 
$co-C = {L|\bar{L} \in C}$
Например, $SAT \in NP$, а $\{$всюду ложных формул$\} \in co-NP$.\\

$co-NP$ пересекается с $NP$ по $P$, но может быть по чему-нибудь еще. 

Давай-те же строить иерархию.
$\sigma^0P = \Pi^0P = \Delta^0P = P$\\
$\sigma^{i + 1}P = NP^{\Pi^iP}$\\
$\Pi^{i + 1}P = co-NP^{\Sigma^iP}$\\
$\Delta^{i + 1}P = P^{\sigma^iP}$

$\Sigma^{i} = co-\Pi^{i}$\\

$PH = \cup_{i \ge 0}\Sigma^{i}P$ \\

Все это полиномиальная иерархия. 

Иногда возникает вопрос, можно ли использовать один язык, или 
любой язык из класса, если там есть полный язык, то это неважно, 
можно свести к нему и к нему обратиться. 

\begin{theorem}
$L \in \Sigma^{k}P \Lra \exists$ полиномиально ограниченное отношение 
$R \in \Pi^{k - 1}P$ такое,что $\forall x (x \in L \Lra \exists y R(x, y))$
\end{theorem}
\begin{proof}
\begin{description}
\item[$\La$] L распазнается следующей машиной с оракулом $R:$
недетерменированно выбираем $y$ и проверяем $R(x, y)$.
\item[$\Ra$] Индукция. 
    \begin{description}
    \item[База:]
    $\Sigma^1 P = NP$ это определение класса $NP$.
    \item[Переход:] 
    Для $k - 1$ верно, доказываем для $k$.
    
    $L = L(M^O)$.
    По определению задается оракульной недетерменнированой 
    машиной $M$ с оракулом $O \in \Sigma^{k - 1}P$. По
    предположению индукции имеется полиномиально
    ограниченная $S \in \Pi^{k - 2}P$, такое что
    $\forall q(q \in O \Lra S(q, w))$.

    Строим R.

   $R(x, y) = 1$, если $y$ "--- принимающая ветвь вычисления
   $M^O$, но $Y$-ответы оракула снабжены сертификатами
   $w\colon S(q, w) = 1$.

  $R \in \Pi^{k - 1}P:$ детерменированно проверяем
  корректность $y$, затем комбинируем $\Pi^{k - 1}P$-вычисления,
  проверяющие $N$-ответы, и $\Pi^{k - 2}P$ вычисления, проверяющие
  сертификаты $Y$-ответов.  
    \end{description}
\end{description}
\end{proof}             

\begin{Def}
$QFB_k$ состоит из замкнутых истиных формул вида
$$\exists X_1 \forall X_2 \exists X_3 \cdots X_k \phi$$
где $\phi$ формула в КНФ или ДНФ, а $\{X_i\}_{i = 1}^{k}$ "---
разбиение множества переменных этой формулы на непустые непересекающиеся 
подмножества. 
\end{Def}
\begin{theorem}
$QBF_k$ "--- $\Sigma^kP$"---полные задачи. 
\end{theorem}
\begin{proof}
Нужно свести произвольный язык из $\Sigma^{k}P$ к $QBF_k$.\\ 
Что бы это доказать, нужно воспользоваться следствием и это 
уже почти доказательство. k квантеров у нас уже есть, но 
у нас после этих квантеров написано полиномиально проверяемое 
отношение, а мы бы хотели, что бы была записана булева формула.
Из отношения сделать булеву формулу мы можем с помощью теоремы 
Кука-Левина. 

$L \in \Sigma^{k}P \Lra \exists$ полиномиально ограниченые $R \in P$
такое, что $\forall x(x \in L \Lra \exists L \Lra \exists y_1 \forall y_2 \cdots R(x, y_1, \cdots, y_k))$
Считаем, что все $y_i$ полиномиально ограничены от $x$.

Если последний квантор "--- $\exists$, то запишем R в виде булевой формулы 
$\Phi$ как в теореме Кука-Левина: $R(z) \Lra \exists w \Phi(z,w)$\\
Итог: $\forall x(x \in L \Lra \exists y_1 \forall y_2 \cdots \exists w(\Phi(x, y_1, \cdots, w)))$.

Если последний квантор "--- $\forall$, то запишем $\bar R$ в виде булевой формулы 
$\Psi$ как в теореме Кука-Левина: $\bar R(z) \Lra \exists w \Pi(z,w)$\\
Итог: $\forall x(x \in L \Lra \exists y_1 \forall y_2 \cdots \forall w(\bar{\Psi}(x, y_1, \cdots, w)))$.

Здесь мы доказали, что задача $\Sigma^k$ трудная, но принадлежность 
$\Sigma^k$ очевидна. 
\end{proof}
\begin{theorem}
Если $\Sigma^k P = \Pi^k P \Ra PH = \Sigma^kP$, при
$k > 0$. 
\end{theorem}
\begin{proof}
При $k = 1$ все просто, значит $NP = coNP$, значит квантор
существования можно заменяить на квантр всобщности и все,
все кванторы сразу становятся одинаковыми.

Теперь на $k$-ом уровне более формально.
Достаточно показать, что k+1 уровень и k совпадают, то есть,
что $\Sigma^{k + 1}P = \Pi^kP$.

Пусть $L \in \Sigma^{k + 1}P$, то есть $L = \{x \colon \exists y R(x, y)\}$,
для $R \in \Pi^k P = \Sigma^k P$.

Значит, имеется $S \in \Pi^{k - 1}P$, такое что $R(x, y) \Lra \exists z S(x, y, z)$, то есть
$x \in L \Lra \exists y \exists z S(x,y, z)$, то есть $L \in \Sigma^{k}P$ 
\end{proof}
\begin{conseq}
Если существует $PH$-полная задача, то полиномиальная иерархия конечна. 
\end{conseq}
\begin{proof}
Так как $L$ лежит в конкретном $\Sigma^k P$.
\end{proof}
\section{Классы, ограниченные по времени и памяти}
\begin{Def}
$DTime[f(n)] = \{L| L\text{принимается ДМТ, работающей время O(f(n))}\}$\\
$f(n)$ должна быть неубывающей и вычислимой за время $O(f(n))$ по $1^n$.\\
\end{Def}
\begin{Rem}
$$P = \cup_{k \ge 0}DTime[n^k]$$
\end{Rem}
\begin{Def}
$DSpace[f(n)] = \{L|L\text{ принимается ДМТ с памятью O(f(n))}\}$.\\
$f(n)$ должна быть неубывающая и вычислимой с памятью $O(f(n))$ по $1^n$.
\end{Def}
\begin{Def}
$$PSPACE = \cup_{k \ge 0}DSpace[n^k]$$
\end{Def}
\begin{theorem}
QBF $PSPACE$-полная. 
\end{theorem}
\begin{proof}
$QBF \in  PSPACE$. 
С полиномиальной памятью мы умеем делать совершенно любой перебор. 
Так как длина сертифекатов полиномиальная. Можно перебрать и 
запустить $R$.\\                                
\\
Сводим $L \in PSPACE$ к $QBF$.\\
L задается какое-то машиной тьюринга с полиномиальной памятью.\\ 
Построим граф $2^{p(n)}$ конфигураций машины,
принимающей $L$. Решим задачу достижимости.

Строим $\phi_i(c_1, c_2) = $"существует путь из $c_1$ в $c_2$ длины $\le 2^i$"\\
$\phi_i(c_1, c_2) = \exists d \forall x \forall y(((x = c_1 \wedge y = d) \vee (x = d \wedge y = c_2)) \Ra \phi_{i - 1}(x, y))$\\
$\phi_0(c_1, c_2)$ записывается как в теореме Кука-Левина.  
\end{proof}
\begin{conseq}
Если $PH = PSPACE \Ra$ все сломается, значит
что в полиномиальной иерархии завелась полная задача. 
\end{conseq}