\section{PCP-теорема}  
\subsection{Вероятностно проверяемые доказательства}

Что такое класс PCP("Probabilistically Checkable Proof")? 
Наше определение класса NP можно записать как существует полиномиальная 
машина Тьюринга $V$(verifier), x - вход и далее выполняются следующие свойства:
	\begin{enumerate}
	\item $x \in L \Ra \exists \pi \colon V^{\pi}(x) = 1$
	\item $x \not \in L \Ra \forall \pi \colon V^{\pi}(x) = 0$	
	\end{enumerate}
Где $\pi$ "--- это сертификат.

В случае класса PCP у нас меняется несколько вещей, во-первых verifier
становится вероятностным, а во-вторных мы можем обращаться к любому биту
доказательству, не просматривая остальные. В случае PCP обращение к битам
доказательства - ограничено. Так же стоит учитывать, что адрес ячейки
имеет логарифмический размер от всего доказательства, значит в данном
случае полиномиальному V может потребовать экспоненциальное доказательство. 

Verifier может быть адаптивным и неадаптивным. Неадаптивный выбирает 
следующие место куда посмотреть основываясь только на входе и 
случайных битах, а адаптивный так же еще учитывает ранее считанные биты
доказательства.

Мы будем далее считать, что V неадаптивный. 

\begin{Def}
   Пусть у нас есть две функции $q, r \colon \N \to \N$. Мы говорим, 
   что язык L принадлежит $PCP(r(n), q(n))$, если существует такая 
   полиномиальная вероятностная машина V, что 
   \begin{description}
   \item[Эффективность:]
   	Для каждого входа $x \in \{0, 1\}^n$ и данного 
   	доказательства $\pi$. V использует на более $O(r(n))$
   	случайных бит и делает не более $O(q(n))$ запросов
   	к доказательству. 
   \item[Полнота:]
   	Если $x \in L$ тогда существует доказательство $\pi \in \{0, 1\}^n$, 
   	такое что $P[V^{\pi}(x) = 1] = 1$. Мы будем называть $\pi$ коррестным 
   	доказательством.
   \item[Проность:]
   	Если $x \not \in L$, тогда для любого доказательства $\pi \in \{0, 1\}^*, Pr[V^{\pi}(x) = 1] \le \frac{1}{2}$ 
   \end{description}
\end{Def}

\begin{theorem}
	$NP = PCP(O(\log n), O(1))$ 
\end{theorem} 

\subsection{Связь с неаппроксимируемостью}
PCP теоремя часто связана со многими NP оптимизационными задачами. 
И хорошо работает, в случа, когда надо выдавать ответ близкий к оптимальному. 
Прувер рисует доказательство. [.....] 
В каких местах мы хотим посмотреть. 

Рассмотрим на примере задачи MAX-3SAT. 
\begin{Def}
	MAX-3SAT "--- по данной формуле надо узнать максимальное 
	количество клозов, которые могут быть одновременно выполнены.
\end{Def}

Задача, естественно, NP-трудная.
\begin{proof}
	\begin{Def}
		Опеределим $val(\phi)$ "--- как доля клозов, которые 
		могут быть выполнены. То есть для выполнимой формулы $val(\phi) = 1$.
	\end{Def}
	\begin{Def}
	        Пусть $\rho \le 1$. Алгоритм A является $\rho$-апроксимируемым 
	        если для любой формула в 3КНФ с m клозами результат работы алгоритма A
	        не меньше, чем $\rho val(\phi)m$.
	\end{Def}

	Давай-те построим $\frac{1}{2}$ приблеженный алгоритм для $MAX-3SAT$.

	В данном алгоритме будем присваивать значения переменным поочереди. 
	Присваимваем значение и выбирае тот вариант переменной, когда выполнилось 
	больше клозов. После чего окончательно присваиваем это значение и забываем про 
	эту переменную и клозы, в которых она участовала. Более-менее понятно, 
	что при таком подходе хотя бы половина от максимального числа выполнится. 

	В целом, походими метадами можно добиться $\frac{7}{8}$ приближенный 
	алгоритм. 
\end{proof} 

Так же существует теорема, что если есть $\frac{7}{8} + \epsilon$ приближенное
решение, для любого $\epsilon > 0$, для $MAX-3SAT$, тогда $P = NP$.

PCP теорема часто может показывать для многих важных задач, что известный
алгоритм апроксимации является оптимальным.   



\begin{proof}
Строить будет система квадратичных уравнений по модулю два. 

$x \ne x'$\\
$\sum (x_i + x_i') r_i ?= 0$\\
$r_1 + \sum_{i \ge 2}(x_i + x_i') ?= 0$\\

$s[i]$\\
$f(y) = <x, y>$\\
$f^* -$ линейная\\
$\delta(f,f') \le \cdots$ \\
$f^*(y) = ?$\\
$f(y) + f(z) = f(y + z)$\\

Берем случайные y и z и тыкаем в три точки. 
        
      так вычисляем
$f^*(y) = f(r) + f(y + r)$
$<(u_iu_j), (a_{ij})>$

$<a_{ij}, u_iu_j > = \sum a_{ij}u_iu_j$\\

$f(r)f(r') ?= g(r \otimes r')$\\
$\sum_{i,j}u_iu_j r_ir_j' = (\sum_{i}u_ir_i)(\sum_{j}u_jr'_j) = \sum_{i,j}r_ir'_j$\\


        
 
\end{proof}




