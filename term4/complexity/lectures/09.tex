\section{PCP-теорема}  
\subsection{Вероятностно проверяемые доказательства}

Что такое класс PCP("Probabilistically Checkable Proof")? 
Наше определение класса NP можно записать как существует полиномиальная 
машина Тьюринга $V$(verifier), x - вход и далее выполняются следующие свойства:
	\begin{enumerate}
	\item $x \in L \Ra \exists \pi \colon V^{\pi}(x) = 1$
	\item $x \not \in L \Ra \forall \pi \colon V^{\pi}(x) = 0$	
	\end{enumerate}
Где $\pi$ "--- это сертификат.

В случае класса PCP у нас меняется несколько вещей, во-первых verifier
становится вероятностным, а во-вторных мы можем обращаться к любому биту
доказательству, не просматривая остальные. В случае PCP обращение к битам
доказательства - ограничено. Так же стоит учитывать, что адрес ячейки
имеет логарифмический размер от всего доказательства, значит в данном
случае полиномиальному V может потребовать экспоненциальное доказательство. 

Verifier может быть адаптивным и неадаптивным. Неадаптивный выбирает 
следующие место куда посмотреть основываясь только на входе и 
случайных битах, а адаптивный так же еще учитывает ранее считанные биты
доказательства.

Мы будем далее считать, что V неадаптивный. 

\begin{Def}
   Пусть у нас есть две функции $q, r \colon \N \to \N$. Мы говорим, 
   что язык L принадлежит $PCP(r(n), q(n))$, если существует такая 
   полиномиальная вероятностная машина V, что 
   \begin{description}
   \item[Эффективность:]
   	Для каждого входа $x \in \{0, 1\}^n$ и данного 
   	доказательства $\pi$. V использует на более $O(r(n))$
   	случайных бит и делает не более $O(q(n))$ запросов
   	к доказательству. 
   \item[Полнота:]
   	Если $x \in L$ тогда существует доказательство $\pi \in \{0, 1\}^n$, 
   	такое что $P[V^{\pi}(x) = 1] = 1$. Мы будем называть $\pi$ коррестным 
   	доказательством.
   \item[Проность:]
   	Если $x \not \in L$, тогда для любого доказательства $\pi \in \{0, 1\}^*, Pr[V^{\pi}(x) = 1] \le \frac{1}{2}$ 
   \end{description}
\end{Def}

\begin{theorem}
	$NP = PCP(O(\log n), O(1))$ 
\end{theorem} 

\subsection{Связь с неаппроксимируемостью}
PCP теоремя часто связана со многими NP оптимизационными задачами. 
И хорошо работает, в случа, когда надо выдавать ответ близкий к оптимальному. 
Прувер рисует доказательство. [.....] 
В каких местах мы хотим посмотреть. 

Рассмотрим на примере задачи MAX-3SAT. 
\begin{Def}
	MAX-3SAT "--- по данной формуле надо узнать максимальное 
	количество клозов, которые могут быть одновременно выполнены.
\end{Def}

Задача, естественно, NP-трудная.
\begin{proof}
	\begin{Def}
		Опеределим $val(\phi)$ "--- как доля клозов, которые 
		могут быть выполнены. То есть для выполнимой формулы $val(\phi) = 1$.
	\end{Def}
	\begin{Def}
	        Пусть $\rho \le 1$. Алгоритм A является $\rho$-апроксимируемым 
	        если для любой формула в 3КНФ с m клозами результат работы алгоритма A
	        не меньше, чем $\rho val(\phi)m$.
	\end{Def}

	Давай-те построим $\frac{1}{2}$ приблеженный алгоритм для $MAX-3SAT$.

	В данном алгоритме будем присваивать значения переменным поочереди. 
	Присваимваем значение и выбирае тот вариант переменной, когда выполнилось 
	больше клозов. После чего окончательно присваиваем это значение и забываем про 
	эту переменную и клозы, в которых она участовала. Более-менее понятно, 
	что при таком подходе хотя бы половина от максимального числа выполнится. 

	В целом, походими метадами можно добиться $\frac{7}{8}$ приближенный 
	алгоритм. 
\end{proof} 

Так же существует теорема, что если есть $\frac{7}{8} + \epsilon$ приближенное
решение, для любого $\epsilon > 0$, для $MAX-3SAT$, тогда $P = NP$.

PCP теорема часто может показывать для многих важных задач, что известный
алгоритм апроксимации является оптимальным.   

\subsection{Доказательство простой версии PCP-теоремы}
\subsubsection{Код Walsh-Hadamard}
Хочется предствлять строчку в некотором другом более длинном, 
но зато более удобном виде.

Вместо того что бы рассматривать битовою строчку мы будем
рассматривать табличку ее произведений на все другие битовые строчки.

Вместо строчку x P пишет длинную длинную строчку, в которой написаны все скалярные
произведения x на все возможные строчки анологичной длины.

То есть длина этого кода для строчки длины $n$ есть $2^n$.

Чем хорош этот код, так это то, что это код исправляющий ошибки. А именно.
Любые два кодовых слова находятся на расстояние по крайней мере $\frac12$ от общего
числа битов, в данном случае $2^{n - 1}$. Иначе говоря, если мы возьмем две разных
строчки $x \ne x'$ и ткнем в случаное место кода, то с вероятность хотя бы $\frac{1}{2}$
там окажутся разные биты.

Как в этом убедится? Вот у нас есть две разные строчки.\\  
$x \ne x'$\\

Мы записали два скалярных произведения, сразу перенесли все в одну час, + потому что по модулю два и 
хотим понять какая вероятность, что данное скалярное произведенеи окажется равно 0:
$\sum (x_i + x_i') r_i ?= 0$\\

Мы знаем, что среди $x_i + x_i'$ есть хотя бы одна 1, поскольку строчки не равны. 
Давай-те тогда эту 1 вынесем и напишем отдельно. Не умоляя общности первую. 

$r_1 + \sum_{i \ge 2}(x_i + x_i')r_i ?= 0$\\

Давай-те выберем сначала все остальные $r_i$ и получили какое-то конкретное 
значение второй части. После этого эта штука окажется 0, если мы умудрились тыкнуть $r_1$
ровно в это значение, а вероятность это сделать $\frac12$.\\ 

Нам P дал код Волше-Адомара, нам нужно убеждаться что это что-то, похожее на линейную
функции и значене этой линейной функции научиться считать. 

Нам дали некоторую функцию $s[i]$, которая должна была быть линейной. Потому что она должна была 
быть кодом Волше-Адомара некоторого вектора x. Нам должны были дать функцию $f(y) = <x, y>$.
Мы не знаем какое x, поэтому не можем убедится, что прям такое неравенство, но мы хатим хотя 
бы убедится, что для какого-то x так, ну или $f -$ линейная. Линейная же функция так и выглядит, 
есть какие-то коэффициенты. 

То есть мы хотим понять, что есть такая линейная функция $f^*$, которая похожа на функцию f. 
То есть расстояние между двумя функциями небольшое $\delta(f,f') \le \cdots$. Расстояние между 
двумя функциями "--- это вероятность того, что мы бурем случаную точки и значение 
функции там будет разное. 

Сначала, хотим убедится, что такая $f^*$ есть, а второе мы хотим научиться считать эту $f^*$ с какой-то разумной 
вероятностью.
$f^*(y) = ?$\\

Вероятность того, что мы правильно вычисли в значение y зависит от наших случайных бит, 
а нет от того, что написано в конкретной ячейке. Тыкать в те места, в которые хотим вычислить 
нельзя, нас могли именно там и обмануть. 

И мы знаем, что если нам дали функцию, похожую на линейную, то мы не станем 
вычислять другую функцию, поскольку две разных линейных функции 
много где отличаются.

Теперь, как мы это делаем.  

Будем брать две случайные точки y и z и проверять в них линейность $f(y) + f(z) = f(y + z)$.
То есть мы посмотрели в три места нашей таблицы. 

Нужно доказать, что это хорошоший тест на линейность, то есть если он прошел, 
то наша функция близка к линейной. Если f далека от линейной, то есть находится
на расстояние больше, чем $\delta$, то тест не будет пройден с вероятностью 
хотя бы $\frac{\delta}{2}$. Эту лемму мы докажем чуть больше.

После этого мы этот тест много раз повторим и после этого мы будем с очень хорошей
вероятнтью верить, что то, что у нас есть очень хорошая линейная функция.  
      
Вторая вещь - это вычислить $f^*$, мы будем вместо того, что 
бы вычислять в y будем вычислять: $f^*(y) = f(r) + f(y + r)$
вместо того, что бы брать $f(y)$. Иногда, конечно, может быть ошибка, но не 
если f линейна. r - берем случайным образом.

Что мы так хорошо вычислим $f^*$ мы тоже докажем отдельно.  

\subsubsection{Само доказательство}
\begin{theorem}
	$NP \subset PCP(poly(n), 1)$\\
\end{theorem}
\begin{proof}
	В нашем доказательстве мы решим NP-полную задачу с помощью $PCP(poly(n), 1)$.

	Язык, который мы будем использовать, это язык $QUADEQ$ "--- язык 
	систем квадратных уравнений над полем {0,1}.

	\begin{exmp}
		Пример слова из языка $QUADEQ$ :\\
		$u_1u_2 + u_3u_4 + u_1u_5 = 1$\\
		$u_2u_3 + u_1u_4 = 0$\\
		$u_1u_4 + u_3u_5 + u_3u_4 = 1$\\

		В данном примере решением являются все 1.
	\end{exmp}

	Теперь приступим к конструированию доказательства используя код Волше-Адомара.
	Прувер пытается нас убедить, что у этой системы есть некоторое решение U.

	Что бы доказать, что $QUADEQ$ NP-полный проще всего свести к этой задачи задачу о три-раскраске 
	графа.

	Просили прислать код Уолше-Адомара для решения $u_i$ и для вектора из $u_iu_j$. 

	Первым делом мы проверяем ту и другую табличку на линейность, тестом, который у нас был. 
	Сколько раз мы должны будем ткнуть в табличку? Тест на линейность требует ткнуть в табличку 3 раза. 
	Ну и нужно надо будет константное число раз повторить. 

	Надо проверить, что они к друг другу имееют отношения. Для этого надо взять случайные точки. То есть 
	взять случайные две точки из первой таблички, составить тензорное произведенеи и 
	ткнуть в соответствующую ячейку второй таблички. 

	Хотим в будующем понять, что  вероятностью $\frac14$  мы прувера за руку поймаем. 

	После проверки на линейность, мы обращаемся не к табличке а к линейной функции, которую получили. 

	Теперь проверим, что решение, которо нам дали удовлетворяет системе. Мы можем легко вычислеть
	значение одной строчки системы. $<(u_iu_j), (a_{ij})>$  можем взять сколярное произведение квадратичной формы 
	на строчку составленную из $u_iu_j$. Это будет $<a_{ij}, u_iu_j > = \sum a_{ij}u_iu_j$ значение 
	квадротичной формы. Проблема в том, что мы не можем такое сделать с каждой строчкой нашей системы. 

	Поэтому мы сделаем следущую хитрость, мы из нашей систему составим одно уравнение случайным образом. 
	Как это делается. Мы вычисляем сумму каких-то подстрочек нашей матрицы. То есть 
	каждую строчку берем или не берем с вероятностью $\frac{1}{2}$. И то же самое со свободным столбцом.

	В результате получаем ровно одну квадратичную форму и ровно одно для него значение. И эту форму
	мы уже сможем это проверить. Но все равно, мы к таблице обратимся константу раз.  
	Это был последний шаг, проверить, что все подходит. 

	Теперь вернемся к предыдущему шагу, проверке, что две строчки связаны между собой.  
	Мы утверждаем, что поймаем с вероятноть $\frac{1}{4}$. Что происходит, когда мы делаем
	этот тест. Мы проверяем, что $f(r)f(r') ?= g(r \otimes r')$. Оказалось, что g что-то не то. 
	Мы хотим это поймать. Это точно линейные функции. 
	
	Если мы две разные матрицы умножили на случайною строчку, то с вероятностью $\frac{1}{2}$
	мы получим разные вектора. Потом мы эти матрицы умножаем на случайный вектор справа, то 
	получим разное с вероятностью по карйней мере $\frac{1}{2}$. В итоге результат 
	будет разный с вероятностью хотя бы $\frac{1}{4}$.
	
	$\sum_{i,j}u_iu_j r_ir_j' = (\sum_{i}u_ir_i)(\sum_{j}u_jr'_j) = \sum_{i,j}r_ir'_j$\\

	Что бы улучшить вероятность нужно опять повторить все много раз. 

	В итоге мы в итоге все равно обращались константное число раз.

	Все это  в нашем рассуждение так, если не случилось не одной ошибки в вычисление нашей функции. 
	Но мы изначально сделаем так, что бы вероятность ошибки была маленькая. 

	Если хотите проконтроитровать все числа, то это хорошее упражнение на экзамен :)
	С точностью, до нескольких лемм доказали. 
\end{proof}                                      
