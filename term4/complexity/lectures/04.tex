\section{Оракулы для равенства и не равенства P и NP}
\begin{theorem} (Baker, Grill, Solovay)
	Существуют задачи $A, B$ такие, что
	\begin{enumerate}
	\item $P^{A} = NP^{A}$\\
	\item $P^{B} \ne NP^{B}$\\
	\end{enumerate}
\end{theorem}

\begin{proof}
\begin{enumerate}
\item 
	Рассмотрим $A = \{(M, x, 1^{n})| M(x) = 1 $ за $\le 2^n$ шагов $\}$
	Язык машин тьюринга, которые на входе x останавливаются меньше чем за $2^n$ шагов.

	Хотим доказать, что $P^A = EXP$ и $NP^A = EXP$.

	\begin{Def}
		$EXP = \cup_{p(n)}DTime(2^{p(n)})$
	\end{Def}

	Для $NP^{A}$ можем перебрать все подсказки, за полином проверять и каждый раз моделировать,
	все равно получится не более экспаненты, значит $NP^{A} \subset EXP$.

	EXP содержится в $P^A$, можем просто задавать вопросы оракулу. 

	Ну и тривиальное включение $P^A \subset NP^{A}$.

	Из этого следует, что $P^A = NP^{A}$\\
\item 
	Построим языки B и $U_B$.
	
	$U_{B}$ это такой унарный язык, проекция языка $B$. Если у нас есть слово длины n, 
	то в проекции есть слово из n палочек, а если нет, то нет.

	Каким бы не было $B$, $U_B$ принадлежит $NP^{B}$. Просим подсказку
	это слово такой же длины и спрашиваем у оракула, принадлежит ли это $B$.
	
	Перебираем все детерминированные оракульные машины $M_1, \cdots, M_n, \cdots $
	
	Запускаем машину $M_n(1^n)$ и в какой-то момент она спрашивает оракула. 
	
	Если мы уже добавили в слово в словарь, то говорим да, делать нечего. 
	Если еще не добавили, то говрим нет. 
	
	Ждем время $2^{\frac{n}{10}}$. Теперь смотрим, что она сказала. 
	
	Если она сказала да, то мы принимаем решение, что строчек такой длины в оракуле нет. 
	
	Теперь, если он сказал нет,то находим любую строчку, про которуе не знаем, что нет и отвечаем про нее да. 
	
	Если предыдущие машины спрашивали про строчки этой длины, то резерв-то все равно у нас останется, что бы выбрать строчку.  
\end{enumerate}
\end{proof}

\begin{Def}
	Relative это навешивание оракула. То есть когда факт не зависит от довешивания оракулов на машине. 
\end{Def}

\section{Полиномиальные схемы}
\begin{Def}
	$L \in Size[f(n)]$, если существует семейство булевых схем $\{C_n\}_{n \in \N}$, такие, что 
	\begin{enumerate}
	\item $\forall n |C_n| \le f(n)$\\
	\item $\forall x(x \in L \Lra C_{|x|}(x) = 1)$
\end{enumerate}
\end{Def}

\begin{Def}
	$P/poly = \cup_{k \in \N}Size[n^k]$
\end{Def}

\begin{Rem}
	$P \subset P/poly$\\
	Можем построить схему переходов конфигураций машины тьюринга. Она окажется полиномиального размера. 
\end{Rem}
\begin{Rem}
	Обратное включение не верно. Возьмем язык из n палочек, если $M_n$ останавливается, 
	то выдаем нет, если не останавливается, то да. Схема тривиально, это для данного $n$ просто константа. 
\end{Rem}

\begin{Rem}
	Если $L \in P/poly$ тогда $\exists G \colon 1^n \to C_n$, то язык принадлежит $P$. То есть существует Машина, 
	которая принимает на вход n 1 и выдает схему и язык принадлежит $P/poly$, тогда язык принадлежит P. 
\end{Rem}

\subsection{Теорема Карпа-Липтона}

Мы не умеем доказывать, что $NP = P$, но может мы можем доказать $NP \subset P/poly$. Конечно же нет...

\begin{theorem}
	$NP \subset P/poly \Ra PH = \Sigma^2P$\\
\end{theorem}
\begin{proof}
	Что бы доказать эту теорему покажем, что $\Sigma^3P$-полный язык $QBF_3$ лежит в $\Sigma^2P$.

	Дали значит нам схемы, и сказали, что они решают SAT. Нужно проверить, правда это или нет. 

	Проверки корректности схем для SAT:
	$C_{|G|}(G) = C_{|G[x_1 = 0]}(G[x_1:= 0]) \vee C_{|G[x_1 = 1]}(G[x_1 = 1])$ и проверка корректности для тривиальных схем.

	То есть формула выполнима,если выподнима она, когда вместо первой переменной подставили 0 или если она выполнима, когда вместо переменной 
	поставили бы 1. 

	Хотим формулы с тремя кванторами решить с использованием двух.
	
	$(\exists x \forall y \exists z (F)) \in QBF_3 \Lra
	\exists$ схемы $C_1, \cdots, C_{|F|} \exists x, \forall y$\\
	$\forall G$ - булевы формулы длины $\le |F|$\\
	(семейство $\{C_i\}$ корректно для $G$)$\wedge C_{|F|}(F(x,y,z)) = 1$

        То есть у нас есть формула с тремя кванторами, хотим записать ее с двумя. 
        Говорим, что это то же самое, что у нас существуют схемы, существует x, 
        что для любого y, любая булева формула является корректной для этого семейства схем и 
        формула F является выполнимой. 
\end{proof}

\subsection{Схемовая сложность $Sigma_2$}
\begin{theorem}
	Существует булева функция $\{0, 1\}^{n} \to \{0, 1\}$, 
	которая не вычисляется ни одной схемой размера $\frac{2^n}{10n}$
\end{theorem}

\begin{proof}
	Схемы размера $T(n)$ можно задать с помощью не более
	чем $4T(n) \log T(n)$  битов. Каждая вершинка кодируется
	своим номером. операцией и номерами вершин из которой ребра ведут в эту. 

	Значит, схем размера $\frac{2^{n}}{10n}$ менее, чем $2^{2^{\frac{n}{2}}}$, 
	а всего различных булевых формул $2^{2^n}$
\end{proof}


\begin{theorem}
	$\forall k \colon PH \ne \subset Size[n^k]$\\
\end{theorem}
\begin{proof}
	Из предыдущей теоремы следует, что булевых функций схемной
	сложности больше, чем $n^k$ можно найти среди функций 
	$\{0, 1\}^{(k + 1)\log n}\to \{0, 1\}$. То есть, существует 
	булева функция, зависящая только от первых $(k + 1)\log n$ 
	переменных, схемная сложность которой больше, чем $n^k$.

	Такую функцию можно задать в виде таблицы истиности размера $O(n^{k + 1})$.

	Зададим язык L, который будет на входах каждой длины будет 
	решаться самой первой функцией, зависящей только от первых $(k + 1)\log n$
	переменных, чья схемная сложность строго больше $n^k$.

	$x \in L \Lra \forall f(\forall C \colon |C| \le n^k \exists y \in \{0, 1\}^n C(x) \ne f(x)
	\wedge \forall g((g \le f) \to \exists C|C| \le n^k \forall y \in \{0, 1\}^n C(y) = g(y)) \to f(x) = 1)$.

	 В этой формуле f и g выбираются среди функций из $\{0, 1\}^n \to \{0, 1\}$, которые
	 зависят от первых $(k + 1)\log n$ битов, представляются эти 
	 функции с помощью таблицы истиности для первых $(k + 1)\log n$ переменных, 
	 сравниваются лексикографически.

	Таким образом, мы получили, что $L \in PH$.  
\end{proof}

\begin{conseq}
	$\forall k \Sigma^2 P \cap \Pi^2P \ne \subset Size[n^k]$
\end{conseq}
\begin{proof}
	$\Sigma^2P \cap \Pi^2P \subset Size[n^k] \Ra $\\
	$NP \subset \Sigma^2P \cap \Pi^2 \subset P/poly \Ra$\\
	$PH = \Sigma^2P \cap \Pi^2P \subset Size[n^k]$\\
	Противоречие с предыдущей теоремой. 
\end{proof}

\section{Теорема Савича}
\begin{theorem}
	Если s(n) "--- конструктивная по памяти, то 
	$NSpace[s(n)] \subset DTime[2^{O(s(n))}]$
\end{theorem}
\begin{proof}
	Пусть язык L решается НМТ M, которая использует $O(s(n))$ памяти. 
	Рассмотрим работу машины M на входе x. 

	Псевдоконфигурация машины "--- это положение головок на лентах 
	и содержимое всех лент без входной и текущее состояние. У машины 
	M на входе x длины n может буть не более $2^{cs(n)}$ различных
	конфигураций.  Можно рассматривать ориентированный граф конфигураций, 
	из конфигурации $K_1$ есть ребро в конфигурацию $K_2$, если машина 
	Тьюринга получившая на вход x может за один шаг попасть из $K_1$ в 
	$K_2$ за один шаг. Машина M принимает x, если существует путь из
	начальной конфигурации в принимающую. Принимающих конфигураций
	может быть несколько, но можно считать, что Машина перед окончанием работы
	стирает все с ленты. Для задачи достижимости в графе можно воспльзоваться,
	например, поиском в глубину. То есть детерменированно
	можн смоделировать работу машины M за время $2^{O(s(n))}$.
\end{proof}

\begin{theorem}
	Если $s(n)$ конструктивная по памяти, то 
	$NSpace[s(n)] \subset DSpace[s(n)^2]$
\end{theorem}
\begin{proof}
	Рассмотрим граф конфигураций. Описание каждой конфигурации использует
	$O(s(n))$ битов, поэтому мы можем перебрать все конфигурации используя
	$O(s(n))$ памяти.

	Достаточно доказать, что задачу достижимости в графе, в котором
	$n$ вершин можно решить с использованием $O(\log^2(n))$ памяти.
	Введем предикат $s(u, v, i)$, который истинен, если из вершины u
	существует путь в вершину v длины не более $2^i$. Чтобы выяснить, 
	можно ли попасть из начальной вершины a в конечную вершину b достаточно 
	вычислить предикат s(a, b, n). Что бы вычислить 
	$s(u, v,i)$ мы будем перебирать все z и делать два рекурсивных запуска:
	$s(u, z, i - 1)$ и $s(z, v, i - 1)$. Если найдется такая вершина z, что 
	оба запуска вернут 1, то 1, иначе 0. Теперь как правильно распределить 
	память, что бы было $(\log n)^2$ памяти. В начале ленты всегда написаны 
	аргументы, с которыми вычисляется придекат s. Когда алгоритм 
	перебирает z, то он переиспользует память, для двух рекурсивных 
	вызовов память так же переиспользуется. Глубина рекурсии $O(\log n)$, 
	каждый уровень рекурсии добавляет к используемой памяти $O(\log n)$ битов. 
	Итого используемой памяти $O((\log n)^2)$. 
\end{proof}