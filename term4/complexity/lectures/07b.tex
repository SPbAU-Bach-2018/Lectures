\chapter{Рандомизированные алгоритмы}

\section{Определения}
\TODO

Надо сказать, что константа $\frac 12$ тут выбрана произвольно, можно было взять любое число от $(0,1)$.
Причина следующая: если у нас есть алгоритм $A$, которые выдаёт ответ <<да>> с вероятностью $\sfrac 1 2$,
то мы можем его запустить $k$ раз и проверить, что хотя бы один раз был выдан ответ <<да>>.
Таким образом можно увеличить вероятность работы алгоритма произвольно.
Скажем, запустив алгоритм тысячу раз, получаем вероятность ошибки $\frac{1}{2^{1000}}$.

Теперь класс $BPP$ (Bounded Probability), позволяющий двухсторонние ошибки:
\begin{itemize}
	\item
		Если правильный ответ "--- <<нет>>, то у нас не больше $\sfrac 13$ подсказок, которые
		порождают ответ <<да>>.
	\item
		Если правильный ответ "--- <<да>>, то у нас не меньше $\sfrac 23$ подсказок, которые
		порождают ответ <<да>>.
\end{itemize}
Тут точность тоже можно повышать, но уже чуть хитрее.
Запускаем алгоритм $k$ раз и выбираем тот ответ, который чаще встречается.
Чтобы ответ был неверным, надо, чтобы мы хотя бы в $\sfrac k2$ запусков алгоритма ошиблись
(а вероятность ошибки "--- $\sfrac 13$).
Нам важно, чтобы вероятности выдачи правильного ответа в любом случае были различны (не обязательно $\sfrac 23$)
так как тогда мы можем взять что-то между этими вероятностями и взять его в качестве границы.

Дальше можно воспользоваться неравенством Чернова: введём последовательность $x_1, \dots, x_k$,
где $x_i$ "--- случайная величина <<алгоритм ответил неверно на $i$-м запуске>>.
Матожидание $x_i$ "--- $\sfrac 13$, матожидание суммы "--- $\sfrac{k}{3}$.
Нас интересует вероятность события $\sum x_i \ge\sfrac k 2$.
Подставив это всё дело в неравенство, можно получить, что вероятность ошибки после $k$ запусков
убывает экспоненциально по закону $e^{-ck}$, то есть ухудшив время лишь в константу раз,
мы получаем экспоненциальное увеличение вероятности.
Более того, можно запускать не константное число раз, а $Poly(n)$ раз (ухудшая время работы в полином),
получая вероятность порядка $\frac{1}{2^{Poly(n)}}$.

А теперь "--- класс $PP$, в нём вероятность ошибки уже никак не ограничена.
Не гарантируется, что вероятности ошибки в случае ответов <<да>> и <<нет>> отделены какой-то константой,
лишь гарантируется, что одна вероятность меньше $\sfrac 12$, другая "--- больше.
Например, с ростом входа они могут сходиться к $\sfrac 12$ (тем не менее, они не равны, так как
вероятности дискретны).
В целом мы всё еще можем решать задачи, но потребуется экспоненциальное число запусков, легче уж все подсказки
перебрать и посмотреть, чего больше.
Теоретически класс $PP$ полезен, но на практике пользы от него никакого.

\section{Пример задачи}
Пусть у нас есть некоторый полином от многих переменных над конечным полем, но записан он в каком-то странном виде.
Условно можно считать его <<чёрным ящиком>> (формально мы чёрные ящики не вводили).
Например, можно считать, что у нас полином задан либо формулой, либо схемой, либо чем-то таким,
что можно вычислить.
Вопрос: многочлен поточечно нулевой или нет?
Например, если научимся отвечать на этот вопрос, то сможем и проверять, равны ли два многочлена поточечно.

\begin{lemma}[Шварца-Циппеля (Schwartz-Zippel)]
	Пусть имеется какое-то подмножество $S$ поля $\F$ и ненулевой (хотя бы в одной точке) многочлен $Q$ степени не больше $d$.
	Тогда вероятность $Pr \{ Q(r_1, \dots, r_n) = 0 \}$ (где $r_i$ берутся равновероятно
	из множества $S$) не превышает $\frac{d}{|S|}$
\end{lemma}
\begin{proof}
	Докажем это индукцией по числу переменных.
	Переход: пусть у нас есть многочлен:
	\[
		Q(x_1, \dots, x_n) =
		x_1^k q_k(x_2, \dots, x_n) +
		x_1^{k-1} q_{k-1}(x_2, \dots, x_n) +
		x_1^{k-2} q_{k-2}(x_2, \dots, x_n) +
		\dots +
		x_1^0 q_0(x_2, \dots, x_n)
	\]
	Давайте сначал выберем значения для $x_2, \dots, x_n$ случайно, получим многочлен от переменной $x_1$.
	Рассмотрим его коэффициент при $x_1^k$, два случая:
	\begin{enumerate}
		\item
			Этот коэффициент оказался нулём, вероятность этого не больше $\frac{d-k}{|S|}$
			(так как степень $q_k$ не больше $d-k$ и у нас есть индукционное предположение).
			В таком случае потенциально весь многочлен $Q$ может оказаться нулём независимо от значения $x_1$.
		\item
			Этот коэффициент не ноль, тогда весь $Q$ занулится только если мы выберем правильный $x_1$,
			являющийся корнем $Q(x_1)$.
			Это произойдёт с вероятностью не больше $\frac{k}{|S|}$.
	\end{enumerate}
	Складываем вероятности двух событий, получаем $\frac{d}{|S|}$, что и надо.
\end{proof}

\section{Где живут классы}
$RP \subseteq NP$ из определения: $NP$ требует существования хотя бы одной подсказки, а $RP$ "--- большого количества.
Дальше докажем, что $BPP$ содержится в $\Sigma^2 \cap \Pi^2$.
Еще докажем, что $BPP \subseteq P/Poly$, то есть можно дерандомизировать алгоритм, получив
подсказку, которая зависит только от длины входа (но не от входа).

\begin{theorem}
	$BPP \subseteq P/Poly$
\end{theorem}
\begin{proof}
	Давайте назовём подсказку хорошей для входа $x$, если она не даёт ошибки.
	Мы можем считать, что подсказка хорошая с вероятностью $1 - \frac{1}{4^n}$
	(если это не так, надо повторить алгоритм несколько раз, см. выше).
	Давайте найдём подсказку, хорошую для всех входов размера $n$ и зашьём её в схему.

	Рассмотрим все входы.
	Для каждого входа не более $\frac{1}{4^n}$ подсказок на нём плохие, давайте их выкинем из рассмотрения.
	Суммарно выкинем не более $2^n \cdot \frac{1}{4^n}$ подсказок, то есть останется довольно много хороших.
	Возьмём любую из них и зашьём в схему, получим схему полиномиального размера, которая всегда
	работает правильно.
\end{proof}

\begin{theorem}
	$BPP \subseteq \Sigma^2P$
\end{theorem}
\begin{proof}
	Давайте построим формулу с двумя кванторами, которая выяснит, что множество подсказок, дающих
	ответ <<да>>, достаточно велико, отсюда сделаем вид, что ответ на исходную задачу "--- <<да>>.
	
	Так просто считать количество подсказок мы не умеем, поэтому давайте хитрить.
	Обозначим множество подсказок, дающих ответ <<да>>, за $A_x$.
	Мы хотим отличить ситуацию, в которой доля $A_x$ меньше $\frac{1}{2^{p(n)}}$ от ситуации,
	в которой доля $A_x$ больше $1-\frac{1}{2^{p(n)}}$.
	Отличать будем так (\TODO): попытаемся покрыть вообще все подсказки $k$ копиями множества $A_x$,
	где $k$ не очень большое.
	Удалось "--- значит, $A_x$ было большим.
	Копии будут определённые, вида $A_x \oplus t_i$ ($1 \le i \le k$).
\end{proof}
