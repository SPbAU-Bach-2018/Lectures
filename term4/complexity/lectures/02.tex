\section{Сводимости}
\subsection{Сводимость по Карпу}
Эта сводимость обычно имеется в виду в случае задач распознавания.
\begin{Def}
	Сведение по Карпу: 
	Язык $L_1$ сводится к языку $L_2$($L_1 \to L_2$) если, имеется полиномиально вычислимая f:
	$\forall x \colon x \in L_1 \Lra f(x) \in L_2$
\end{Def}

\begin{Rem}
	Мы не можем поменять местами ответ, то есть мы не можем сказать, что там где нет мы скажем да, а там где да сажем нет. 
	Это важно. Так как есть подсказка для второго языка, то эта же подсказка для первго языка, а подсказки у нас для "да".
\end{Rem}

\subsection{Сводимость по Левину}
Сводимость применяется в случае задач поиска. 
\begin{Def}
	Сведение задач по Левину:
	Задача $R_1$ сводится к задаче $R_2$($R_1 \to R_2$), если $\exists f, g, h \colon \forall x_1, y_1, y_2:$
	\begin{enumerate}
	\item $R_1(x_1, y_1) \Ra R_2(f(x_1), g((x_1, y_1)))$
   	\item $R_1(x_1, h((f(x_1), y_2))) \La R_2(f(x_1), y_2)$
    	\item $f$ и $h$ полиномиально вычислимы, а $g$ ограничена полиномом. 
	\end{enumerate}
\end{Def}
\begin{Rem}
	Функцию $g$ мы не собираемся запускать, но нам важно, что бы решение для второго случая 
	было полиномиально ограницено, если полиномиально ограничено в первом случае.  
\end{Rem}

Видимо, наше седение будет происходить следующим образом. Мы отображаем наше $x_1$ с помощью функции $f$, 
находим в $R_2$ нужные нам решения и отображаем их назад с помощью функции $h$.

\begin{Rem}
	Классы $P, NP, \tilde{P}, \tilde{NP}$ замкнуты относительно 
	этих сведений. 
\end{Rem}

\section{Полные задачи}	
\subsection{Определение полных задач}
\begin{Def}
	Задача A "--- трудная для класса C, $\forall B \in C \colon B \to A$.
	То есть любая задача из класса $C$ сводится к задаче $A$. 
\end{Def}

\begin{Def}
	Задача полная для класса C, если она трудная и принадлижит C.
\end{Def}

\begin{theorem}
	Если $A$ "--- NP-трудная и $A \in P$,
	то $P = NP$.
\end{theorem}
\begin{conseq}
	Если $A$ "--- NP-полная, то $A \in P \Lra P = NP$.
\end{conseq}

\subsection{Задача об ограниченной остановке}
\begin{Def}
	$1^t$ "--- обозначение для записи слова, состоящего из t единиц.
\end{Def}
\begin{Def}
	Задача об ограниченной остановке: 
	$\tilde{BH}(<M, x, 1^t>, w) =$ НМТ
	M с подсказкой w принимет вход $x$ за $\le t$ шагов.
\end{Def}
\begin{theorem}
	Задача об ограниченной остановке "--- $\tilde{NP}$-полная, 
	а соответствующей язык "--- NP-полный. 
\end{theorem}
\begin{Rem}
	Принадлежность $\tilde{NP}$ использует существование универсальной ДМТ, которая 
	может промоделировать вычисление ДМТ, описание которой дано ей на входе. Причем лишь с полиномиальным замедлением. 
\end{Rem}

\begin{proof}
	\begin{description}
	\item[NP-трудность]
	Есть фиксированная задача $L$ из класса $NP$, то есть есть соответствующая ей машины Тьюринга $M$, которая работает $p(n)$
	
	Воспользуемся сведением по Карпу. $f(x) = <M, x, 1^{p(|x|)}>)$.

	Давай-те убедимся, что это правильное сведение. Если у x существовала подсказка $w$, то и у новой машины
	эта же подсказка подходит и наоброт.

        Действительно, если в новом решение подошла подсказка $w$, значит для изначальной $M$ подходила подсказка $w$.
        Теперь, если у изначальной машины была подсказка $w'$ и слово принадлежало языку, то существовала подсказка,
        $w$, которую можно было получить за меньше, чем $p(n)$ шагов, значит уже это подсказка подойдет для $f(x)$.

        Функция $f$ является полиномиально вычислимой.
          
	\item[Принадлежность NP]
	Теперь, что бы удостоверится, что новая задача принадлежит $NP$, нужно значть, что 
	бывает универсальная детерминированная машина тьюринга, которая с неболее чем полиномиальным ухудшением 
	сможет промоделировать переданную машину тьюринга на t шагов. Пока в такую машину поверим, чуть поже будет рассказано,
	как именно ее построить.  
	\end{description}
\end{proof}

\subsection{$CIRCUIT\_SAT$}
\begin{Def}
	Булева схема это:
	\begin{enumerate}
	\item Ориентированный граф без циков.
	\item Бинарные (и унарные) операции над битами: $\wedge, \vee, \oplus$
	в вершинах графа
	\item Есть выделеные вершины, которые являются входом схемы. Вершины без входящих ребер.
	\item Есть выделенные вершины, которые являются выходом схемы.
	\end{enumerate} 
\end{Def}

\begin{Def}
	$CIRCUIT\_SAT = \{(C, x)|C \text{"--- схема}, С(x) = 1\}$\\
	То есть массовая задача для $CIRCUIT_SAT$ "--- это для данной схемы найти вход, на котором эта схема будет давать 1.

	В случае задачи распознавания, узнать, существует ли такой набор. 
\end{Def}

\begin{theorem}
	$CIRCUIT\_SAT$ "--- $NP$-полная задача. 
\end{theorem}
\begin{proof}
	\begin{description}
	\item[Принадлежность NP:]
		Если у нас есть схема и подсказка, то достаточно не сложно проверить результат за полином от размера схемы. 
		Можно, например, сделать топ сорт вершин и за квадрат последовательно вычислять значения в ячейках.
	\item[NP-трудность:]
		Что бы доказать $NP$-трудность, сведем уже известную нам $NP$-полную задачу $BH$ к нашей. 
		Тогда все задачи из $NP$ будут сводится к $BH$, $BH$ будет сводится к нам и как следствие все задачи из $NP$ 
		будут сводится к нам. 

		\begin{enumerate}
		\item 
			Каждый этаж схемы будет соответсовать конфигурация ДМТ.\\
			Конфигурацию шифруем как [состояние, положение головки, память до головки, символ под головкой, память после головки; так же для следующих лент]\\
		
		        Ну да, каждый символ алфавита шифруется каким-то количеством бит. 

		\item	Размер этажа можем ограничесть $const \cdot t$. Так как больше памяти, чем работает машина тьюринга мы не израсходуем.\\ 
		
		\item 
			Количество этажей схемы соответствует времени работы ДМТ. Каждый этаж конфигурация 
			на данном шаге выполнения ДМТ.
		\item 
			Переход между этажами реализует один шаг ДМТ\\
		\item 
			Вход схема "--- подсказка НМТ. \\
			Так, как схема строится для конкретной Машины тьюринга, входа и времени, то все остальное
			уже намертво вбито в нашу построенную схему.  

		\end{enumerate}

		Теперь подробнее разберем, как устроен переход между этажами. 

		Для этого научимся программировать с помощью схем несколько конструкций. 
		
		if x then y else z такую инструкцию можно записать, например в виде
		(x and y) | (not x and z)

		Понятно как проверить, что какой-то символ чему-то равен. Берем ячейки отвечающие за этот 
		символ и соответсвенно and. 

		Теперь хотим узнать, что будет в какой-то конкретной ячейке. 

		if (головка где-то недалеко)
			то что-то содержательное\\
		else
			оставляем символ таким же.\\ 
		
		Что-то содержательное - это много if. У нас будет отдельно в схеме хранится переходы по 
		состояниям. 

		if вида, если такое-то состояние и такие-то сиволы под головкой, то записать в данную ячейку то-то.

	        И в конце исправить положенеи головки. 

	        Получается не так мало if, но все равно константа, поэтому не так важно. 

	        Ячеек в схеме получается порядка $\Theta(|x|^2)$\\
	 
	        Можно уменьшить до $|x|log(|x|)$ с использованием oblivious универсальной машины тьюринга.
	        То есть если изначальная Машина Тьюринга была oblivious, то мы все сделали за линию, 
	        пересчитывая гейты только в окрестности головки и мы так могли бы сделать, так как все время знаем
	        положение головки в любой момент времени вне зависимости от входа. 
	\end{description}
\end{proof}

\subsection{3-SAT}
\begin{Def}
	$\tilde{3-SAT} = \{(F, A)|F \text{--- в 3-КНФ}, F(A) = 1\}$
	
	У нас есть формула в $3-$КНФ, хотим для нее найти выполняющий набор.

	В случае задач распознавания, узнать, существует ли выполняющий набор. 
\end{Def} 
\begin{theorem}
	$3-SAT$ "--- NP-полная задача.
\end{theorem}
\begin{proof}
	\begin{description}
	\item[Принадлежность NP:]
		Проверка выполняющего набора "--- не очень хитрое дело. Подставляем 0 и 1 и 
		дальше уже распарсить выражение, тем более в 3-КНФ - совсем просто. 
	\item[NP-трудность:]
		Сведем $CIRCUIT\_SAT$ к $3-SAT$. 
		
		Теперь как мы это будем делать:
		\begin{enumerate}
		\item Заведем для каждого гейта новую переменную.
		\item Теперь гейт выражает какую-то операцию $g(x, y)$. Для примера $\oplus$. 
		Тогда хотим выписать несколько клозов, которую этот гейт выразят. 

		Это мы сможем сделать не более чем за 8 клозов.
		\item 
		Склеим полученный результат. Напишем конъюнкцию всех этих дизъюнктов. 
		\item 
		Добавляем клоз, что на выходе получили 1. 
		\end{enumerate}
	\end{description}
\end{proof}
\begin{Rem}
	Это наиболее изестная $NP$-полная задача. 
\end{Rem}

\section{Универсальная машина тьюринга:}
\subsection{Универсальная машина тьюринга:}
\begin{Def}
	$U(M, x) = M(x)$ "--- универсальная машина тьринга.
	
	Тут мы говорим про ДМТ.
	Вход для универсальной ДМТ $U$ "--- пара из ДМТ и входа для неё "--- $(M, x)$.
	
	Выход у универсальной машины Тьюринга должен совпадать, с выходом машины, которую она моделирует.
\end{Def}

Интересно то, сколько шагов затратит $U$ на эмуляцию $M$, если $M$ работала за $t$ шагов.

\begin{Rem}
	Стоит помнить, что в универсальной машине фиксированное число лент, 
	число состояний и размер алфавита. 

	В Машине которую мы эмулируем все это может быть сильно больше. 
	
	Проблема с большим алфавитом в машине M лечится преобразованием машины $M$
	в машину $M'$, которая пользуется алфавитом $\{0, 1, \mathvisiblespace, \triangleright\}$ и кодирует каждый старый символ
	фиксированным числом бит.
	Замедление $M'$ по сравнению с $M$ будет лишь константное.
\end{Rem}
	
Если нам требуется моделировать только $M$ с ограниченным числом лент $\le k$, то
это легко делается машиной $U$ с $k+1$ лентой с константным замедлением (т.е. $U_M$ будет работать для конкретной $M$ за $\O(t)$).
На этой отдельной ленте мы храним описание $M$ и текущее состояние, а первые $k$ лент и позиции головок на них в точности соответствуют машине $M$.
Прочитали за не зависящее от $t$ время символы под головками, нашли нужный переход, перешли.

\begin{theorem}
	Существует такая универсальная машина тьюринга U, что для любого $x, \alpha \in \{0, 1\}^*$
	$U(x, \alpha) = M_{\alpha}(x)$, где $\alpha$ - описание Машины Тьюринга $M_{\alpha}$.

	Более того, если машина $M_{\alpha}$ на входе x делала t шагов, 
	то $U(x, \alpha)$ сделает не более $Ct\log t$, где $C$ не зависит от 
	x и зависит только от размера алфавита машины, числа лент и количества состояний. 
\end{theorem}
\begin{proof}
	\includegraphics[width=0.5\linewidth]{UTM.png}

	Наша машина тьюринга U будет иметь входную ленту для x и использовать ее так же, 
	как и наша прошлая машину. Ленту, где описана машина Тьюринга M и ленту, которая описывает
	текущее состояние машины тьюринга M, а так же выходная лента.

	Пусть k количество лент в машине Тьюринга M, и алфавит $\Sigma$, 
	тогда алфавит универсальной машины тьюринга будет порядка $\Sigma^{k}$ и 
	мы всегда умеем его сводить в алфавиту $\{0, 1\}$.\\

	Дальше мы сталкиваемся с проблемой, что машина M имела k движущихся головок, 
	а мы имеем только одну. 

	Здесь можно воспользоваться принципом "Если гора не идет к Мухамеду, то Мухамед идет к горе".

	То есть, вместо того, что бы двигать головку, будем считать, что головка
	всегда стоит на одном месте, а мы двигаем ленту. В силу нашего большого алфавита, 
	можем считать, что под головкой сразу много лент параллельно. 

	Например, если раньше было три ленты и головки сдвигались налево, направо и налево, 
	то теперь сдвигаются ленты направо, налево и направо. 

	Но с точки зрения машины за $T \log T$ это все не очень хорошо, 
	потому что при каждом сдвиге нам совсем все придется двигать, а такие
	большие передвижения уже будут работать за квадрат, что не очень хорошо. 

	Поэтому у нас есть план создать некоторый буфер свободного пространства, 
	что бы лентам не приходилось далеко двигаться, а они могли использовать буфер. 

	\includegraphics[width=0.5\linewidth]{UTM_buf.png}

	Теперь у ячеек будут слудующие номера $\cdots -3, -2, -1, 0, 1, 2, 3, \cdots$\\

	Теперь разделим все на блоки $L_0, R_0, L_1, R_1, \cdots$.
	$R_i$ содержит $2^i$ ячеек с номерами $[2^i \cdots 2^{i + 1} - 1]$
	А $L_i$ содержит $2^i$ ячеек с номерами $[-2^{i + 1} + 1 \cdots -2^i]$\\ 
	
	Головка находится вне блоков на позиции 0. 

	Далее будем подерживать следующие инварианты:
	\begin{enumerate}
	\item 
		Каждая зона либо пустая, либо полная, либо наполовину полная. 
	\item
		Количество элементов в зонах $L_i$ и $R_i$ суммарно $2^i$. 
	\item
		0 ячейка не содержит символов пропуска.  
        \end{enumerate}

        Давай-те теперь опишем, как машина будет делать левый сдвиг, из 
        этого все станет понятно. 

        \begin{enumerate}
        \item U находит минимальный i, такой что, блок $R_i$ не пустой. 
        Это же минимальный i, такой, что блок $L_i$ не полный. 
        \item U устанавливает первый не пустой символ в 0 позицию и 
        Сдвигаем оставшиеся $2^{i - 1} - 1$ элемент в рание блоки так, 
        что бы все блоки были заполнены наполовину. 

        Для этого как раз нужно $\sum_{j = 1}^{i - 1} 2^{j - 1} = 2^{i - 1} - 1$ элемент. 
        \item 
        Делаем симметричную операцию слева, что бы подержать инвариант. 
        То есть $2^{i - 1} - 1$ левых элементов сдвигаем в секцию $L_i$, 
        что бы в каждом блоке $L_0, \cdots L_{i - 1}$  осталось только половина 
        элементов. 
        \item
        Заметим, что инвариант не нарушен и зоны с номерами меньше i наполовину 
        полные.
        \end{enumerate}

        Что бы сделать одну такую операвцию требуется $O(2^i)$ действий. Но, 
        после этого что бы добраться до зоны i нам потребуется совершить $2^{i - 1}$ операций
        с более маленькими блоками как минимум. Нам нужно, что бы все элементы из 
        мелких блоков переехали в какую-то одну сторону. 

        То есть, если мы проделали T шагов,то обратимся к i-ому блоку мы $\frac{T}{2^{i - 1}}$ раз 
        максимум, значит время работы

        $O(sum_{i = 1}^{log t + 1}\frac{T}{2^{i - 1}}2^i) = O(t \log t)$
\end{proof}

\subsection{oblivious универсальная машина тьюринга}
\begin{Def}
	Oblivios машина тьюрига(пофигистическая)

	Положение головки на машине тьюринга не зависит от входа, а только от 
	текущего шага. 
\end{Def}
\begin{theorem}
	Машину построенную в пердыдущем разделе можно сделать пофигистичной. 
\end{theorem}
\begin{proof}
	Как-то получается так,что в ближайщем к выходу ячейке может нарушаться
	инвариант. В целом, идея по переделыванию такая. Мы знаем где максимум
	можем находиться в этот момент времени. Давай-те дойдем до предела на лева и
	до предела на права. Стырим символ только из нужного места. Просто немного больше
	прогуляемся. В конце ребалансировку сделаем того блока, который сейчас на очереде
	в любом случае. 	
\end{proof} 
