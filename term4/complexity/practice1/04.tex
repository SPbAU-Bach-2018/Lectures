\chapter{Занятие 02.03.2016}

К сожалению, Егора на занятии не было, поэтому записаны только разборы задач
со слов присутствующих.

\section{Разбор задач}
\problem{16}\label{prob16}
	На занятии разбирал Игорь Лабутин.
	Записано со слов Пети Смирнова и записей Лизы Третьяковой.

	\begin{assertion}
		$f(n)=n^{\log n}=e^{\log^2 n}$ асимптотически больше любого полинома ограниченной степени
		и асимптотически меньше любой экспоненты.
	\end{assertion}
	Давайте построим язык $L \in \EXP$.
	Строим машину Тьюринга, которая разрешает слово $n$ за экспоненциальное время:
	\begin{enumerate}
		\item
			Запускает универсальную машину Тьюринга на алгоритме с номером $n$ на входе $n$ в течение $f(|n|)$ шагов.
			Под алгоритмом подразумеваем машину Тьюринга, которая отвечает <<да/нет>> (либо принимает вход, либо не принимает).
		\item
			На предыдущем шаге мы узнали значение $x \coloneq \langle r \rangle(n)$.
			Если $x$ не определён (т.е. машина Тьюринга не завершилась), то считаем $n \notin L$.
		\item
			Если $x=0$, то считаем $n \in L$ (выдавая 1), иначе считаем $n \notin L$ (выдавая 0).
	\end{enumerate}
	Очевидно, что эта машина разрешает $L$ за не более чем экспоненциальное время.
	От противного покажем, что не существует машины $M$, которая бы разрешала $L$ за полиномиальное время.
	В самом деле, пусть машина $M$ разрешает $L$, причём тратит на это не более $P(|n|)$ шагов,
	где $P$ "--- полином фиксированной степени.
	Заметим, что у этой машины бесконечное число номеров: если мы допишем в машину лишнее недостижимое состояние,
	её свойства не поменяются.
	Пусть это номера $a_1, a_2, \dots$.
	Посмотрим на числа $L(a_1), L(a_2), \dots$.
	Заметим, что начиная с некоторого места при подсчёте соответствующего числа у нас внутренняя машина Тьюринга ($M$)
	обязательно завершила выполнение, так как $P(|n|)=o(f(|n|))$.
	Стало быть, начиная с некоторого места $L(a_i)=\lnot M(a_i)$ по построению языка $L$.
	С другой стороны, $L(a_i)=M(a_i)$, так как $M$ разрешает язык $L$.
	Противоречие.

\problem{17}
	На занятии разбирал Никита Подгузов.
	Записано со слов Пети Смирнова.

	\begin{Rem}
		$\Sigma_i^P$ и $\Sigma^i \P$ "--- две формы записи, обозначающие одно и то же.
		Аналогично с $\Pi^i \P$.
	\end{Rem}

	То, что $A$ сводится по Тьюрингу (оракульно) за полиномиальное время к $B$ в точности обозначает, что $A \in \P^B$.
	Заметим, что также $A \in \NP^B$, так как если мы разрешим машине работать недетерминированно, она не сломается
	(просто не будет использовать недетерминированность).
	Теперь еще расширим: $\NP^B \subseteq \NP^{\Sigma_i^P}$ (так как $B \in \Sigma_i^P$), мы просто добавили те языки, которые в качестве
	оракула требовали не язык $B$, а какой-то другой из $\Sigma_i^P$.

	Еще мы знаем, что если оракул заменить на оракула, выдающего противоположный ответ, то ничего не изменится
	(так как внешняя машина	может сама инвертировать ответ):
	\[ A \in \NP^{\Sigma_i^P} = \NP^{\co\Sigma_i^P} \]

	Осталось понять, что $\co\Sigma_i^P=\Pi_i^P$, тогда решим задачу, так как справа получим в точности определение $\Sigma_{i+1}^P$.
	\label{prob17_quantors}
	Это легко понять из записи с кванторами: если есть язык $L \in \co\Sigma_i^P$, то для него можно записать:
	\begin{gather*}
		R \in \P \\
		\begin{alignedat}{3}
		x \in L &\iff& \lnot (&\exists y_1 \forall y_2 \exists y_3 \dots \colon       & R(x, y_1, y_2, \dots)&) \quad \text{определение} \\
		x \in L &\iff&        &\forall y_1 \exists y_2 \forall y_3 \dots \colon \lnot & R(x, y_1, y_2, \dots)&
		\end{alignedat} \\
		(\lnot R) \in \P
	\end{gather*}
	Что и требовалось показать: любой язык из $\co\Sigma_i^P$ лежит в $\Pi_i^P$ (если читать выкладки сверху вниз) и наоборот (если читать снизу вверх).

\problem{18}
	На занятии разбирала Лиза Третьякова.
	Записано со слов Пети Смирнова.

	Мы знаем, что $\PH=\Sigma_0^P\cup\Sigma_1^P\cup\dots$.
	Давайте покажем, что для произвольного $k$ верно, что $\Sigma_k^P \subseteq \PSPACE$, тогда покажем, что требуется.
	Возьмём произвольную задачу $A \in \Sigma_k^P$.
	Мы знаем, что $A$ за полиномиальное время (и, соответственно, полиномиальную память) сводится к задаче $QBF_k$, так как она является $\Sigma_k^P$-полной.
	Также очевидно, что задача $QBF_k$ (выполнимость формулы, содержащей ровно $k$ чередований кванторов) тривиально сводится к задаче $QBF$
	(выполнимость формулы, содержащей конечное число чередований кванторов) "--- надо просто сконвертировать формулу из одного формата записи в другой (если они вообще различались).
	Но мы знаем, что $QBF$ является $\PSPACE$-полной, стало быть, $QBF \in \PSPACE$.
	Значит, исходная задача $A$ тоже лежит в $\PSPACE$, так как её можно за полиномиальную память свести к $QBF$, а потом "--- решить $QBF$.

	\begin{Rem}
		Можно еще говорить, что класс $\PSPACE$ (впрочем, как и классы $\Sigma_k^P$) замкнут относительно сведений за полиномиальное время:
		если была задача $X$, которую мы за полиномиальное время свели к задаче $Y\in \PSPACE$, то $X \in \PSPACE$, сверху мы просто
		передоказали это еще раз.
	\end{Rem}

\problem{19}
	На занятии разбирал Петя Смирнов, записано с его же слов.

	\begin{Rem}
		Для начала стоит понять, что обозначается записью $\PH^A$ "--- ведь в основании стоит на самом деле не класс задач, а некоторая
		модель вычислений, которой можно добавлять оракула.
		Понимать следует так:
		\begin{align*}
			\PH &= \Sigma_0^P \cup \Sigma_1^P \cup \dots \\
			\Sigma_k^P &= \NP^{\Pi_{i-1}^P} \\
			\Sigma_k^P
				&= \NP^{\co\NP^{\NP^{\dots^{\Sigma_0^P}}}} \\
				&= \NP^{\co\NP^{\NP^{\dots^{\P}}}} \\
			\left(\Sigma_k^P\right)^A
				&= \NP^{\co\NP^{\NP^{\dots^{\P^A}}}}
		\end{align*}
		То есть мы отдельно добавляем оракула в каждый из классов $\Sigma_k^P$, а при добавлении в класс мы пишем не
		что-то вроде $\NP^{\{A\}\cup \Pi_{i-1}^P}$, а добавляем оракула в самый внутренний уровень.
		Если писать с кванторами, то мы просто разрешаем самому внутреннему отношению $R$ лежать не в $\P$, а в $\P^A$.
	\end{Rem}

	Давайте теперь индукцией по $i$ покажем, что $\left(\Sigma_k^P\right)^A = \P^A$, тогда мы докажем и $\PH^A=\P^A$.
	База при $i=0$ очевидна, так как слева стоит просто $\P^A$.
	Теперь переход: пусть мы доказываем утверждение для $\left(\Sigma_k^P\right)^A$.
	\begin{Rem}
		Дальше важно работать именно с $\left(\Sigma_k^P\right)^A$, а не просто с $\Sigma_k^P$, потому что
		даже если есть два равных класса задач $X$ и $Y$, то необязательно, что $X^A=Y^A$.
		Это, опять же, происходит из-за того, что мы используем не класс задач, а модель вычислений, в которой он определяется.
		Если модели вычислений разные, может случиться проблема.
		\TODO привести пример
	\end{Rem}
	Будем делать несколько аккуратных формальных преобразований по шагам.
	\begin{enumerate}
		\item
			Запишем определение: $\Sigma_k^P = \NP^{\Pi_{k-1}^P}$
		\item
			Вспомним, что у нас есть оракул, и что он лежит <<внутри>>: $\left(\Sigma_k^P\right)^A = \NP^{\left(\Pi_{k-1}^P\right)^A}$
		\item
			Ответы оракула можно инвертировать: $\left(\Sigma_k^P\right)^A = \NP^{\co\left(\Pi_{k-1}^P\right)^A}$
		\item
			\begin{lemma}
				\[ \co\left(\Pi_{k-1}^P\right)^A = \left(\Sigma_{k-1}^P\right)^A \]
			\end{lemma}
			\begin{proof}
				Аналогично \hyperref[prob17_quantors]{доказательству в задаче 17}.
				Возьмём произвольную задачу $L$ из $\co\left(\Pi_{k-1}^P\right)^A$, для неё по определнию есть некоторое отношение $R \in \P^A$ такое, что:
				\begin{alignat*}{3}
					x \in L &\iff& \lnot(&\forall y_1 \exists y_2 \forall y_3 \dots \colon &      R(x, y_1, y_2, \dots)&) \\
					x \in L &\iff&       &\exists y_1 \forall y_2 \exists y_3 \dots \colon &\lnot R(x, y_1, y_2, \dots)&
				\end{alignat*}
				Заметим, что $(\lnot R) \in \P^A$, стало быть, по определению задача $L$ лежит в классе $\left(\Sigma_{k-1}^P\right)^A$.
			\end{proof}
			Теперь можем заменить класс в оракуле: $\left(\Sigma_k^P\right)^A = \NP^{\left(\Sigma_{k-1}^P\right)^A}$.
		\item
			А теперь пользуемся индукционным предположением (мы можем это делать, так как наверху стоят действительно классы задач):
			$\left(\Sigma_k^P\right)^A = \NP^{\P^A}$
		\item
			А теперь поймём, что $\NP^{\P^A}=\NP^A$.
			В самом деле: пусть есть задача $L\in \NP^{\P^A}$ и алгоритм $T$ для неё, который использует в качестве оракула решатель $T'$ некоторой задачи $L'\in \P^A$.
			Соответственно, решатель $T'$ использует в качестве оракула решатель $T''$ задачи $A$.
			Давайте теперь переделаем алгоритм $T$: теперь вместо вызова оракула $T'$, он будет явно запускать все те действия, которые бы сделал $T'$,
			в частности, обращаться к решателю $T''$.
			Получим, что теперь у нас обращение к оракулу для $L'$ занимает не один шаг, а какой-то полином, ничего страшного.
			Получили недетерминированный алгоритм для решения $L$, использующий лишь оракул для задачи $A$, что и требовалось.
		\item
			Последний шаг: по условию задачи $\P^A=\NP^A$, стало быть, $\left(\Sigma_k^P\right)^A = \P^A$, что и требовалось доказать.
	\end{enumerate}

\problem{22}
	Была разобрана на лекции.
	\TODO
