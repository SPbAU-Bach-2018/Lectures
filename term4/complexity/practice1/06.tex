\chapter{Занятие 16.03.2016}

\section{Вопросы}
\subsection{Определение полиномиальной иерархии}
	Вот у нас есть класс $NP$, он как-то связан с квантором <<существует>> (подсказка).
	А класс $coNP$, соответственно "--- с квантором <<для всех>>.

	Определяем $\Sigma_1=NP$, $\Pi_1=coNP$.
	А дальше так:
	$\Sigma_i = NP^{\Sigma_{i-1}} = NP^{\Pi_{i-1}}$.
	$\Pi_i = coNP^{\Sigma_{i-1}} = co\Sigma_i$.
	Наблюдение: всё равно, как определять $\Pi_i$, так как два выражения справа эквивалентны.
	\TODO

	Физический смысл: довольно часто удобно работать с оракульным определенияем,

\section{Разбор задач}
\subsection{Задача 21}
	\subsubsection{Пример неверного решения от семинариста}
		Задача: найти ошибку.

		Пусть мы научились быстро решать задачи из $NP$:
		\[ NP \subseteq DTime[n^{\log n}] \]
		Давайте теперь научимся быстро решать задачи из полиномиальной иерархии.
		Будем доказывать, что $\Sigma_i \subset DTime[n^{\log^{2i} n}]$ индукцией по $i$.
		Для $i \le 1$ база есть.
		Теперь переход.
		По определению мы знаем, что $\Sigma_i = NP^{\Sigma_{2i-2}}$ (\TODO проверить двойку и вычисления дальше),
		отсюда по индукционному предположению $\Sigma_i \subset NP^{DTime[n^{\log^{2i-2} n}]}$.
		Теперь по условию задачи заменяем $NP$ на больший класс, получаем:
		\begin{align*}
			\Sigma_i &\subset \left(DTime[n^{\log^n}]\right)^{DTime[n^{\log^{2i-2} n}]} \circleeq \\
				&\text{Теперь просто заменяем оракульный вызов на явное решение задачи} \\
				&\circleeq DTime[n^{\log n} \cdot \left(n^{\log n}\right)^{\log^{2i-2} \left( n^{\log n} \right)}] = \\
				&= DTime[n^{\log n} \cdot n^{\log n \cdot \log^{2i-2} \left( n^{\log n} \right)}] = \\
				&= DTime[n^{\log n} \cdot n^{\log n \cdot \left(\log^2 n\right)^{2i-2}}] = \\
		\end{align*}
		Что и требовалось доказать.

		\begin{Rem}
			В том месте, где мы заменяем класс внизу на больший, мы делаешь формальную чушь.
			На самом же деле в выражении $A^B$ только $B$ действительно является классом задач
			(которые умеет решать оракул).
			А вот $A$ "--- это не класс языков, а некое описание модели вычислений с оракулом,
			которая используется в \textit{определении} класса $A$.
			Например, в случае $A=NP$ это недетерминированная машина Тьюринга, работающая полиномиальное время.

			По этому поводу переход от $NP$ к $DTime$ был неочевиден (и в целом непонятный): $NP$
			использует НМТ с полиномиальным временм, а $DTime$ "--- ДМТ с полиномиальным временем.
		\end{Rem}

	\subsubsection{Правильное решение}
		Разбирал Дима Розплохас.

		Перепишем условие:
		\[ NP \subset DTime[2^{\log^2 n}] \]
		Чтобы решить задачу, хотим показать по индукции следующее:
		\[ \forall k \ge 1 \colon \Sigma_i \subset DTime[2^{\log^{2^k} n}] \]
		База индукции при $k=1$ нам дана по условию.
		Теперь переход от $k$ к $k+1$.
		Мы знаем, что $\Sigma_k \subset DTime[2^{\log^{2^k}} n]$.
		Отсюда знаем, что $\Pi_k$ тоже вложено в это $DTime$
		(так как если $\Sigma_k$ лежало, то можно взять машину для него и заставить её инвертировать ответ).

		Возьмём какой-нибудь язык $L \in \Sigma_{k+1}$ и покажем, что оно лежит в нужном $DTime$.
		По одному из определений $\Sigma_{k+1}$ знаем, что есть полиномиально ограниченное отношение
		$R \in \Sigma_k$ такое, что:
		\begin{gather*}
			x \in L \iff \exists \colon y (x, y) \in R
		\end{gather*}
		Зафиксируем это $R$.
		Теперь нам построим вот такой язык $L'$ по языку $L$ (примерно как в решении
		\hyperref[prob13_sol2]{с раздуванием единичек в задаче 13}, просто дописали кучу единиц к
		каждому слову из $L$):
		\[
			L' = \{
				\t{1}^{2^{\log^{2^k} |x|}}
				\t{0x}
				\mid
				x \in L
			\}
		\]
		Докажем, что $L' \in NP = \Sigma_1 \subset DTime[2^{\log^2 n}]$ (последний переход по условию задачи).
		Построим алгоритм проверки слова $x'$ на НМТ с подсказкой $y$, он должен работать за полином
		от длины $x'$:
		\begin{enumerate}
			\item Сначала проверим, что $x'$ имеет вид $\t{1^\alpha 0 x}$, это просто и детерминированно.
			\item Потом убедимся, что $\alpha = 2^{\log^{2^k} |x|}$, это тоже просто.
			\item
				Вычисляем $R(x, y)$ на ДМТ и возвращаем результат.
				Мы знаем, что $R \in \Sigma_k$ и по индукционному предположению это произойдёт за время $\O(\log^{2^k} |x|)$.
				А это время "--- полином от длины $x'$, что и требовалось доказать.
		\end{enumerate}

		Теперь, наконец, научимся проверять $x \in L$ за $DTime[2^{\log^{k+1} n}]$.
		Наш алгоритм берёт слово $x$, дописывает к нему кучу единиц за время $\O(2^{\log^{2^k} |x|})$,
		а потом запускаем на результате проверяющий алгоритм для $L'$.
		Проверяющий алгоритм получит вход длины $\O(2^{\log^{2^k} |x|})$, а работает
		за $\O(2^{\log^2 n})$.
		Если раскрыть, то он работает:
		\[
			\O\left(2^{\log^2 \left(C \cdot 2^{\log^{2^k} |x|}\right) }\right) =
			\O\left(2^{\left(\log C + \log^{2^k} |x|\right)^2}\right) =
			\O\left(2^{\left(C \cdot \log^{2^k} |x|\right)^2}\right) =
			\O\left(2^{C^2 \cdot \log^{2^{k+1}}}\right)
		\]
		Что и требовалось доказать
		\TODO проверить счёт, аккуратно с ошками

	\subsubsection{Правильное решение от семинариста}
		Починим старое решение.
		Будем доказывать, что $\Sigma_i \subset DTime[n^{\log^{2^i} n}]$ индукцией по $i$.
		Для $i \le 1$ база всё так же есть.
		В переходе дойдём до
		\[ \Sigma_i \subset NP^{DTime[n^{\log^{2^{i-1}} n}]} \]
		Возьмём какой-нибудь язык $L\in\Sigma_i$, его можно разрешать на НМТ
		с оракулом для некоторого языка $A \in DTime[n^{\log^{2^{i-1}} n}]$.
		Давайте добьём единичками язык $A'$ так, чтобы он попал в $P$.
		Тогда давайте еще раздуем $L$ до $L'$, чтобы успевать делать запросы к оракулу
		для языка $A'$.
		Тогда $L' \subset NP^{A'} \subset NP^P$.
		А так как запросов полином и каждый раз оракул работает за полином, то $L' \subset NP \subset DTime[n^{\log n}]$.
		Оценим время аккуратнее: у нас было слово из $L$ длины $x$,
		мы его добили единичками до длины $2^{\log^{2^{i-1}} x} \eqcolon n$, а потом разрешили за полином от $n$:
		\begin{gather*}
			n = 2^{\log^{2^{i-1}} x} \\
			\log n = \log^{2^{i-1}} x \\
			\log^2 n = \log^{2^i} x \\
			n^{\log n} = 2^{\log^2n} = 2^{\log^{2^i} x}
		\end{gather*}
		Что и требовалось.

\subsection{Задача 28}
	Эта задача отличается от задачи XXX тем, что тут нам нужен разрешимый язык.
	\subsubsection{Неверное решение}
		Разбирал Всеволод Степанов и повалился.

		Основная идея та же: возьмём язык $\{1^n \mid n \in W\}$, тогда схемы все будут размера $\O(1)$,
		а никакая машина Тьюринга не должна будет иметь разрешать $W$ за полиномиальное время.

		А теперь проблема: за полиномиальное \textit{от $n$} время (от размера входа),
		а не от $\log n$ (длины $n$).
		В частности, поэтому пример из задачи $P \neq EXP$ нам не подходит:
		там мы строили задачу с входом из числа $n$ (размера $\log n$) и показывали,
		что её нельзя разрешать за полиномомиальное от $\log n$ время.

	\subsubsection{Верное решение}
		Разбирала Оля Черникова.

		Давайте построим унарный язык.
		Слово длины $n$ будет (не)приниматься такой машиной за экспоненту:
		\begin{enumerate}
			\item
				Запускаем $\langle n \rangle (n)$ в течение $2^{\sfrac n 10}$ шагов.
			\item
				Если не завершилась, слово отвергаем, выдавая 0
			\item
				Если завершилась с единицей, выдаём ноль, иначе единицу.
		\end{enumerate}
		\TODO аккуратно дописать.

		\begin{Rem}
			\TODO Почему это отличается от решения: взяли язык $L \in EXP \setminus P$ и посмотрели на язык $\{1^n \mid n \in L\}$?
			Потому что честно расписали.
		\end{Rem}

	\subsubsection{Доделка неверного решения}
		Разбирал семинарист.
		Давайте возьмём $L \in DTime[2^{2^n}] \setminus DTime[2^{2^{\sfrac n2}}]$,
		такой есть по теореме с лекции о том, что если время работы отличается довольно
		сильно (кажется, чуть сильнее логарифма).
		Теперь возьмём его унарную версию: $L' = \{ 1^n \mid n \mid L\}$.
		Она нам подходит.

		От противного: пусть $L' \in P$.
		Тогда $L \in EXP$.
		Но это не так, так как $L \notin DTime[2^{2^{\sfrac n2}}] \supset DTime[2^n]$.
		\TODO

\subsection{Задача 29}
	Разбирал семинарист.
	От противного: пусть $NTime[n] = PSPACE$.
	Рассмотрим класс $NTime[n^2]$.
	Он, очевидно, лежит в $PSPACE$ (так как для перебора подсказки нам надо $n^2$
	памяти, время экспоненциальное, но неважно).
	Но тогда $NTime[n^2] \subset NTime[n]$.
	Противоречие с теоремой об иерархии классов.

\subsection{Задача 30}
	Разбирал семинарист.
	Пусть $DSpace[n] = NP$.
	Тогда возьмём язык $L \in DSpace[n^2]$.
	Построим язык $L' = \{ \t{x01^{|x|^2}} \mid x \in L \}$.
	Он, очевидно, лежит в $DSpace[n]$ (так как можно запустить алгоритм для $L$, откинув мусор).
	Значит $L' \in NP$.
	Значит, $L \in NP$, так как можно просто дописать полином единичек ко входу и запустить алгоритм для $L'$.
	Значит, $L \in DSpace[n]$, противоречие, так как мы знаем теорему об иерархии по памяти.

\subsection{Задача 20}
	Разбирал семинарист.
	Нужно взять правильные версии задач об ограниченной остановке.

	\subsubsection{EXP}
		\[ BH_{EXP} = \{ (M, x, t) \mid \text{ДМТ $M$ принимает $x$ за $t$ шагов} \} \]
		Любая задача из $EXP$ к этой сводится, так как для любой задачи есть машина $M$
		и некоторое ограничение сверху (экспоненциальное от $|x|$) на время работы.
		Давайте его посчитаем за экспоненту, получим что-то длины порядка $2^{|x|}$.
		Запустим машину $M$ в течение $2^{|x|} \eqcolon t$ шагов при помощи задачи $BH_{EXP}$,
		потратим на это $\O(t \cdot \log t)=\O(2^{|x|} \cdot |x|)$ времени, что всё еще лежит в EXP.

	\subsubsection{NEXP}
		Абсолютно то же самое, но машина теперь недетерминированная.

	\subsubsection{NE}
		Конструкция та же самая:
		\[ BH_{NE} = \{ (M, x, t) \mid \dots \]
		Всё еще никакие рассуждения не ломаются, надо чуть аккуратнее посмотреть, что при эмуляции
		машины мы не вылезем:
		\[ \O(t \cdot \log t) = \O(2^{cn} \cdot cn) = \O(2^{cn+\log c + \log n}) = \O(2^{c'n})\]

	\subsubsection{Альтернативные}
		Без доказательства, просто пример.

		NEXP-полная задача из жизни: пусть есть некоторая схема с большим количеством входов и выходов.
		Она задаёт какую-то булеву формулу в КНФ следующим образом: если подать схеме на вход число $n$,
		она выдаст клоз с номером $n$.
		Надо понять, разрешима ли формула.

		Для NE, кажется, пример тот же, но только у нас формулы из 3-КНФ, но это неточно.

\subsection{Задача 23}
	Разбирал семинарист.

	\subsubsection{а}
		Конфигураций у машины Тьюринга из $L$ всего полином от длины входа.
		Давайте мы её запустим, если конфигурация повторилась "--- какая-то фигня.
		А если не повторилась "--- мы сделали не более полинома шагов.

	\subsubsection{б}
		Надо заметить, что сведение из теоремы Кука-Левина на самом деле требует логарифмической памяти:
		там мы генерировали формулу по уровням, на каждом уровне было константное число гейтов,
		зависящих только от константного числа гейтов на предыдущем уровне.

\subsection{Задача 27}
	Разбирал семинарист.

	Занумеруем вообще все алгоритмы (каждый "--- бесконечное число раз): $M_1, M_2, \dots, M_k, \dots$.%, каждому сопоставим длину входа: $M_k \to k$.
	Теперь построим язык $L$: $x \in L$, если и только если машина $M_{|x|}$ на $x$ ответила 0 или не проработала
	больше $|x|^{2.1}$.
	Теперь предположим, что есть машина $M_k$, разрешающая $L$ за квадрат.
	Возьмём достаточно большой её номер $k$ так, чтобы она стала успевать отрабатывать на входах длины $k$.
	Тогда заметим, что она ошибётся вообще на всех входах длины $k$.

\section{Организационное}
	28 марта после пар "--- зачёт.
	Выдаются задачи из прошлых (и не только).
	Будут бонусы тем, кто много решал, о них мы когда-нибудь узнаем.
