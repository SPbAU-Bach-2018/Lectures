\chapter{Занятие 16.03.2016}

\section{Вопросы}
\subsection{Определение полиномиальной иерархии}
	Вот у нас есть класс $\NP$, он как-то связан с квантором <<существует>> (подсказка).
	А класс $\co\NP$, соответственно "--- с квантором <<для всех>>.

	Определяем $\Sigma_1=\NP$, $\Pi_1=\co\NP$.
	А дальше так:
	$\Sigma_i = \NP^{\Sigma_{i-1}} = \NP^{\Pi_{i-1}}$.
	$\Pi_i = (\co\NP)^{\Sigma_{i-1}} = \co\Sigma_i$.
	Наблюдение: всё равно, как определять $\Pi_i$, так как два выражения справа эквивалентны.

	Физический смысл: довольно часто удобно работать с оракульным определением/решением разных задач и
	по тому, насколько сильно задачи используют оракульность, их можно классифицировать.

\section{Разбор задач}
\problem{21}
	\subsubsection{Пример неверного решения от семинариста}
		Задача: найти ошибку.

		Пусть мы научились быстро решать задачи из $\NP$:
		\[ \NP \subset DTime\left[n^{\log n}\right] \]
		Давайте теперь научимся быстро решать задачи из полиномиальной иерархии.
		Будем доказывать индукцией по $i$ следующее:
		\[ \Sigma_i \subset DTime\left[n^{\log^{2i} n}\right] \]
		Для $i \le 1$ база есть.
		Теперь переход.
		По определению мы знаем, что $\Sigma_i = \NP^{\Sigma_{i-1}}$,
		отсюда по индукционному предположению пишем:
		\begin{gather*}
			\Sigma_i \subset \NP^{DTime\left[n^{\log^{2i-2}}\right]} \\
			\text{По условию задачи заменяем $\NP$ на больший класс, получаем:} \\
			\Sigma_i \subset \left(DTime\left[n^{\log^n}\right]\right)^{DTime\left[n^{\log^{2i-2}}\right]} \circleeq \\
			\text{Теперь просто заменяем оракульный вызов на явное решение задачи.} \\
			\begin{aligned}
				\circleeq &DTime[n^{\log n} \cdot \left(n^{\log n}\right)^{\log^{2i-2}}] = \\
				= &DTime[n^{\log n} \cdot \left(2^{\log^2 n}\right)^{\log^{2i-2}}] = \\
				= &DTime[n^{\log^{2i} n}]
			\end{aligned}
		\end{gather*}
		Что и требовалось доказать.

		В этом решении есть две большие проблемы:
		\begin{enumerate}
		\item
			В том месте, где мы заменяем класс внизу на больший, мы делаешь формальную чушь.
			На самом же деле в выражении $A^B$ только $B$ действительно является классом задач
			(которые умеет решать оракул).
			А вот $A$ "--- это не класс языков, а некое описание модели вычислений с оракулом,
			которая используется в \textit{определении} класса $A$.
			Например, в случае $A=\NP$ это недетерминированная машина Тьюринга, работающая полиномиальное время.

			По этому поводу переход от $\NP$ к $DTime$ был неочевиден (и в целом непонятный): $\NP$
			использует НМТ с полиномиальным временм, а $DTime$ "--- ДМТ с полиномиальным временем.
		\item
			Эта проблема на занятии, кажется, прошла незамеченной.
			Несмотря на то, что мы не забыли при замене оракульного вызова подставить в качестве $n$ для оракула
			размер его входа (который равен уже не $n$, а потенциально может разрастись до $n^{\log n}$), мы налажали в арифметике:
			\begin{align*}
				  &DTime[n^{\log n} \cdot n^{\log n \cdot \log^{2i-2} \left( n^{\log n} \right)}] =
				   DTime[n^{\log n} \cdot n^{\log n \cdot \log^{2i-2} \left( 2^{\log^2 n} \right)}] = \\
				= &DTime[n^{\log n} \cdot n^{\log n \cdot \left(\log^2 n\right)^{2i-2}}] =
				   DTime[n^{\log n} \cdot n^{\log n \cdot \log^{4i-4} n}] = \\
				= &DTime[n^{\log n} \cdot n^{\log^{4i-3} n}] =
				   DTime[n^{\log n + \log^{4i-3} n}]
			\end{align*}
			То есть разрастание степени логарифма тут получается экспоненциальное.
		\end{enumerate}

	\subsubsection{Правильное решение}
		Разбирал Дима Розплохас.

		Перепишем условие:
		\[ \NP \subset DTime\left[2^{\log^2 n}\right] \]
		Чтобы решить задачу, хотим показать по индукции следующее (как в предыдущем решении):
		\[ \forall k \ge 1 \colon \Sigma_i \subset DTime\left[2^{\log^{2^k} n}\right] \]
		База индукции при $k=1$ нам дана по условию.
		Теперь переход от $k$ к $k+1$.
		Мы знаем, что $\Sigma_k \subset DTime\left[2^{\log^{2^k}} n\right]$.
		Отсюда знаем, что $\Pi_k$ тоже вложено в это $DTime$
		(так как если $\Sigma_k$ лежало, то можно взять машину для него и заставить её инвертировать ответ).

		Возьмём какой-нибудь язык $L \in \Sigma_{k+1}$ и покажем, что оно лежит в нужном $DTime$.
		По одному из определений $\Sigma_{k+1}$ знаем, что есть полиномиально ограниченное отношение
		$R \in \Pi_k$ такое, что:
		\begin{gather*}
			x \in L \iff \exists y \colon (x, y) \in R
		\end{gather*}
		Зафиксируем это $R$.
		Теперь нам построим вот такой язык $L'$ по языку $L$ (примерно как в решении
		\hyperref[prob13_sol2]{с раздуванием единичек в задаче 13}, просто дописали кучу единиц к
		каждому слову из $L$):
		\[
			L' = \{
				\t{1}^{\left(2^{\log^{2^k} |x|}\right) - 1 - |x|}
				\t{0}
				x
				\mid
				x \in L
			\}
		\]
		Докажем, что $L' \in \NP$.
		Построим алгоритм проверки слова $x'$ на НМТ с подсказкой $y$, он должен работать за полином
		от длины $x'$:
		\begin{enumerate}
			\item Сначала проверим, что $x'$ имеет вид $\t{1}^\alpha \t{0}x$, это просто и детерминированно.
			\item Потом убедимся, что $\alpha = 2^{\log^{2^k} |x|} - 1 - |x|$, это тоже просто.
			\item
				Вычисляем $R(x, y)$ и возвращаем результат (тут нам никакой эмуляции и универсальной машины не надо "--- $R$ фиксировано).
				Мы знаем, что $R \in \Sigma_k$ и по индукционному предположению это произойдёт за время $\O(\log^{2^k} |x|)$.
				А это время "--- полином от длины $x'$ (которая равна в точности $\log^{2^k} |x|$), что и требовалось доказать.
		\end{enumerate}
		Теперь, так как $L' \in \NP$, то мы по условию задачи знаем:
		\[ L' \in \NP = \Sigma_1 \subset DTime\left[2^{\log^2 n}\right] \]
		То есть мы умеем проверять слово на принадлежность $L'$ за $\O\left(2^{\log^2n}\right)=C\cdot 2^{\log^2n}$ на \textit{детерминированной} машине Тьюринга.

		Теперь, наконец, научимся проверять $x \in L$ за $\O\left(2^{\log^{2^{k+1}} n}\right)$, закончив тем самым доказательство перехода.
		Наш алгоритм берёт слово $x$, дописывает к нему кучу единиц за время $\O\left(2^{\log^{2^k} |x|}\right)$,
		а потом запускаем на результате проверяющий алгоритм для $L'$.
		Проверяющий алгоритм для $L'$ получит вход длины \textit{в точности} $m \coloneq 2^{\log^{2^k} |x|}$, а работает
		за $C \cdot 2^{\log^2 m}$.
		\begin{Rem}
			Тут нам становится важно, что длина $x'$ в точности равна $m$.
			На занятии мы на это забили и сказали, что мы дописываем к $x$
			$2^{\log^{2^k} |x|}$ единичек, т.е. $x'$ получается на $|x|+1$ длиннее.
			К сожалению, тогда при аккуратном расписывании не сходится арифметика, причём больше, чем на константу:
			ведь нам надо получить именно $2^{\log^{2^{k+1}} |x|}$, а $2^{C\cdot \log^{2^{k+1}} |x|}$ нас уже не устроит.
		\end{Rem}
		Если подставить и раскрыть, то получаем время работы всего алгоритма (для языка $L$):
		\begin{gather*}
			\O(2^{\log^{2^k} |x|}) + C \cdot 2^{\log^2 \left(2^{\log^{2^k} |x|} \right)} =
			\O(2^{\log^{2^k} |x|}) + C \cdot 2^{\left(\log^{2^k} |x|\right)^2} = \\
			= \O(2^{\log^{2^k} |x|}) + C \cdot 2^{\log^{2^{k+1}} |x|} = \\
			\O(2^{\log^{2^{k+1}} |x|})
		\end{gather*}
		Что и требовалось доказать

	\subsubsection{Правильное решение от семинариста}
		Починим старое решение.
		На этот раз будем доказывать, что $\Sigma_i \subset DTime[2^{\log^{2^i} n}]$ индукцией по $i$ при $i\ge 1$.
		Для $i = 1$ база есть.
		В переходе дойдём до
		\[ \Sigma_i \subset \NP^{DTime[\underbrace{2^{\log^{2^{i-1}} n}}_{\eqcolon f(n)}]} \]
		Возьмём какой-нибудь язык $L\in\Sigma_i$, его можно разрешать за $P(n)$ на НМТ
		с оракулом для некоторого языка $A \in DTime[f(n)]$ (тут $P(n)$ "--- полином, можно оценить как $n^a$ для всех $n \ge 1$).
		Построим язык $A'$, раздув язык $A$ так, чтобы он попал в $P$:
		\[ A' = \{ \t{1}^{f(|x|)}\t{0}x \mid x \in A \} \]
		Теперь раздуем раздуем $L$ до $L'$, чтобы успевать делать запросы к оракулу для языка $A'$:
		\[
			L' = \{ \t{1}^{f(P(|x|))}\t{0} x \mid x \in L \}
		\]
		Тогда $L' \in \NP^{A'} \subset \NP^\P$.
		Но $\NP^\P=\NP$, так как запросов полином и каждый раз оракул работает за полином, можно его просто запускать.
		А теперь воспользуемся условием задачи:
		\[ L' \in \NP \subset DTime[n^{\log n}] \]
		Теперь можно построить алгоритм для разрешения языка $L$.
		У нас было слово из $L$ длины $k$, мы его должны добить $f(P(k))$ единичками до некоторой длины $n$, а потом разрешить за $\O(n^{\log n})$.
		\begin{gather*}
			\begin{aligned}
				n &= k + 1 + f(P(k)) \le k + 1 + f(k^a) \\
				n &\le k + 1 + 2^{\log^{2^{i-1}} k^a} \\
				n &\le k + 1 + 2^{\left(a \log k\right)^{2^{i-1}}} =
					k + 1 + 2^{a^{2^{i-1}} \log^{2^{i-1}} k} \\
				n &\le 2^{2a^{2^{i-1}} \log^{2^{i-1}} k} \\
				\log n &\le 2a^{2^{i-1}} \log^{2^{i-1}} k \\
				\log^2 n &\le 4a^{2^i} \log^{2^i} k \\
			\end{aligned} \\
			n^{\log n} = 2^{\log^2n} \le 2^{4a^{2^i} \log^{2^i} k}
		\end{gather*}
		\TODO

		Получилось почти то, что надо.
		В частности, если $a=1$, то мы доказали переход.
		На паре мы забили на аккуратность и арифметику, поэтому у нас получилось.

\problem{28}
	Эта задача отличается от \hyperref[prob25]{задачи 25} тем, что тут нам нужен разрешимый язык.
	\subsubsection{Неверное решение}
		Разбирал Всеволод Степанов и повалился.

		Основная идея та же: возьмём язык $L=\{1^n \mid n \in W\}$ (никакая машина Тьюринга не должна уметь разрешать $W$ за полиномиальное время),
		тогда все схемы будут размера $\O(1)$.

		А теперь проблема: МТ не должна работать за \textit{полиномиальное от $n$} время (от размера входа,
		т.е. от размера слова из $L$), а не от $\log n$ (длины $n$, слова из $W$).
		В частности, поэтому пример из задачи $\P \neq \EXP$ нам не подходит:
		там мы строили задачу с входом из числа $n$ (размера $\log n$) и показывали,
		что её нельзя разрешать за полиномомиальное от $\log n$ время.
		Но неочевидно, что её нельзя разрешить за полиномиальное от $n$ время.

	\subsubsection{Верное решение}
		Разбирала Оля Черникова.

		Давайте всё-таки построим унарный язык $L$ (следовательно, сразу лежащий в $P/poly$), но строить будем аккуратно.
		Примерно как в \hyperref[prob16]{задаче 16}.
		Слово длины $n$ будет распознаваться за экспоненту по следующему алгоритму:
		\begin{enumerate}
			\item
				Запускаем $\langle n \rangle (n)$ в течение $2^{\sfrac n {10}}$ шагов.
			\item
				Если не завершилась, слово отвергаем, выдавая 0
			\item
				Если завершилась с единицей, выдаём ноль, иначе единицу.
		\end{enumerate}
		Давайте теперь предположим, что есть машина $M$, которая разрешает $L$ за полиномиальное время $Poly(n)$ (тут $n$ "--- длина входа).
		Она встречается в списке машин бесконечное числа раз и, начиная с какого-то места,
		$Poly(n) < 2^{\sfrac n {10}}$, так что с некоторого места эта машина всегда будет успевать отработать.
		Но тогда на всех этих словах она будет выдавать неправильный ответ "--- мы-то вывод при построении $L$ инвертировали.
		Противоречие.

	\subsubsection{Доделка неверного решения}
		Разбирал семинарист.

		\begin{Rem}
			Брать произвольный язык из $L \in \EXP \setminus \P$ и строить по нему унарный
			нельзя "--- нам может попасться язык, который за $\O(Poly(|n|))$ не разрешается, а вот
			за $\O(2^{C\cdot|n|})=\O(Poly(n))$ разрешается.
			Хотя язык, который бы разрешался лишь за $\O(2^{|n|^2}) = \O(n^{\log n})$ нам подошёл, только где его взять?
		\end{Rem}

		Давайте возьмём $L \in DTime\left[2^{2^n}\right] \setminus DTime\left[2^{2^{\sfrac n2}}\right]$,
		такой есть по теореме с лекции о том, что если время работы отличается довольно
		сильно (кажется, чуть сильнее логарифма), то классы $DTime$ не равны.
		Теперь возьмём его унарную версию: $L' = \{ 1^n \mid n \in L\}$.
		Она нам подходит.

		От противного: пусть $L' \in \P$.
		Тогда $L \in \EXP$ (так как число $n$ длины $\log n$ можно разрешить за $Poly(n)=Poly(2^{\log n})=2^{C\cdot \log n}$).
		В частности, $L \in DTime\left[2^{Poly(n)}\right]$ для некоторого фиксированного полинома.
		Но $DTime\left[2^{Poly(n)}\right]~\subset~DTime\left[2^{2^{\sfrac n2}}\right]$ (так как экспонента больше любого полинома).
		Это противоречие "--- язык $L$ мы выбирали так, чтобы он там не лежал.

\problem{29}
	Разбирал семинарист.

	От противного: пусть $NTime[n] = \PSPACE$.
	Рассмотрим класс $NTime[n^2]$.
	Он, очевидно, лежит в $\PSPACE$ (так как для перебора подсказки нам надо $n^2$
	памяти, время экспоненциальное, но неважно).
	Но тогда $NTime[n^2] \subset NTime[n]$.
	Противоречие с теоремой об иерархии классов.

\problem{30}
	Разбирал семинарист.

	От противного: пусть $DSpace[n] = \NP$.
	Тогда возьмём язык $L \in DSpace[n^2]$.
	Построим язык $L' = \{ x\t{0}\t{1}^{|x|^2} \mid x \in L \}$.
	Он, очевидно, лежит в $DSpace[n]$ (так как можно запустить алгоритм для $L$, откинув мусор "--- для этого
	вообще только константа памяти нужна).
	Значит $L' \in \NP$.
	Значит $L \in \NP$, так как можно просто дописать полином единичек ко входу и запустить алгоритм для $L'$.
	Значит $L \in DSpace[n]$, противоречие, так как мы знаем теорему об иерархии по памяти.

\problem{20}
	Разбирал семинарист.

	Нужно взять правильные версии задач об ограниченной остановке.

	\subsubsection{EXP}
		\[ BH_{EXP} = \{ (M, x, t) \mid \text{ДМТ $M$ принимает $x$ за $t$ шагов} \} \]
		Эта задача лежит в $\EXP$: нам надо считать вход длины $k=\log x$ и проэмулировать
		$x$ шагов машины Тьюринга, это можно делать за $\O(x \cdot \log x)=\O(2{|x|}\cdot |x|)$, что лежит
		в $\EXP$.

		Любая задача из $\EXP$ к этой сводится, так как для любой задачи есть машина $M$
		и некоторое ограничение сверху (экспоненциальное от $|x|$) на время работы.
		Давайте его посчитаем, получим что-то длины порядка $2^{Poly(|x|)}$.
		Запустим машину $M$ в течение $2^{|x|}$ шагов при помощи задачи $BH_{EXP}$,
		получим ответ.

	\subsubsection{NEXP}
		Абсолютно то же самое, но машина теперь недетерминированная.

	\subsubsection{NE}
		Конструкция та же самая:
		\[ BH_{NE} = \{ (M, x, t) \mid \dots \} \]
		Всё еще никакие рассуждения не ломаются:
		\begin{itemize}
			\item Если была задача из $NE$, то она решалась за $2^{cn}$, а длина входа, которую мы должны посчитать и выдать задаче $BH_{NE}$ ровно такая
			\item Задача $BH_{NE}$ всё еще лежит в $NE$, потому что $t$ шагов мы эмулируем за следующее время:
				\[ \O(t \cdot \log t) = \O(2^{|t|} \cdot |t|) = \O(2^{|t|+\log |t|}) = \O(2^{2|t|}) \]
		\end{itemize}

	\subsubsection{Альтернативные}
		Без доказательства, просто пример.

		NEXP-полная задача из жизни: пусть есть некоторая схема с больш\'им количеством входов и выходов.
		Она задаёт какую-то булеву формулу в КНФ следующим образом: если подать схеме на вход число $n$,
		она выдаст клоз с номером $n$.
		Надо понять, разрешима ли формула.

		Для NE, кажется, пример тот же, но только у нас формулы из 3-КНФ, но это неточно.

\problem{23}
	Разбирал семинарист.

	\subsubsection{а}
		Конфигураций у машины Тьюринга из $\mathsf{L}$ всего полином от длины входа.
		Давайте мы её запустим, если конфигурация повторилась "--- какая-то фигня, машина зациклилась и не может являться разрешающей для некоторого языка.
		А если не повторилась "--- мы сделали не более полинома шагов.

	\subsubsection{б}
		Надо заметить, что сведение из теоремы Кука-Левина (которая про NP-полноту SAT) на самом деле требует логарифмической памяти:
		там мы генерировали формулу по уровням, на каждом уровне было константное число гейтов,
		зависящих только от константного числа гейтов на предыдущем уровне.
		Можем за логарифмическую память сгенерировать схему, за логарифмическую память решить её, а композиция МТ
		с логарифмической памятью тоже использует логарифм памяти.

\problem{27}
	Разбирал семинарист.

	Занумеруем вообще все алгоритмы (каждый "--- бесконечное число раз): $M_1, M_2, \dots, M_k, \dots$.
	Теперь построим язык $L$: $x \in L$, если и только если машина $M_{|x|}$ на $x$ ответила 0 или проработала
	больше $|x|^{2.1}$.
	Очевидно, что $L$ разрешается за $\O(n^3)$.
	\begin{Rem}
		Тут мы для слова $x$ запускаем машину $M_{|x|}$, а не $M_x$.
		А в целом конструкция опять похожа на \hyperref[prob16]{задачу 16} "--- та же диагонализация.
	\end{Rem}

	Теперь предположим, что есть машина $M_k$, разрешающая $L$ за квадрат.
	Возьмём достаточно большой её номер $k$ так, чтобы она стала успевать отрабатывать на входах длины $k$.
	Тогда заметим, что она ошибётся вообще на всех входах длины $k$.

\section{Организационное}
	28 марта после пар "--- зачёт.
	Выдаются задачи из прошлых (и не только).
	Будут бонусы тем, кто много решал, о них мы когда-нибудь узнаем.
