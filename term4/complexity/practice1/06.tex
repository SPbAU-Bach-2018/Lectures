\chapter{Занятие 16.03.2016}

\section{Вопросы}
\subsection{Определение полиномиальной иерархии}
	Вот у нас есть класс $\NP$, он как-то связан с квантором <<существует>> (подсказка).
	А класс $\co\NP$, соответственно "--- с квантором <<для всех>>.

	Определяем $\Sigma_1=\NP$, $\Pi_1=\co\NP$.
	А дальше так:
	$\Sigma_i = \NP^{\Sigma_{i-1}} = \NP^{\Pi_{i-1}}$.
	$\Pi_i = (\co\NP)^{\Sigma_{i-1}} = \co\Sigma_i$.
	Наблюдение: всё равно, как определять $\Pi_i$, так как два выражения справа эквивалентны.

	Физический смысл: довольно часто удобно работать с оракульным определением/решением разных задач и
	по тому, насколько сильно задачи используют оракульность, их можно классифицировать.

\section{Разбор задач}
\problem{21}
	\subsubsection{Пример неверного решения от семинариста}
		Задача: найти ошибку.

		Пусть мы научились быстро решать задачи из $\NP$:
		\[ \NP \subseteq DTime[n^{\log n}] \]
		Давайте теперь научимся быстро решать задачи из полиномиальной иерархии.
		Будем доказывать, что $\Sigma_i \subset DTime[n^{\log^{2i} n}]$ индукцией по $i$.
		Для $i \le 1$ база есть.
		Теперь переход.
		По определению мы знаем, что $\Sigma_i = \NP^{\Sigma_{2i-2}}$ (\TODO проверить двойку и вычисления дальше),
		отсюда по индукционному предположению $\Sigma_i \subset \NP^{DTime[n^{\log^{2i-2} n}]}$.
		Теперь по условию задачи заменяем $\NP$ на больший класс, получаем:
		\begin{align*}
			\Sigma_i &\subset \left(DTime[n^{\log^n}]\right)^{DTime[n^{\log^{2i-2} n}]} \circleeq \\
				&\text{Теперь просто заменяем оракульный вызов на явное решение задачи} \\
				&\circleeq DTime[n^{\log n} \cdot \left(n^{\log n}\right)^{\log^{2i-2} \left( n^{\log n} \right)}] = \\
				&= DTime[n^{\log n} \cdot n^{\log n \cdot \log^{2i-2} \left( n^{\log n} \right)}] = \\
				&= DTime[n^{\log n} \cdot n^{\log n \cdot \left(\log^2 n\right)^{2i-2}}] = \\
		\end{align*}
		Что и требовалось доказать.

		\begin{Rem}
			В том месте, где мы заменяем класс внизу на больший, мы делаешь формальную чушь.
			На самом же деле в выражении $A^B$ только $B$ действительно является классом задач
			(которые умеет решать оракул).
			А вот $A$ "--- это не класс языков, а некое описание модели вычислений с оракулом,
			которая используется в \textit{определении} класса $A$.
			Например, в случае $A=\NP$ это недетерминированная машина Тьюринга, работающая полиномиальное время.

			По этому поводу переход от $\NP$ к $DTime$ был неочевиден (и в целом непонятный): $\NP$
			использует НМТ с полиномиальным временм, а $DTime$ "--- ДМТ с полиномиальным временем.
		\end{Rem}

	\subsubsection{Правильное решение}
		Разбирал Дима Розплохас.

		Перепишем условие:
		\[ \NP \subset DTime[2^{\log^2 n}] \]
		Чтобы решить задачу, хотим показать по индукции следующее:
		\[ \forall k \ge 1 \colon \Sigma_i \subset DTime[2^{\log^{2^k} n}] \]
		База индукции при $k=1$ нам дана по условию.
		Теперь переход от $k$ к $k+1$.
		Мы знаем, что $\Sigma_k \subset DTime[2^{\log^{2^k}} n]$.
		Отсюда знаем, что $\Pi_k$ тоже вложено в это $DTime$
		(так как если $\Sigma_k$ лежало, то можно взять машину для него и заставить её инвертировать ответ).

		Возьмём какой-нибудь язык $L \in \Sigma_{k+1}$ и покажем, что оно лежит в нужном $DTime$.
		По одному из определений $\Sigma_{k+1}$ знаем, что есть полиномиально ограниченное отношение
		$R \in \Sigma_k$ такое, что:
		\begin{gather*}
			x \in L \iff \exists \colon y (x, y) \in R
		\end{gather*}
		Зафиксируем это $R$.
		Теперь нам построим вот такой язык $L'$ по языку $L$ (примерно как в решении
		\hyperref[prob13_sol2]{с раздуванием единичек в задаче 13}, просто дописали кучу единиц к
		каждому слову из $L$):
		\[
			L' = \{
				\t{1}^{2^{\log^{2^k} |x|}}
				\t{0x}
				\mid
				x \in L
			\}
		\]
		Докажем, что $L' \in \NP = \Sigma_1 \subset DTime[2^{\log^2 n}]$ (последний переход по условию задачи).
		Построим алгоритм проверки слова $x'$ на НМТ с подсказкой $y$, он должен работать за полином
		от длины $x'$:
		\begin{enumerate}
			\item Сначала проверим, что $x'$ имеет вид $\t{1^\alpha 0 x}$, это просто и детерминированно.
			\item Потом убедимся, что $\alpha = 2^{\log^{2^k} |x|}$, это тоже просто.
			\item
				Вычисляем $R(x, y)$ на ДМТ и возвращаем результат.
				Мы знаем, что $R \in \Sigma_k$ и по индукционному предположению это произойдёт за время $\O(\log^{2^k} |x|)$.
				А это время "--- полином от длины $x'$, что и требовалось доказать.
		\end{enumerate}

		Теперь, наконец, научимся проверять $x \in L$ за $DTime[2^{\log^{k+1} n}]$.
		Наш алгоритм берёт слово $x$, дописывает к нему кучу единиц за время $\O(2^{\log^{2^k} |x|})$,
		а потом запускаем на результате проверяющий алгоритм для $L'$.
		Проверяющий алгоритм получит вход длины $\O(2^{\log^{2^k} |x|})$, а работает
		за $\O(2^{\log^2 n})$.
		Если раскрыть, то он работает:
		\[
			\O\left(2^{\log^2 \left(C \cdot 2^{\log^{2^k} |x|}\right) }\right) =
			\O\left(2^{\left(\log C + \log^{2^k} |x|\right)^2}\right) =
			\O\left(2^{\left(C \cdot \log^{2^k} |x|\right)^2}\right) =
			\O\left(2^{C^2 \cdot \log^{2^{k+1}}}\right)
		\]
		Что и требовалось доказать
		\TODO проверить счёт, аккуратно с ошками

	\subsubsection{Правильное решение от семинариста}
		Починим старое решение.
		Будем доказывать, что $\Sigma_i \subset DTime[n^{\log^{2^i} n}]$ индукцией по $i$.
		Для $i \le 1$ база всё так же есть.
		В переходе дойдём до
		\[ \Sigma_i \subset \NP^{DTime[n^{\log^{2^{i-1}} n}]} \]
		Возьмём какой-нибудь язык $L\in\Sigma_i$, его можно разрешать на НМТ
		с оракулом для некоторого языка $A \in DTime[n^{\log^{2^{i-1}} n}]$.
		Давайте добьём единичками язык $A'$ так, чтобы он попал в $P$.
		Тогда давайте еще раздуем $L$ до $L'$, чтобы успевать делать запросы к оракулу
		для языка $A'$.
		Тогда $L' \subset \NP^{A'} \subset \NP^\P$.
		А так как запросов полином и каждый раз оракул работает за полином, то $L' \subset \NP \subset DTime[n^{\log n}]$.
		Оценим время аккуратнее: у нас было слово из $L$ длины $x$,
		мы его добили единичками до длины $2^{\log^{2^{i-1}} x} \eqcolon n$, а потом разрешили за полином от $n$:
		\begin{gather*}
			n = 2^{\log^{2^{i-1}} x} \\
			\log n = \log^{2^{i-1}} x \\
			\log^2 n = \log^{2^i} x \\
			n^{\log n} = 2^{\log^2n} = 2^{\log^{2^i} x}
		\end{gather*}
		Что и требовалось.

\problem{28}
	Эта задача отличается от \hyperref[prob25]{задачи 25} тем, что тут нам нужен разрешимый язык.
	\subsubsection{Неверное решение}
		Разбирал Всеволод Степанов и повалился.

		Основная идея та же: возьмём язык $L=\{1^n \mid n \in W\}$ (никакая машина Тьюринга не должна уметь разрешать $W$ за полиномиальное время),
		тогда все схемы будут размера $\O(1)$.

		А теперь проблема: МТ не должна работать за \textit{полиномиальное от $n$} время (от размера входа,
		т.е. от размера слова из $L$), а не от $\log n$ (длины $n$, слова из $W$).
		В частности, поэтому пример из задачи $\P \neq \EXP$ нам не подходит:
		там мы строили задачу с входом из числа $n$ (размера $\log n$) и показывали,
		что её нельзя разрешать за полиномомиальное от $\log n$ время.
		Но неочевидно, что её нельзя разрешить за полиномиальное от $n$ время.

	\subsubsection{Верное решение}
		Разбирала Оля Черникова.

		Давайте всё-таки построим унарный язык $L$ (следовательно, сразу лежащий в $P/poly$), но строить будем аккуратно.
		Примерно как в \hyperref[prob16]{задаче 16}.
		Слово длины $n$ будет распознаваться за экспоненту по следующему алгоритму:
		\begin{enumerate}
			\item
				Запускаем $\langle n \rangle (n)$ в течение $2^{\sfrac n {10}}$ шагов.
			\item
				Если не завершилась, слово отвергаем, выдавая 0
			\item
				Если завершилась с единицей, выдаём ноль, иначе единицу.
		\end{enumerate}
		Давайте теперь предположим, что есть машина $M$, которая разрешает $L$ за полиномиальное время $Poly(n)$ (тут $n$ "--- длина входа).
		Она встречается в списке машин бесконечное числа раз и, начиная с какого-то места,
		$Poly(n) < 2^{\sfrac n {10}}$, так что с некоторого места эта машина всегда будет успевать отработать.
		Но тогда на всех этих словах она будет выдавать неправильный ответ "--- мы-то вывод при построении $L$ инвертировали.
		Противоречие.

	\subsubsection{Доделка неверного решения}
		Разбирал семинарист.

		\begin{Rem}
			Брать произвольный язык из $L \in \EXP \setminus \P$ и строить по нему унарный
			нельзя "--- нам может попасться язык, который за $\O(Poly(|n|))$ не разрешается, а вот
			за $\O(2^{C\cdot|n|})=\O(Poly(n))$ разрешается.
			Хотя язык, который бы разрешался лишь за $\O(2^{|n|^2}) = \O(n^{\log n})$ нам подошёл, только где его взять?
		\end{Rem}

		Давайте возьмём $L \in DTime\left[2^{2^n}\right] \setminus DTime\left[2^{2^{\sfrac n2}}\right]$,
		такой есть по теореме с лекции о том, что если время работы отличается довольно
		сильно (кажется, чуть сильнее логарифма), то классы $DTime$ не равны.
		Теперь возьмём его унарную версию: $L' = \{ 1^n \mid n \in L\}$.
		Она нам подходит.

		От противного: пусть $L' \in \P$.
		Тогда $L \in \EXP$ (так как число $n$ длины $\log n$ можно разрешить за $Poly(n)=Poly(2^{\log n})=2^{C\cdot \log n}$).
		В частности, $L \in DTime\left[2^{Poly(n)}\right]$ для некоторого фиксированного полинома.
		Но $DTime\left[2^{Poly(n)}\right]~\subset~DTime\left[2^{2^{\sfrac n2}}\right]$ (так как экспонента больше любого полинома).
		Это противоречие "--- язык $L$ мы выбирали так, чтобы он там не лежал.

\problem{29}
	Разбирал семинарист.

	От противного: пусть $NTime[n] = \PSPACE$.
	Рассмотрим класс $NTime[n^2]$.
	Он, очевидно, лежит в $\PSPACE$ (так как для перебора подсказки нам надо $n^2$
	памяти, время экспоненциальное, но неважно).
	Но тогда $NTime[n^2] \subset NTime[n]$.
	Противоречие с теоремой об иерархии классов.

\problem{30}
	Разбирал семинарист.

	От противного: пусть $DSpace[n] = \NP$.
	Тогда возьмём язык $L \in DSpace[n^2]$.
	Построим язык $L' = \{ x\t{0}\t{1}^{|x|^2} \mid x \in L \}$.
	Он, очевидно, лежит в $DSpace[n]$ (так как можно запустить алгоритм для $L$, откинув мусор "--- для этого
	вообще только константа памяти нужна).
	Значит $L' \in \NP$.
	Значит $L \in \NP$, так как можно просто дописать полином единичек ко входу и запустить алгоритм для $L'$.
	Значит $L \in DSpace[n]$, противоречие, так как мы знаем теорему об иерархии по памяти.

\problem{20}
	Разбирал семинарист.

	Нужно взять правильные версии задач об ограниченной остановке.

	\subsubsection{EXP}
		\[ BH_{EXP} = \{ (M, x, t) \mid \text{ДМТ $M$ принимает $x$ за $t$ шагов} \} \]
		Эта задача лежит в $\EXP$: нам надо считать вход длины $k=\log x$ и проэмулировать
		$x$ шагов машины Тьюринга, это можно делать за $\O(x \cdot \log x)=\O(2{|x|}\cdot |x|)$, что лежит
		в $\EXP$.

		Любая задача из $\EXP$ к этой сводится, так как для любой задачи есть машина $M$
		и некоторое ограничение сверху (экспоненциальное от $|x|$) на время работы.
		Давайте его посчитаем, получим что-то длины порядка $2^{Poly(|x|)}$.
		Запустим машину $M$ в течение $2^{|x|}$ шагов при помощи задачи $BH_{EXP}$,
		получим ответ.

	\subsubsection{NEXP}
		Абсолютно то же самое, но машина теперь недетерминированная.

	\subsubsection{NE}
		Конструкция та же самая:
		\[ BH_{NE} = \{ (M, x, t) \mid \dots \} \]
		Всё еще никакие рассуждения не ломаются:
		\begin{itemize}
			\item Если была задача из $NE$, то она решалась за $2^{cn}$, а длина входа, которую мы должны посчитать и выдать задаче $BH_{NE}$ ровно такая
			\item Задача $BH_{NE}$ всё еще лежит в $NE$, потому что $t$ шагов мы эмулируем за следующее время:
				\[ \O(t \cdot \log t) = \O(2^{|t|} \cdot |t|) = \O(2^{|t|+\log |t|}) = \O(2^{2|t|}) \]
		\end{itemize}

	\subsubsection{Альтернативные}
		Без доказательства, просто пример.

		NEXP-полная задача из жизни: пусть есть некоторая схема с больш\'им количеством входов и выходов.
		Она задаёт какую-то булеву формулу в КНФ следующим образом: если подать схеме на вход число $n$,
		она выдаст клоз с номером $n$.
		Надо понять, разрешима ли формула.

		Для NE, кажется, пример тот же, но только у нас формулы из 3-КНФ, но это неточно.

\problem{23}
	Разбирал семинарист.

	\subsubsection{а}
		Конфигураций у машины Тьюринга из $\mathsf{L}$ всего полином от длины входа.
		Давайте мы её запустим, если конфигурация повторилась "--- какая-то фигня, машина зациклилась и не может являться разрешающей для некоторого языка.
		А если не повторилась "--- мы сделали не более полинома шагов.

	\subsubsection{б}
		Надо заметить, что сведение из теоремы Кука-Левина (которая про NP-полноту SAT) на самом деле требует логарифмической памяти:
		там мы генерировали формулу по уровням, на каждом уровне было константное число гейтов,
		зависящих только от константного числа гейтов на предыдущем уровне.
		Можем за логарифмическую память сгенерировать схему, за логарифмическую память решить её, а композиция МТ
		с логарифмической памятью тоже использует логарифм памяти.

\problem{27}
	Разбирал семинарист.

	Занумеруем вообще все алгоритмы (каждый "--- бесконечное число раз): $M_1, M_2, \dots, M_k, \dots$.
	Теперь построим язык $L$: $x \in L$, если и только если машина $M_{|x|}$ на $x$ ответила 0 или проработала
	больше $|x|^{2.1}$.
	Очевидно, что $L$ разрешается за $\O(n^3)$.
	\begin{Rem}
		Тут мы для слова $x$ запускаем машину $M_{|x|}$, а не $M_x$.
		А в целом конструкция опять похожа на \hyperref[prob16]{задачу 16} "--- та же диагонализация.
	\end{Rem}

	Теперь предположим, что есть машина $M_k$, разрешающая $L$ за квадрат.
	Возьмём достаточно большой её номер $k$ так, чтобы она стала успевать отрабатывать на входах длины $k$.
	Тогда заметим, что она ошибётся вообще на всех входах длины $k$.

\section{Организационное}
	28 марта после пар "--- зачёт.
	Выдаются задачи из прошлых (и не только).
	Будут бонусы тем, кто много решал, о них мы когда-нибудь узнаем.
