\chapter{Занятие 27.04.2016}

\section{Разбор задач}
\problem{26}[полное решение]
	Разбирал Дима Розплохас.

	Будем называть схему \textit{$n$-маленькой}, если она имеет размер не более $\frac{2^n}{10n}$.
	Нам надо в предположени $\P=\NP$ найти язык $L \in \EXP$ такой, что его нельзя распознать $n$-маленькими схемами.
	Давным-давно мы уже выяснил, что для любого $n\ge100$ есть язык $L_n$ бинарных слов длины $n$ такой,
	что он не распознаётся $n$-маленькими схемами (мы это доказывали, посчитав количество схем).
	Раз существует хотя бы один, то среди них можно выбрать лексикографически минимальный.

	Давайте лексикографически минимальные $L_n$ объединим для всех $n$, построим язык $L$.
	Мы знаем, что он не распознаётся $n$-маленькими схемами.
	Теперь надо доказать, что он лежит в $\EXP$

	Л.О.: задача такая: дан язык слов длины $n$ "--- $L$.
	Дана схема $C$ с $n$ входами, надо проверить: верно ли, что схема распознаёт этот язык.
	Вход: характеристическая функция языка и сама схема.
	Выход: один бит.
	Эта задача лежит в $\co\NP=\Pi_1$: в качестве подсказки принимаем слово, которое схема распознаёт неправильно
	(т.е. такое $x$, что $L(x) \neq C(x)$).

	Л.О.: пусть есть язык $L$ слов длины $n$.
	Надо проверить, что есть какая-то $n$-маленькая схема, распознающая наш язык.
	Вход: характеристическая функция языка $L$.
	Это задача из $\NP^{\co\NP}=\Sigma_2$ "--- принимаем подсказку длины $\O(2^n)$ (т.е. как вход) и проверяем
	её на оракуле из $\co\NP$ (см. предыдущую задачу).

	Л.О.: на вход дана характеристическая функция языка $L \subset \{0, 1\}^n$.
	Надо проверить, верно ли, что $L$ не распознаётся $n$-маленькими схемами и что нет лексикографически меньшего языка с тем же свойством (т.е. $L=L_n$).
	Эта задача лежит в $\co\NP^{\NP^{\co\NP}}=\Pi_3$.
	Утверждение: $L=L_n$ если для всех языков $L'$ верно следующее:
	\[
		(L~\text{не распознаётся маленькой схемой}) \land ((L'~\text{распознаётся}) \lor (L\leq L'))
	\]

	Л.О.: дано слово $x$ произвольной длины, надо проверить, что он лежит в языке $\cup L_n$.
	Эта задача лежит в $\NEXP^{\co\NP^{\NP^{\co\NP}}}$.
	Давайте в качества оракула возьмём предыдущую задачу.
	Подсказка "--- язык для слов длины $|x|$, надо проверить что этот язык действительно является $L_n$
	и что $x$ лежит в этом слове.

	Теперь, так как $\P=\NP$, то полиномиальная иерархия схлопывается и $\NEXP^{\Pi_3}=\NEXP^{\P}$,
	а полиномиальный оракул нафиг не нужен $\NEXP^\P=\NEXP$, а потом по какой-то древней задаче $\NEXP=\EXP$.

	\begin{Rem}
		В прошлый раз сломались в том месте, где у нас оракулы были экспоненциальные.
		У нас под кванторами стояли длинные переменные, мы не догадались, что на самом деле можно одно из двух:
		\begin{itemize}
			\item Попросить на нижнем уровне расширить вход от $x$ до $(x, 1^{2^{|x|}}$ и получить, что в оракулах входы уже не экспоненциальной, а полиномиальной длины
			\item
				Расписать формулу с кванторами и понять, что у нас написан $\NEXP$ в степени формулы без первого квантора.
				Но у этого оракула вход экспоненциальный, а вот внутри "--- уже полиноми от этой экспоненты
		\end{itemize}
	\end{Rem}

\subproblem{58}{а}
	Разбирала Надежда Бугакова.

	Сначала включение $\P\subseteq \PCP(0, \log(n))$.
	В самом деле: алгоритм из $\PCP$ просто не будет спрашивать подсказку и честно проверит.

	Обратно: $\PCP(0, \log(n)) \subseteq \P$.
	Неадаптивно: мы на фиксированном входе всегда обращаемся к одним и тем же битам подсказки, давайте
	переберём их все возможные значения и проверим.

	Адаптивно: давайте строить дерево перебора, надо ещё проверять, что нет противоречий с предыдущими битами подсказки.

\subproblem{58}{б}
	Разбирала Надежда Бугакова.

	То же самое, что и в пункте <<а>>.
	Включение $\NP\subseteq \PCP(0, poly(n))$ очевидно, так как алгоритм из $\NP$ просто спрашивает
	полином битов подсказки, один за другом (а в $\PCP$ можно спрашивать любые).

	Для неадаптивного: просим в качестве подсказки те биты, которые мы будем смотреть на данном входе.

	Для адаптивного: наша НМТ работает и когда хочет считать бит из подсказки, она принимает недетерминированное решение.
	Только надо проверять, что мы из одного и того же места <<подсказки>> читаем одни и те же биты.

\subproblem{56}{а}
	Разбирал Егор Суворов.

	\begin{Rem}
		Также хочется выполнить даже более сильное условие: чтобы для любой раскраски в три цвета
		вершин $T$, $t_1$, $t_2$ существовала правильная раскраска.
		Это мы создадим такой <<гейт>>, из которого потом составим схему.
	\end{Rem}
	Физический смысл такой: ровно один цвет соответствует \t{true} (цвет вершины $T$),
	оставишеся два цвета "--- \t{false} (обозначим их $F_1$, $F_2$).
	В этой задаче нас просят создать гейт <<или>> для двух вершин.

	Сначала построим гейт <<не>> "--- по вершине $T$ и <<входу>> $t$ будет выдавать на $r$
	отрицание $t$ (если отрицание неоднозначно "--- $F_1$ или $F_2$, то может выдать любое).
	\begin{center}
		\begin{dot2tex}[scale=0.8,options=-tmath]
			graph G {
				{rank=same; T t}
				T -- f;
				t -- f -- r -- t;
			}
		\end{dot2tex}
	\end{center}
	Доказательство корректности: заметим, что в треугольнике все цвета должны быть различны, причём
	цвет вершины $f$ должен быть какой-то ложью.
	Если цвет $t$ "--- \t{true}, то цвет вершины $r$ будет какой-то ложью (на выбор).
	Если же цвет $t$ "--- $F_1$ или $F_2$, то вершина $f$ примет значение второй лжи, а
	вершине $r$ останется только истиниа.

	Далее мы будем обозначать построение гейта <<не>> ребром синего цвета.

	Теперь, соединив последовательно два гейта <<не>>, можно получить элемент копирования, который
	по истине выдаёт истину, а по какой-то лжи "--- произвольную ложь (т.е. даже если на входе имеется
	$F_1$, то гейту дозволяется выдать как $F_1$, так и $F_2$).

	Попробуем построить элемент <<не-или>>:
	\begin{center}
		\begin{dot2tex}[scale=0.8,options=-tmath]
			graph G {
				{rank=same; T t_1 t_2}
				{t_1 t_2} -- r
			}
		\end{dot2tex}
	\end{center}
	Если хотя бы одна из вершин $t_1$ и $t_2$ есть \t{true}, то на выходе получим ложь, как и надо.
	Если они имеют разные цвета \t{false}, то на выходе гарантированно получим \t{true}.
	Но возникает проблема, если $t_1$ и $t_2$ покрашены в один цвет $F_1$,
	тогда на выходе получим либо $T$, либо $F_2$, что нехорошо.

	Теперь строим элемент <<не-или>> по-нормальному:
	\begin{center}
		\begin{dot2tex}[scale=0.8,options=-tmath]
			graph G {
				{rank=same; T t_1 t_2}
				{rank=same; f_1 f_2}
				{rank=same; x_1 x_2}
				{rank=same; y_1 y_2}
				T -- f_1 -- f_2 -- T;
				t_1 -- x_1 [color=blue];
				t_2 -- x_2 [color=blue];
				x_1 -- y_1 [color=blue];
				x_2 -- y_2 [color=blue];
				f_1 -- y_1
				f_2 -- y_2
				{y_1 y_2} -- r
			}
		\end{dot2tex}
	\end{center}
	Тут мы сначала сначала цвета $F_1$ и $F_2$, построим треугольник с вершиной $T$.
	Потом строим вершины $y_1$ и $y_2$, которые имеют такой же
	логический смысл, как и $t_1$, $t_2$, но вершина $y_1$ не может иметь цвет
	$F_1$, а вершина $y_2$ "--- цвет $F_2$.
	Поэтому если $y_1$ и $y_2$ имеют цвет лжи, то это разная ложь, и вершина $r$ может быть
	покрашена только в цвет $T$, что и требовалось.

	Также можно добавить ещё один гейт <<не>>, чтобы получить <<или>> и решить пункт <<а>>.

\subproblem{56}{б}
	Разбирал Егор Суворов.

	Гейт <<или>> для трёх элементов "--- это просто соединение двух гейтов <<или>> для двух элементов.

\subproblem{56}{в}
	Разбирал Егор Суворов.

	\TODO
	Надо вспомнить теорему Кука-Левина и построить по машине Тьюринга и входу для неё схему,
	которая эмулирует МТ, а дальше преобразовать схему в неориентированный граф, который надо раскрасить
	в три цвета (пользуемся тем, что через гейт <<не-или>> всё выражается).

\subproblem{53}{а}
	В нумерации в задании 11 имела неправильный номер 56.
	Разбирала Оля Черникова.

	Хочется взять какую-нибудь $\co\NP$-полную задачу и свести её к $USAT$.
	Например, $UNSAT$ (язык невыполнимых формул).
	\begin{Rem}
		Считаем, что его $\co\NP$-полнота очевидна.
		\TODO
	\end{Rem}
	Давайте сводить эту задачу к $USAT$.
	Пусть есть формула $\phi$.
	Рассмотрим формулу $(\phi) \lor (x_1 \land \dots x_n)$, у неё есть хотя бы одно решение.
	Есть проблема: склеились случаи <<$\phi$ имела ровно одно решение из всех единиц>> и <<$\phi$ невыполнима>>.
	Расклеиваем:
	\[
		\tau \coloneq (\phi) \lor (x_1 \land \dots x_n) \lor ((\lnot x_1 \land \dots \lnot x_n) \lor \phi[1, \dots, 1])
	\]
	Докажем, что у $\tau$ ровно одно решение $\iff$ формула $\phi$ невыполнима.

	В одну сторону: если $\phi$ невыполнима, то первый дизъюнкт будет нулём всегда, последний "--- тоже (так как невыполнима, в частности, в случае $x_i=1$).
	А центральный будет единицей ровно один раз.

	В другую сторону: если $\phi$ выполнима, то у $\tau$ есть хотя бы два выполняющих набора.
	Один точно есть: $x_i=1$.
	Если у $\phi$ имеется какой-то другой выполняющий набор, то успех.
	Если же $\phi$ выполнима только в случае $x_i=1$, то в последнем дизъюнкте будет второй конъюнкт равен единице,
	т.е. у $\tau$ появится выполняющий набор $x_i=0$.

	\begin{Rem}
		Комментарий от Егора: необязательно записывать всё в одну формулу, наше сведение может само подставить $x_i=1$ в формулу.
		Если не выполнилась "--- дописываем только дизъюнкт и успех.
		Если выполнилась "--- уже знаем ответ, надо выдать что-то с таким же ответом, например, что-то противоречивое: $x_1 \land \lnot x_1$.
	\end{Rem}

\subproblem{53}{б}
	Разбирала Оля Черникова.

	Хотим показать, что $USAT \in \P^{\NP}$.
	Дана формула $\phi$.
	Давайте сначала проверим, что у формулы $\phi$ есть какое-то решение "--- это одно обращение к оракулу для $SAT$.

	Дальше проверим, что нет двух разных решений "--- это задача из $\co\NP$ (так как легко опровергнуть, подсказка "--- два решения).
	А её отрицание "--- задача <<есть хотя бы два решения>> "--- это задача из $\NP$, она сводится к $SAT$.
	Это ещё одно обращение к оракулу.
