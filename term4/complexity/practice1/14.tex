\chapter{Занятие 11.05.2016}

\section{Разбор задач}
\problem{62}
	Разбирал семинарист.

	Переформулировка задачи: мы умеем считать перманент с вероятностью $1-\epsilon$,
	но вероятность берётся по входам.
	А мы хотим научитьс считать перманент на всех входах с вероятностью по случайным битам.

	\begin{Rem}
		Будем действовать по аналогии с тестом на линейность с коррекцией ошибок.
		Там у нас была функция $f$, близкая к линейной (т.е. которая в небольшой доле точек
		отличается от линейной).
		Там мы вместо подсчёта значения $f(x)$ считали значение в случайной точке $r$,
		в точке $x+r$ и полагали, что $f(x)=f(r)+f(x+r)$ "--- это корректное значение,
		если две случайные точки ($r$ и $x+r$) попали в корректные значения.
	\end{Rem}

	Теперь решаем задачу.
	Пусть нам надо посчитать перманент матрицы $A$.
	Давайте возьмём случайную матрицу $B$ и чисто теоретически рассмотрим такой перманент:
	\[ \perm(A + tB) \]
	Это многочлен от $t$ степени не более $n$ над полем $\mathrm{F}$.
	Давайте возьмём $n+1$ случайную точку в поле ($r_1, \dots, r_{n+1}$) и посчитаем перманенты следующих матриц:
	\[
		\perm(A + r_1B),
		\perm(A + r_2B),
		\dots
		\perm(A + r_{n+1}B)
	\]
	Это мы получили значения полинома в $n+1$ точке, можно проинтерполировать, получить в явном виде
	полином и взять его значение в точке ноль.
	Всё получится успешно, если мы правильно посчитаем каждый из $n+1$ перманента случайных матриц.
	Вероятность ошибки в одной матрице не более $\frac{1}{3n}$, а для $n+1$ ошибка не более:
	\[
		\frac{n+1}{3n} = \frac{1+\frac1n}{3} < \frac12
	\]
	Ура, получили алгоритм, которых с хорошей вероятностью по случайным битам считает определитель правильно.

\subproblem{44}{в}[сложное решение]
	Разбирал семинарист.
	Решение ниже автором конспекта не понято и не дописано до конца.

	Докажем что $\BPTime[n^{\log n}] \neq \BPTime[2^n]$ от противного (остальное показали раньше).
	Тогда из пункта <<а>> мы знаем, что если $f(n)\ge n$, то:
	\[ \BPTime[f(n)^{\log f(n)}] = \BPTime[2^{f(n)}] \]
	Из пункта <<б>> знаем, что:
	\begin{gather*}
		\BPTime[f(n)] \subseteq \DTime[2^{\O(f(n))}] \\
		\DTime[2^{f^2(n)}] \subseteq \BPTime[2^{f^2(n)}] \\
		\text{По иерархии по времени:} \\
		\DTime[2^{\O(f(n))}] \subsetneq \DTime[2^{f^2(n)}] \\
		\BPTime[f(n)] \subsetneq \BPTime[2^{f^2(n)}]
	\end{gather*}
	Давайте заведём функцию $f'$ и скажем, что:
	\[ f = f'^{\log f'} \]
	Подставляем в наше знание про $\BPTime$:
	\[
		\BPTime[f'^{\log f'}] \subsetneq \BPTime[2^{f'^{2\log f'}}] \\
		\text{Подставляем знание из пункта <<а>>:} \\
		\BPTime[2^{f'}] \subsetneq \BPTime[2^{f'^{2\log f'}}]
		\text{Подставили $f'=n$} \\
		\BPTime[2^{n}] \subsetneq \BPTime[2^{т^{2\log n}}]
	\]
	Применили пункт <<а>> с параметрами $f=n$, $g=2^{2^{(2\log \log n)^2}}$, $h=2^n$, получили:
	\[
		\BPTime[n] \subsetneq \BPTime[2^{2^{(2\log \log n)^2}}]
	\]
	Подставим сюда $n=n'^{\log n'}$, дальше \TODO (и выше надо поменять $\subsetneq$ на $\not\supseteq$), получим противоречие:
	\begin{gather*}
		\BPTime[n'^{\log n'}] \not\supseteq \BPTime[2^{2^{8\log \log^2 n}}] \\
		\BPTime[2^{n'}] \not\supseteq \BPTime[2^{2^{8\log \log^2 n}}]
	\end{gather*}
	Но слева стоит функция больше, чем справа, противоречие.

\subproblem{44}{в}[простое решение]
	Решение спросили у Кнопа.

	Опять же, будем доказывать только интересную часть: $\BPTime[n^{\log n}] \neq \BPTime[2^n]$.
	Докажем методом от противного (остальное показали раньше).
    
    Раз $\BPTime[n^{\log n}] = \BPTime[2^n]$, то мы можем воспользоваться пунктом <<а>> со следующими функциями:
    \begin{align*}
    	f(n) &= n^{\log n} \\
    	g(n) &= 2^n \\
    	h(n) &= 2^{\sqrt n} \\
    \end{align*}
    Получаем:
    \begin{align*}
    	\BPTime[\left(2^{\sqrt n}\right)^{\log 2^{\sqrt n}}] &= \BPTime[2^{2^{\sqrt n}}] \\
    	\BPTime[\left(2^{\sqrt n}\right)^{\sqrt n}] &= \BPTime[2^{2^{\sqrt n}}] \\
    	\BPTime[2^{\sqrt n \cdot \sqrt n}] &= \BPTime[2^{2^{\sqrt n}}] \\
    	\BPTime[2^n] &= \BPTime[2^{2^{\sqrt n}}]
    \end{align*}
    Можем применить пункт <<а>> с той же функций $h(n)$ ещё раз:
    \begin{align*}
    	\BPTime[2^{2^{\sqrt n}}] &= \BPTime[2^{2^{\sqrt{2^{\sqrt n}}}}] \\
    	\BPTime[2^{2^{\sqrt n}}] &= \BPTime[2^{2^{2^{\sfrac{\sqrt n}{2}}}}] \\
    \end{align*}
    Отсюда получаем:
    \[
	    \BPTime[n^{\log n}] = \BPTime[2^n] = \BPTime[2^{2^{\sqrt n}}] &= \BPTime[2^{2^{2^{\sfrac{\sqrt n}{2}}}}]
    \]
    С другой стороны:
    \begin{gather*}
    	\DTime[2^{\O(n^{\log n})}] \supseteq \BPTime[n^{\log n}] =
    	\BPTime[2^{2^{2^{\sfrac{\sqrt n}{2}}}}] \supseteq \DTime[2^{2^{2^{\sfrac{\sqrt n}{2}}}}] \\
    	\DTime[2^{\O(n^{\log n})}] \supseteq \DTime[2^{2^{2^{\sfrac{\sqrt n}{2}}}}]
    \end{gather*}
    Что противоречит иерархии по времени.

\problem{55}
	Разбирал Дима Розплохас.

	Построим такие языки $A$ и $L$, что $L \in \NP^A$, но $L \notin \P^{\mathsf{3-SAT}, A}$.
	
	У нас была теорема, в которой мы строили оракул $A$, разделяющие $\NP$ и $A$, в частности,
	ещё и такой язык $L$, что $L \in \NP^A$, но $L \notin \P^A$.
	Нам надо наложить дополнительное условие: $A$ является $\NP$-трудным, тогда, очевидно,
	сведение может использовать оракул для $\mathsf{3-SAT}$.

	Давайте возьмём доказательство той самой теоремы: в ней мы строили язык $A$,
	постепенно его разращивая по длинам.
	Давайте будем его разращивать по нечётным длинам, а чётные длины зарезервируем
	за формулами из $\mathsf{3-SAT}$, повторёнными два раза (т.е. пишем не формулу $\phi$,
	а строчку $\phi\phi$).
	Тогда, очевидно, $\mathsf{3-SAT}$ сводится к $A$.
	Но рассуждениями, полностью такими же, как в теореме, можно показать, что $\NP^A \neq \P^A$.
	\begin{Rem}
		Мы нигде пользовались тем, что язык "--- $\mathsf{3-SAT}$.
		Поэтому подойдёт любой язык.
	\end{Rem}

\problem{45}[попытка починки]
	Разбирал семинарист и завалился.

	Сначала напоминание прошлого решения.
	Нам дают $(y, m)$.
	Давайте возьмём случайный бит $b$ и случайное число $x \in \Z_m$.
	Если $b=0$, то пошлём Prover'у $x^2$, иначе пошлём $x^2y$.
	Спросим, прислали ли мы квадратичный вычет.
	Если $(y, m) = 1$, то мы победили и вероятности (вроде) хорошие.
	Если же $(y, m) \neq 1$, то $x^2y$ может оказаться квадратичным вычетом, даже если $y$ был невычетом.

	Чиним протокол.
	Давайте будем брать не просто случайный $x$, а взаимно простой.
	Проверим $(y, m)=1$, если это правда, то всё делаем как раньше.
	Иначе положим $l\coloneq (y, m)$.
	\TODO что-то доделали?
