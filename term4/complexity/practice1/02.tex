\chapter{Занятие 17.02.2016}
\section{Напоминание определений}

\begin{Def}
	Задача "--- множество пар $(x, y)$, тут $x$ "--- \textit{условие}, $y$ "--- \textit{решение}.
	Обозначаем принадлежность пары задаче как $R(x, y)$ "--- это бинарное отношение между
	условиями и решениями.
\end{Def}

\begin{Def}
	$\widetilde{NP}$ "--- множество задач $R$, обладающих следующими свойствами:
	\begin{enumerate}
		\item
			\textit{Полиномиальная ограниченность}: существует некоторый фиксированный
			полином $Poly(|x|)$ такой, что для любого $x$ верно следующее:
			если есть хотя бы одно решение $y$, то есть и решение $y'$ размера не более
			$Poly(|x|)$
		\item
			Существует алгоритм, который по паре $(x, y)$ проверяет отношение $R(x, y)$
			на детерминированной машине Тьюринга за полиномиальное время (полиномиальное
			от суммарного размера ввода "--- $Poly(|x| + |y|)$).
	\end{enumerate}
\end{Def}

\begin{Def}
	$\widetilde{P}$ "--- множество задач $R$, обладающих следующими свойствами:
	\begin{enumerate}
		\item $R \in \widetilde{NP}$
		\item
			Существует полиномиальный алгоритм, который умеет по условию $x$ находить некоторое
			решение $y$ такое, что $R(x, y)$, если оно существует.
	\end{enumerate}
\end{Def}

\section{Разбор задач}
\subsection{Соглашение по умолчанию}
	Обычно, если мы доказываем оценку снизу (<<нельзя быстрее>>), то считается, что
	мы доказываем это на обычной машине Тьюринга, где нет случайного доступа к памяти.

	А вот если мы хотим предъявить какой-то алгоритм с нужной асимптотикой, то мы обычно
	подразумеваем (если не сказано иное) RAM-машину, которая умеет обращаться к произвольной
	ячейке памяти за $\O(log M)$, где $M$ "--- количество ячеек пямяти.

\subsection{Задача 3}
	Разбирал Юра Ребрик.
	Тут в условии стоит исправить <<машина Тьюринга>> на <<RAM-машину>>.

	Надо найти алгоритм $\Pi(x, w)$, тут $x$ (условие) "--- это сам граф, а $w$ "--- подсказка.
	В качестве подсказки мы возьмём произвольный цикл нечётной длины в графе (необязательно простой).
	Подсказка "--- это максимум $V$ вершин, номер вершины имеет размер $\log V$.
	Надо просто проверить, что подсказка действительно является циклом нечётной длины.
	Надо проверить существование $V$ рёбер, это можно сделать за $V$ доступов к памяти, итого $\O(V \log V)$.

\subsection{Задача 1}
	Считаем, что очевидная и все решили.

	Решение от Егора: подсказка "--- это строка из $n$ единиц, где $n$ "--- число
	шагов, за которое останавливается алгоритм.
	Проверить очевидно: берём и эмулируем.
	
\subsection{Задача 2}
	Разбирал Никита Подгузов.

	Строим алгоритм $\Pi(x, w)$.
	Условие "--- две матрицы (работаем на этакой псевдо-RAM-машине, доступ к произвольной ячейке памяти).
	Подсказка "--- координаты ячейки произведения, которая не равна нулю.
	Чтобы проверить подсказку, нам надо посчитать $n$ произведений числа размера $\log n$,
	это можно сделать за $\O(n\cdot\log n \cdot \log n) \subseteq \O(n^2)$.
	Далее надо сложить $n$ чисел размера $2\log n$ каждое, это легко за $\O(n^2)$ делается.

\subsection{Задача 4}
	Разбирал Игорь Лабутин.

	Пусть у нас есть какая-то хорновская формула.
	Давайте сначала попробуем присвоить всем переменным значение 0.
	У нас выполнились все дизъюнкты, кроме дизъюнктов, состоящих только из
	одной переменной (потому что в остальных входит хотя бы одна переменная с отрицанием).
	Тогда эта переменная, очевидно, должна иметь значение 1.
	Подставим это значение в формулу, выкинем все вычисленные дизъюнкты.
	На каждом шаге у нас длина формулы уменьшается, и нам надо посмотреть всю формулу.
	Получаем квадрат от длины формулы "--- полином.

\subsection{Задача 5}
	Разбирал Петя Смирнов.

	Возьмём формулу в КНФ.
	Пусть есть клоз, в котором хотя бы три литерала: $(a_1 \lor a_2 \lor \dots \lor a_k \lor \lnot b_1 \lor \lnot b_2 \lor \dots \lnot b_l)$.
	Давайте введём новые переменные $x_1 = \lnot a_1$, \dots, $x_k = \lnot a_k$.
	Перепишем клоз так, чтобы он стал Хорновским: $(\lnot x_1 \lor \ldots \lor \lnot x_k \lor \lnot b_1 \lor \dots)$.
	Осталось лишь дописать в конец формулы условия на $x_i$: $(x_i \lor a_i) \land (\lnot x_i \lor \lnot a_i)$.

\subsection{Задача 6}
	Разбирала Оля Черникова.

	За $n$ обозначается длина входа.
	То есть рабочие ленты сильно меньше, чем вход, в частности,
	вход на рабочую ленту не переписать.

	\subsubsection{Заваленное решение}
	Скорее всего, доделывается.
	Интерпретируем условие так: у нас есть лента для входа, лента для выхода и ровно одна дополнительная
	рабочая лента (на ней можно и писать, и читать, и перемещаться).
	\begin{Rem}
		Замечание: кто сказал, что если функция считается за логарифм памяти на, скажем, трёх рабочих лентах (как в условии),
		то почему она считается за логарифм памяти на одной рабочей ленте?
		Надо честно показывать, что сведение многоленточной ДМТ к одноленточной не портит оценку памяти.
	\end{Rem}
	Итак, были ДМТ для $f(x)$ и $g(x)$, строим машину для $f(g(x))$.
	
	У неё тоже будет лента для входа, лента для выхода и одна рабочая лента.
	Идея такая: давайте запустим машину для $f(x)$ на рабочей ленте, а когда ей потребуется
	$i$-й символ входа, мы машину $f$ приостановим, и запустим машину $g$ на хвосте рабочей
	ленты, читать она будет с входной ленты, а вот выводить будет в самый первый элемент рабочей ленты.
	Так она будет работать, пока не выведет $i$-й символ вывода (который нужен $f$).
	В этот момент мы машину $g$ остановим и продолжим выполнение $f$.
	Лента будет выглядеть перед запуском $g$ так: пустое место для вывода машины Тьюринга,
	потом сохранённое состояние машины $f$, потом специальный символ, потом состояние машины для $g$.

	Как завалили: непонятно, как машина $g$ может вернуться обратно на старую позицию рабочей ленты,
	после того, как вывела символ в начало рабочей ленты.
	Состояний у нас у машины фиксированная константа, а вот размер памяти произвольно большой (хоть и логарифмический).

	\subsubsection{Починенное решение}
	\begin{Rem}
		Более глобальная проблема в задаче: что, если у нас $g$ выдаёт очень большой вывод,
		$f$ считается (по памяти) за логарифм от длины вывода $g$, но мы-то всё равно хотим
		посчитать $f(g(x))$ за логарифм от длины исходного ввода.
		Что делать?

		Ответ: давайте посмотрим, сколько конфигураций у ДМТ.
		Конфигурация машины "--- это внутреннее состояние (константа),
		умножить на память на лентах (их суммарная длина "--- $\O(\log n)$, т.е. на них
		состояний $\Sigma^{\O(\log n)} = e^{\O(\log n)} = n^{O(1)}$),
		умножить на текущую позицию на входной ленте (еще $n$).
		Итого получаем, что конфигураций конкретной машины всего лишь полином от длины входа ($n$),
		т.е. $Poly(n)$.
		Так как машина Тьюринга останавливается, то она останавливается за полиномиальное время,
		иначе какая-то конфигурация повторится.
		Значит, она не может вывести больше, чем некоторый фиксированный полином от длины входа.

		Таким образом, вход $f$ получится не более, чем в фиксированный полином раз больше исходного входа.
		Значит, памяти $f$ будет использовать не более, чем в фиксированную константу раз больше,
		чем $\O(\log n)$, т.е. тоже $\O(\log n)$.
	\end{Rem}

	Теперь интерпретируем задачу так: у нас машины могут иметь некоторое константное число лент.
	Иначе нужно озаботиться честным аккуратным сведением $k$-ленточной машины к одноленточной с сохранением количества памяти.
	Давайте построим машину для $f(g(x))$ "--- в ней будут рабочие ленты для $f$, рабочие ленты для $g$,
	плюс несколько вспомогательных рабочих лент: на одну мы будем писать последный символ, выведенный
	$g$, а также сколько символов ей еще осталось вывести, чтобы вывести интересующий $f$ символ,
	на другой мы будем писать номер символа, на который сейчас указывает указатель входа для $f$.

	То есть алгоритм такой: мы запускаем $f$, поддерживаем на одной из рабочих лент номер символа,
	который может считать $f$.
	Когда она хочет его считать "--- мы запускаем $g$ с самого начала и работаем в ней, пока у нас не
	машина для $g$ не выведет нужный по номеру символ.

	\begin{Rem}
		Кажется, что можно даже разрешить ходить по выходной ленте влево-вправо, тогда
		всё еще ничего не сломается.
		Но вот разрешать с неё читать всё еще нельзя, так как тогда у нас получится дополнительная линия памяти.
	\end{Rem}

\subsection{Задача 7}
	Разбирал Сева Степанов.

	Возьмём граф.
	Удалим некоторое ребро $e$, запустим оракула.
	Есть в результате Гамильтонов цикл всё еще остался, то можно это ребро выкинуть окончательно.
	Если же исчез, то это ребро должно обязательно лежать в Гамильтоновом цикле.
	Тогда у нас получается $|E|$ проверок на Гамильтоновость, итого полином.
	В конце получится просто $C_n$, потому что если есть некоторое ребро, которое не лежит хотя
	бы в одном Гамильтоновом цикле, то мы его обязательно удалим.

\subsection{Задача 8}
	Разбирал Дима Розплохас.

	Пусть у нас есть языки $L_1, L_2 \in NP$.
	Вспомним определение: $L \in NP$, если есть некоторое бинарное отношение $R \in \widetilde{NP}$
	такое, что $x \in L \iff (\exists y \colon R(x, y))$ (в частности, $R$ полиномиально проверяемо
	и полиномиально ограничено).
	Итак, пусть у нас для языков $L_1$, $L_2$ есть отношения $R_1$, $R_2$.

	Для языка $L_1 \cup L_2$ нас устроит отношение $R_1 \lor R_2$.
	Надо проверитЬ, что оно полиномиально ограничено: максимум из двух полиномов мы так просто, наверное, брать не умеем,
	поэтому возьмём их сумму (если беспокоитесь за отрицательные значения "--- возведите еще оба полинома в квадрат).
	И еще надо проверить полиномиальную проверяемость: запускаем сначала $R_1$ (за полиномиальное время),
	а потом $R_2$ (за полиномиальное время).

	Для языка $L_1 \cap L_2$ будет вводить более хитрое бинарное отношение.
	В качестве подсказки у нас теперь будут пары $\langle u, w \rangle$,
	где первый элемент пары "--- подсказка для проверки $x \in L_1$,
	а второй "--- подсказка для проверки $y \in L_2$.
	Пары мы умеем кодировать, например, так: $\langle x, y \rangle \lra (x+y)^2+x$.
	Итак, вводим отношение:
	\[ R(x, \langle u, w \rangle) = R_1(x, u) \land R_2(y, w) \]
	Оно полиномиально проверяемо: сначала раскодируем пару, потом запускаем $R_1$ и $R_2$.
	Осталась полиномиальная ограниченность: мы знаем, что если $x \in L_1 \cap L_2$,
	то есть полиномильно ограниченные (от $|x|$) подсказки $u$ и $w$.
	Закодированная ими пара тоже имеет полиномиально ограниченный размер (от $Poly(|x|)$).

\subsection{Задача 9}
\subsubsection{Решение с графом импликаций}
	Разбирал сначала Дима Лапшин, потом Егор Суворов

	Есть формула в 2-КНФ: $(x_1 \lor x_2) \land \dots$.
	Давайте построим граф, для каждой переменной заведём две вершины: $x_i$ и $\bar x_i$.
	Посмотрим на клоз $(x_i \lor x_j)$.
	Заметим, что он равносилен двум импликациям: $\lnot x_i \ra x_j$ и $\lnot x_j \ra x_i$.
	Давайте проведём такие рёбра в графе.
	Получаем, что если мы выберем в графе ровно половину вершины (при этом выберем либо $x_i$,
	либо $\lnot x_i$) так, чтобы все достижимые из выбранной тоже были выбранными, то исходная формула выполнима,
	и наоборот.
	
	\begin{assertion}
		Если у нас есть путь в графе $x_i \to \lnot x_i$, то значение
		$x_i=1$ брать нельзя (просто потому что тогда по импликациям получим противоречие).
	\end{assertion}
	\begin{assertion}
		Если у нас есть два пути $x_i \to \lnot x_i \lnot x_i$, то формула невыполнима.
		Просто потому что не можем выбрать значение для $x_i$.
	\end{assertion}

	Теперь самое интересное: почему если никаких таких явных противоречий нет, то формула выполнима.
	К сожалению, так просто сказать, что значения переменных $x_i$ можно выбирать произвольно, если
	нет путей $x_i \to \lnot x_i$ (и наоборот), нельзя, контрпример:
	\[ (a \lor b) \land (\lnot a \lor \lnot b) \]
	Тут у нас каждая переменная может принимать любое значение (поэтому, очевидно, путей $x_i \to \lnot x_i$
	нет), однако же они не независимы.

	Доказательство непротиворечивости от Егора: возьмём конденсацию графа импликаций и топологически её отсортируем.
	Так как очевидной непротиворечивости ($x_i \to \lnot x_i \to x_i$) нет, то для 
	каждой переменной одна из двух вершин ($x_i$ и $\lnot x_i$) лежит в топологической сортировке строго правее другой
	(при этом не обязательно достижима из той, что левее).
	Возьмём ту вершину, что правее.
	Покажем, что нет противоречий, т.е. вершины, достижимые из любой выбранной вершины, тоже выбраны.
	От противного: пусть есть выбранная вершина $a$, из неё достижима невыбранная $b$.
	Тогда мы знаем три вещи:
	\begin{enumerate}
		\item $a$ лежит <<нестрого левее>> $b$ в топологической сортировке.
		\item Так как $b$ не выбрана, то выбрана $\lnot b$, стало быть, $b$ лежит строго левее $\lnot b$.
		\item
			есть путь $\lnot b \to \lnot a$ (мы так строили граф: для любого ребра $x \to y$
			добавляли симметричное ему $\lnot y \to \lnot x$).
			Стало быть, $\lnot b$ лежит нестрого левее $\lnot a$.
	\end{enumerate}
	Комбинируя эти три вещи, получаем, что $a$ лежит строго левее $\lnot a$ в топологической сортировке,
	то есть мы на самом деле должны были выбрать $\lnot a$.
	Противоречие.

\subsubsection{Решение без графа импликаций}
	Разбирал семинарист Дмитрий Соколов.

	Выберем какую-нибудь переменную $x$.
	Попробуем подставить $x=1$ во все клозы: какие-то сразу выполнятся,
	в каких-то останется одна переменная.
	Из тех, в которых осталась одна переменная, мы сразу можем сделать вывод про какие-то оставшиеся переменные,
	их тоже подставляем.
	Так делаем, пока не останутся только клозы из двух переменных, либо пока не придём
	к противоречию.
	Это произойдёт за квадратичное время: у нас не более линии проходов, на каждом мы убиваем одну переменную.
	Если пришли к противоречию, то подставлять $x=1$ было нельзя, и тогда подставляем $x=0$ (единственный оставшийся вариант).
	Если же не пришли к противоречию, то у нас теперь имеется формула, являющаяся подмножеством исходной
	(это как раз то место, где мы пользуемся количеством переменных в клозе: если одну убили, то сразу можем
	сделать вывод про оставшуюся и убить клоз целиком).
	Т.о. если исходная была выполнима, то наша тоже выполнима.
	Повторили алгоритм еще раз.
	Итого полиномиальное от размера формулы время.

\subsubsection{Решение через резолюции}
	Оля Черникова заметила, что 2-КНФ мы разбирали в первом семестре у Ицыксона через метод резолюций:
	берём пару клозов, делаем резолюцию ($(x \lor y) \land (\lnot y \lor z) \Ra (x \lor z)$, пока не надоест.
	Всего у нас полиномиальное число возможных клозов, поэтому мы закончим за полиномиальное время.
	А в конце либо получим противоречие (вроде $x \land \lnot x$), либо, по полноте метода резолюций,
	противоречия не получим и тогда формула выполнима.
	Разбора у доски не было, это было сказано мимоходом.
