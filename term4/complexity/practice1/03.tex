\chapter{Занятие 24.02.2016}
\section{Замечание к задачам}
	Есть алгоритм Миллера-Рабина для проверки числа на простоту.
	К сожалению, он использует случайные биты, которых ни в одном определении у нас еще не было,
	что означает, что мы все алгоритмы считаем случайными, поэтому алгоритм Миллера-Рабина просто некорректен.
	Поэтому в задачах его использовать нельзя.
	Но бывают специальные классы сложности для рандомизированных алгоритмов, например, $\mathsf{BPP}$.
	Также конкретно алгоритм Миллера-Рабина иногда можно дерандомизовать: там мы выбираем
	случайное число в некотором диапазоне $[0, n]$.
	Но если верна гипотеза Римана, то хватит $[0; \log^2 n]$, поэтому можно просто перебрать отсюда все числа.
	К сожалению, никто не знает, верна ли она.

\section{Вопросы к лекции}
\subsection{Сведение по Левину}
	Попытка еще раз рассказать определение другими словами.
	Итак, было две задачи поиска: $R_1(x, w)$, $R_2(x, w)$ (тут $R_i$ "--- бинарные отношения между условиями и решениями).
	Говорим, что $R_1$ сводится по Левину к $R_2$, если:
	\begin{itemize}
		\item Есть три функции $f$, $g$, $h$ такие, что:
		\item
			$R_1(x, w) \Ra R_2(f(x), g(x, w))$ "--- функция $f$ переводит условие $R_1$ в условие $R_2$,
			а функция $g$ переводит решение $R_1$ в решение $R_2$.
			То есть если решалася $R_1$, то решается и $R_2$.
		\item
			Функция $g$ полиномиально ограничена "--- просто чтобы показать, что если есть решение $R_1$, то есть решение $R_2$
		\item
			$R_2(f(x), w) \Ra R_1(x, h(x, w))$ "--- если есть решение $R_2$, можно
			получить решение для $R_1$ задачи.
			То есть если решалась $R_2$, то решается и $R_1$.
		\item
			Функция $f$ полиномиально вычислима (и, следовательно, полиномиально ограничена) "--- чтобы условие росло не слишком сильно
		\item
			Функция $h$ полиномиально вычислима "--- чтобы мы могли переводить решение $R_2$ в решение $R_1$
	\end{itemize}
	Вообще говоря, иногда требуеют, чтобы все три функции были полиномиально вычислимы "--- просто для красоты
	(источник "--- сам Левин), на самом деле для функции $g$ это не требуется.

	\begin{exmp}
		Пусть мы свели по Левину задачу SAT к задаче поиска Гамильтонова цикла.
		Тогда как мы узнаём выполняющий набор для некоторой конкретной формулы?
		Мы берём формулу $x$, по ней строим некоторый граф $f(x)$, потом решаем задачу
		о нахождении цикла в этом графе, получаем цикл $w$ (т.е. сейчас верно $R_2(f(x), w)$),
		потом функцией $h$ переводим это решение в выполняющий набор для формулы "--- $h(f(x), w)$.
	\end{exmp}

\subsection{Задача об ограниченной остановке}
	Как мы доказывали $\widetilde{\NP}$-полноту этой задачи?
	\begin{Rem}
		Задача об ограниченной остановке, условие:
		\begin{itemize}
			\item $M$ "--- некоторая недетерминированная машина Тьюринга
			\item $x$ "--- её вход
			\item $1^t = \underbrace{111\dots11}_{t}$ "--- количество шагов, которым мы ограничиваем время рабоыт $M$
		\end{itemize}
		Искомое решение "--- подсказка для $M$, при которой она остановится на входе $x$ за $t$ шагов.
	\end{Rem}
	Доказывали по определению.
	Берём какую-нибудь задачу поиска из $\widetilde{\NP}$.
	По определению класса $\widetilde{\NP}$ она решается за полиномиальное время на недетерминированной машине Тьюринга.
	Тогда сведение произвольной задачи $A$ такое:
	\begin{enumerate}
		\item Взяли недетерминированную машину Тьюринга $M$, решающую задачу $A$
		\item Мы знаем, что $M$ решает задачу $A$ на входе $x$ за $P(|x|)$.
		\item
			Пусть нам дали вход $x$. Тогда построили задачу об ограниченной остановке недетерминированной
			машины Тьюринга: $(M, x, 1^{P(|x|)})$,
			это мы можем сделать за полиномиальное от $|x|$ время.
		\item
			Решили задачу об ограниченной остановке, узнали нужную подсказку для $M$.
		\item
			Теперь можем запустить $M$ с использованием этой подсказки как детерминированную машину,
			она отработает за полиномиальное время, получили требуемое решение задачи $A$.
	\end{enumerate}

\subsection{Сведение по Тьюрингу}
	Вопрос: почему сведение языков по Тьюрингу не равносильно many-one сведению (оно же <<по Карпу>>)?
	На самом деле, сведения по Карпу следует сведение по Тьюрингу.
	А вот наоборот \hyperref[task_14_rem_turing]{неверно}.

\section{Про зачёт}
	Комментарий по поводу зачёта: будет примерно как в прошлом семестре, но на промежуточном
	зачёте будут появляться новые задачи.
	Т.е. недостаточно уметь решать только разобранные задачи.

\section{Разбор задач}
\problem{12}
	Разбирала Лиза Третьякова.

	\subsubsection{а}
		Нужно показать, что $\P \subseteq \NP \cap \co\NP$ (это задачи типа <<да/нет>>).
		Будем показывать две вещи по отдельности:
		\begin{enumerate}
			\item
				$\P \subseteq \NP$.
				В самом деле: взяли произвольную задачу $A \in \P$.
				Она по определению решается на детерминированное машине Тьюринга за полином.
				Стало быть, на недетерминированной машине тоже решается за полином.
			\item
				$\P \subseteq \co\NP$.
				Аналогично.
				Берём произвольную задачу $A \in \P$.
				Она по определению решается на детерминированное машине Тьюринга за полином.
				Стало быть, если инвертировать ответ, тоже можем решить на ДМТ за полином.
				Стало быть, на недетерминированной машине задача с инвертированным ответом тоже решается за полином.
		\end{enumerate}

	\subsubsection{б}
		Давайте возьмём задачу $A \in \NP$ и НМТ для неё.
		Знаем, что длина подсказки для решения входа $x$ не больше $poly(|x|)$.
		Перебрали все подсказки за $2^{poly(|x|)}$

\problem{14}
	Исправление условия: пары неизоморфных \textit{графов}.

	Разбирал Дима Розплохас.

	Мы знаем, что задача проверки двух графов на изоморфность лежит в $\NP$,
	подсказка "--- перестановка вершин одного графа, проверка "--- перебор всех рёбер.
	Пусть у нас есть оракульная машина Тьюринга для этой задачи.
	Научим её решать задачу <<верно ли, что два графа \textit{не}изоморфны>>.
	Для этого берём два исходных графа, запускаем на них оракула, он нам выдаёт
	один бит: изоморфны ли графы.
	Надо этот бит инвертировать, это делается за константу.

	\begin{Rem}
		От семинариста: на самом деле, точно так же можно показать, что для любого
		класса $A$ верно:
		\[ \P^A = P^{\co A} \]
	\end{Rem}
	\begin{Rem}\label{task_14_rem_turing}
		Пример, когда сведение по Тьюрингу сильнее, чем по Карпу (это которое сводит задачу
		с условием $x$ к задаче с условием $f(x)$ с таким же ответом):
		пусть у нас есть классы $\NP$ и $\co\NP$.
		Где-то внутри класса $\NP$ живут $\NP$-полные задачи.
		Мы знаем, что $\NP$ сводится по Карпу к $\NP$-полным (по определению),
		а вот про $\co\NP$ мы такого не знаем, и вообще это открытый вопрос (Карп не разрешает нам что-то делать
		с ответом задачи).

		По Тьюрингу нам неважно, что сводить в $\NP$-полной задачи: язык или же дополнение языка,
		инвертировать ответ мы умеем.
		А вот по Карпу важно.
		Вообще говоря, неизвестно, замкнут ли $\NP$ относительно взятия отрицания (он несимметричен относительно
		ответов <<да/нет>>), поэтому было бы странно везде использовать Тьюринга.
	\end{Rem}

\problem{13}
	\subsubsection{От Егора Суворов}
		Покажем два включения.
		Включение $\EXP \subseteq \NEXP$ очевидно: берём исходную ДМТ, и получаем
		из неё НМТ, которая просто игнорируют подсказку.

		Теперь в другую сторону: пусть есть задача <<да/нет>> $A \in \NEXP$.
		Тогда для неё по определению есть НМТ $M$, которая за $2^{P(|x|)}$ определяет
		принадлежность слова $x \in A$.
		На лекции мы строили булеву схему размера $O(t^2)$ для недетерминированной машины, работающей не более чем $t$ шагов
		Входами у этой схемы были биты подсказки (всего $t$ штук), выходом "--- единственный бит: результат работы машины.
		Теперь у нас есть схема размера $O(t^2)=O(poly(t))=O(poly(2^{P(|x|)}))=O(2^{poly(|x|)})$ и,
		так как $\P=\NP$, мы умеем решать CIRCUIT-SAT на ДМТ за полином от размера схемы, что тоже есть $O(2^{poly(|x|)})$.
		Таким образом, мы научились решать сводить $A$ к CIRCUIT-SAT и всё решение вместе работает на ДМТ
		за $O(2^{poly(|x|)})$, т.о. $A \in \EXP$, что и требовалось.

	\subsubsection{От семинариста}\label{prob13_sol2}
		Пусть у нас есть язык $L \in \NEXP$ и есть $x$.
		Мы умеем проверять $x \in L$ за $2^{P(|x|)}$ на НМТ.
		Мы хотим научиться проверять, что $x\in L$ на детерминированной машине Тьюринга.
		Давайте рассмотрим такой язык $L'$:
		\[ L' = \{ x 0 1^{2^{P(|x|)}} \mid x \in L \} \]
		Это мы дописали к каждому слову $x$ нолик и фиксированное число единиц (зависящее только от длины $x$,
		причём в точности как время работы исходной НМТ для $L$).

		Заметим, что $L' \in \NP$, так как для этого надо всего лишь определить
		$x \in L$ за время $2^{P(|x|)}$ на НМТ, а мы это можем себе позволить "--- у нас на входе
		есть и $x$ и $2^{P(|x|)}$ мусора.
		Получаем алгоритм для НМТ для проверки $y \in L'$, работающий за линейное время.
		По предположению получаем $L' \in \P$.
		А значит, у нас верно и $L \in \EXP$: для поверки некоторого $x$ надо за $2^{P(|x|)}$ дописать
		к нему кучу мусора и за полиномиальное от $2^{P(|x|)}$ время (т.к. $L' \in P$) проверить.

\problem{11}
	Разбирала Оля Черникова.

	\subsubsection{Независимое множество}
		Будем доказывать $\NP$-полноту следующей задачи: верно ли, что в графе $G$ есть независимое множество размера ровно $k$ (оно же антиклика).
		Для этого научимся сводить 3-SAT к этой задаче.
		Пусть у нас есть КНФ из кучи термов.
		Рассмотрим один терм, у него есть семь выполняющих наборов и один невыполняющий.
		Каждому выполняющему набору каждого терма сопоставим вершину графа.
		Дальше соединим рёбрами противоречивые вершины графа (например, если одна считает $a=0$, а другая "--- $a=1$).
		В частности, для каждого клоза между соответствующими семью вершинами будут вообще все рёбра.
		Т.о. наш граф будет выглядть как много клик размера 7 с какими-то дополнительными рёбрами между ними.

		Теперь нам нужно из каждой группы выбрать по одной вершинке, причём так, чтобы никакие две не были соединены рёбрами.
		Пусть было $k$ клозов, тогда нам надо найти в графе антиклику (независимое множество) размера ровно $k$.
		Понятно, что если найдём такую, то мы сразу восстанавливаем ответ: в каждом клозе выбран ровно одна вершина.

	\subsubsection{б}
		Научимся сводить задачу поиска антиклики размера $k$ (которая, как мы доказали, $\NP$-полная) к задаче поиска клики размера $k$.
		Пусть нам дали граф $G$, давайте инвертируем в нём все рёбра, получим граф $G'$.
		Заметим, что антиклики в графе $G$ однозначно соответствуют кликам размера $k$ в графе $G'$.
		Значит, если научимся искать клику размера $k$ в графе $G'$, то научимся искать антиклику размера
		$k$ в графе $G$, то есть научимся решать любую задачу.

	\subsubsection{в}
		Заметим, что дополнение произвольной антиклики есть покрывающее множество (такое,
		что все рёбра имеют хотя бы один конец в нём), и наоборот.
		В самом деле: если была антиклика $A$, то любое ребро имеет хотя бы один конец вне $A$.
		И наоборот: если было покрывающее множество, то его дополнение есть антиклика.

		Заметим, что задача поиска антиклики размера $k$ (NP-полная) сводится к задаче поиска
		покрывающего множества размера $\le n-k$, покажем таким образом NP-полноту задачи
		поиска покрывающего множества.
		В самом деле: взяли тот же граф, нашли в нём покрывающее множество размера $n-k$.
		Взяли его дополнение, это антиклика размера $\ge k$.
		Выбрали из неё произвольные $k$ вершин, получили антиклику размера ровно $K$.

	\subsubsection{а}
		Давайте сведём задачу поиска клики (пункт <<б>>, NP-полная) к задаче из пункта <<а>>.
		Берём граф $G$, в котором надо найти клику размера $k$.
		Давайте возьмём граф $K_k$ (полный граф на $k$ вершинах).
		Узнаем, есть ли в $G$ подграф, изоморфный $K_k$ "--- это как раз задача из пункта <<а>>.
		Тогда мы в точности поняли, есть ли в $G$ клика размера $k$, что и требовалось.

\problem{15}
	Комментарий к условию: унарный язык $L$ "--- это некоторое подмножество $\{1\}^*$,
	то есть это все слова, в которых используется ровно один символ, а вот длина "--- из некоторого
	счётного множества, характеризующего язык.
	При этом подсказки у нас по-прежнему из $\{0,1\}^*$, то есть их много, несчётно.

	В результате последнего комментария все, кроме Димы Розплохаса, отказались от своего решения.
	Разбирал, разумеется, Дима Розплохас.
	Егор Суворов ничего не понял :(
	Потом спросил у Пети Смирнова, решение такое (должно быть похоже), ему рассказал семинарист:

	Давайте научимся решать задачу SAT за полиномиальное время, тогда $\P=\NP$.
	Мы знаем, что есть полиномиальное полиномиально ограниченное сведение $f$,
	которое по любой формуле $\phi$ выдаст некоторое слово длины не более $Poly(|\phi|)$,
	которое принадлежит языку $L$ тогда и только тогда, когда $\phi$ разрешима.
	\begin{assertion}
		Если у нас есть формулы $\phi_1$ и $\phi_2$, причём $f(\phi_1) = f(\phi_2)$,
		то $\phi_1$ и $\phi_2$ либо одновременно разрешимы, либо одновременно неразрешимы.
	\end{assertion}
	Теперь у нас есть конкретная формула длины $l$ с $k$ переменными.
	Давайте будем в лоб перебирать значения всех переменных, а чтобы не получить экспоненциальное
	время работы, будем из набора формул с одинаковым образом $f$ оставлять только одну, неважно какую.
	Алгоритм получается такой: на каждом из $k$ шагов у нас имеется множество $S$ из $Poly(l)$
	формул, выполнимость исходной эквивалентна существованию выполнимой формулы в $S$.
	Дальше мы в каждую формулу из $S$ подставляем по очереди два значения переменной $x_i$,
	получаем множество из $2S$ формул, но в них уже меньше неизвестных.
	А теперь склеиваем формулы с одинаковыми образами, опять получаем не более $Poly(l)$ формул.

	Важно, что $l$ "--- это длина самой исходной формулы.
	То есть у нас имеется не более $l$ шагов (так как $k \le l$), на каждом у нас не более
	$Poly(l)$ формул, на каждом шаше за полиномиальное от числа формул время мы можем убрать из
	них одну переменную и убрать лишние переменные.
	Так как формул всегда полином и шагов полином, в сумме получаем полином, что и требовалось:
	получили решение SAT за полином.

\section{Бонусная задача}\index{Бонусная задача от 24.02.2016}
	Сложная. Стоимость "--- четыре задачи.
	Вот в задаче 15 был унарный язык.
	\begin{Def}
		Sparse-языки: $L \in \mathsf{Sparse}$ тогда и только тогда, когда есть некоторый
		полином $P$ такой, что количество слов длины ровно $n$ в языке $L$ не более
		$P(n)$.
	\end{Def}
	Задача: если есть хотя бы один $\mathsf{Sparse}$-язык, то $\P=\NP$.
	Нужно как-то модифицировать решение задачи 15, но это не слишком просто.
	Но можно.
